{"version":3,"sources":["webpack://rock-raiders-web/./site/clearcache/clearCacheButton.css","webpack://rock-raiders-web/./site/github/github.css","webpack://rock-raiders-web/./site/clearcache/clearCacheButton.css?9693","webpack://rock-raiders-web/./site/clearcache/ClearCacheButton.ts","webpack://rock-raiders-web/./site/github/github.css?bbb3","webpack://rock-raiders-web/./site/github/github-box.ts","webpack://rock-raiders-web/./site/modal/WadFileSelectionModal.ts","webpack://rock-raiders-web/./src/core/Util.ts","webpack://rock-raiders-web/./src/game/model/EntityType.ts","webpack://rock-raiders-web/./src/game/model/raider/RaiderTool.ts","webpack://rock-raiders-web/./src/game/model/map/SurfaceType.ts","webpack://rock-raiders-web/./src/game/model/raider/RaiderTraining.ts","webpack://rock-raiders-web/./src/game/model/Selectable.ts","webpack://rock-raiders-web/./src/event/LocalEvents.ts","webpack://rock-raiders-web/./src/game/model/GameState.ts","webpack://rock-raiders-web/./src/game/model/anim/AnimationEntityType.ts","webpack://rock-raiders-web/./src/screen/DebugHelper.ts","webpack://rock-raiders-web/./src/event/GuiCommand.ts","webpack://rock-raiders-web/./src/game/model/collect/BarrierLocation.ts","webpack://rock-raiders-web/./src/event/WorldEvents.ts","webpack://rock-raiders-web/./src/game/model/activities/BaseActivity.ts","webpack://rock-raiders-web/./src/game/model/activities/AnimEntityActivity.ts","webpack://rock-raiders-web/./src/game/model/activities/BarrierActivity.ts","webpack://rock-raiders-web/./src/game/model/activities/RaiderActivity.ts","webpack://rock-raiders-web/./src/game/model/PathTarget.ts","webpack://rock-raiders-web/./src/game/model/job/JobState.ts","webpack://rock-raiders-web/./src/game/model/job/JobType.ts","webpack://rock-raiders-web/./src/game/model/job/PriorityIdentifier.ts","webpack://rock-raiders-web/./src/game/model/job/Job.ts","webpack://rock-raiders-web/./src/game/model/job/surface/CompletePowerPathJob.ts","webpack://rock-raiders-web/./src/game/model/building/BuildingSite.ts","webpack://rock-raiders-web/./src/game/model/map/WallType.ts","webpack://rock-raiders-web/./src/game/model/map/SurfaceGeometry.ts","webpack://rock-raiders-web/./src/game/model/building/BuildPlacementMarkerMesh.ts","webpack://rock-raiders-web/./src/game/model/building/BuildPlacementMarker.ts","webpack://rock-raiders-web/./src/game/model/map/astar.ts","webpack://rock-raiders-web/./src/event/WorldLocationEvent.ts","webpack://rock-raiders-web/./src/game/model/anim/AnimClip.ts","webpack://rock-raiders-web/./src/game/model/anim/AnimSubObj.ts","webpack://rock-raiders-web/./src/resource/AnimatedMesh.ts","webpack://rock-raiders-web/./src/resource/LWOLoader.ts","webpack://rock-raiders-web/./src/resource/LWSCLoader.ts","webpack://rock-raiders-web/./src/game/model/anim/AnimEntity.ts","webpack://rock-raiders-web/./src/game/model/BaseEntity.ts","webpack://rock-raiders-web/./src/game/model/job/CarryJob.ts","webpack://rock-raiders-web/./src/game/model/activities/BuildingActivity.ts","webpack://rock-raiders-web/./src/game/model/collect/CarryPathTarget.ts","webpack://rock-raiders-web/./src/game/model/collect/MaterialEntity.ts","webpack://rock-raiders-web/./src/game/model/collect/Crystal.ts","webpack://rock-raiders-web/./src/game/model/activities/DynamiteActivity.ts","webpack://rock-raiders-web/./src/game/model/job/surface/CarryDynamiteJob.ts","webpack://rock-raiders-web/./src/game/model/collect/Dynamite.ts","webpack://rock-raiders-web/./src/game/model/collect/Ore.ts","webpack://rock-raiders-web/./src/game/model/job/surface/ClearRubbleJob.ts","webpack://rock-raiders-web/./src/game/model/job/surface/DrillJob.ts","webpack://rock-raiders-web/./src/game/model/job/surface/ReinforceJob.ts","webpack://rock-raiders-web/./src/game/model/map/Surface.ts","webpack://rock-raiders-web/./src/game/TerrainLoader.ts","webpack://rock-raiders-web/./src/game/model/map/TerrainPath.ts","webpack://rock-raiders-web/./src/game/model/map/Terrain.ts","webpack://rock-raiders-web/./src/game/SceneManager.ts","webpack://rock-raiders-web/./src/resource/wadworker/InitLoadingMessage.ts","webpack://rock-raiders-web/./src/game/model/MoveState.ts","webpack://rock-raiders-web/./src/resource/ResourceManager.ts","webpack://rock-raiders-web/./src/resource/AnimEntityLoader.ts","webpack://rock-raiders-web/./src/game/model/BuildingPathTarget.ts","webpack://rock-raiders-web/./src/game/model/collect/Barrier.ts","webpack://rock-raiders-web/./src/game/model/job/CarryFenceJob.ts","webpack://rock-raiders-web/./src/game/model/collect/ElectricFence.ts","webpack://rock-raiders-web/./src/game/model/building/BuildingEntity.ts","webpack://rock-raiders-web/./src/game/model/building/entities/Barracks.ts","webpack://rock-raiders-web/./src/game/model/building/entities/Docks.ts","webpack://rock-raiders-web/./src/game/model/building/entities/Geodome.ts","webpack://rock-raiders-web/./src/game/model/building/entities/GunStation.ts","webpack://rock-raiders-web/./src/game/model/building/entities/OreRefinery.ts","webpack://rock-raiders-web/./src/game/model/building/entities/PowerStation.ts","webpack://rock-raiders-web/./src/game/model/building/entities/TeleportBig.ts","webpack://rock-raiders-web/./src/game/model/building/entities/TeleportPad.ts","webpack://rock-raiders-web/./src/game/model/building/entities/Toolstation.ts","webpack://rock-raiders-web/./src/game/model/building/entities/Upgrade.ts","webpack://rock-raiders-web/./src/game/model/building/PowerPathBuildingSite.ts","webpack://rock-raiders-web/./src/game/model/job/EatJob.ts","webpack://rock-raiders-web/./src/game/model/job/GetToolJob.ts","webpack://rock-raiders-web/./src/game/model/job/TrainJob.ts","webpack://rock-raiders-web/./src/game/model/job/UpgradeJob.ts","webpack://rock-raiders-web/./src/game/GuiManager.ts","webpack://rock-raiders-web/./src/game/model/job/MoveJob.ts","webpack://rock-raiders-web/./src/game/model/EntityStep.ts","webpack://rock-raiders-web/./src/game/model/MovableEntity.ts","webpack://rock-raiders-web/./src/game/model/FulfillerEntity.ts","webpack://rock-raiders-web/./src/game/model/raider/Raider.ts","webpack://rock-raiders-web/./src/game/model/activities/MonsterActivity.ts","webpack://rock-raiders-web/./src/game/model/monster/Monster.ts","webpack://rock-raiders-web/./src/game/model/monster/Bat.ts","webpack://rock-raiders-web/./src/game/model/monster/SmallSpider.ts","webpack://rock-raiders-web/./src/game/ObjectListLoader.ts","webpack://rock-raiders-web/./src/event/EventTypeEnum.ts","webpack://rock-raiders-web/./src/game/Supervisor.ts","webpack://rock-raiders-web/./src/core/NerpRunner.ts","webpack://rock-raiders-web/./src/core/NerpParser.ts","webpack://rock-raiders-web/./src/game/model/job/PriorityList.ts","webpack://rock-raiders-web/./src/game/WorldManager.ts","webpack://rock-raiders-web/./src/screen/layer/ScreenLayer.ts","webpack://rock-raiders-web/./src/event/GameKeyboardEvent.ts","webpack://rock-raiders-web/./src/event/GamePointerEvent.ts","webpack://rock-raiders-web/./src/event/GameWheelEvent.ts","webpack://rock-raiders-web/./src/event/EventManager.ts","webpack://rock-raiders-web/./src/screen/layer/CursorLayer.ts","webpack://rock-raiders-web/./src/screen/BaseScreen.ts","webpack://rock-raiders-web/./src/screen/layer/GameLayer.ts","webpack://rock-raiders-web/./src/screen/layer/OffscreenLayer.ts","webpack://rock-raiders-web/./src/screen/layer/GuiMainLayer.ts","webpack://rock-raiders-web/./src/screen/layer/OverlayLayer.ts","webpack://rock-raiders-web/./src/screen/layer/SelectionLayer.ts","webpack://rock-raiders-web/./src/screen/GameScreen.ts","webpack://rock-raiders-web/./src/menu/MainMenuBaseItem.ts","webpack://rock-raiders-web/./src/menu/MainMenuIconButton.ts","webpack://rock-raiders-web/./src/menu/MainMenuLabelButton.ts","webpack://rock-raiders-web/./src/menu/MainMenuLayer.ts","webpack://rock-raiders-web/./src/menu/MainMenuLevelButton.ts","webpack://rock-raiders-web/./src/menu/MainMenuPanel.ts","webpack://rock-raiders-web/./src/menu/MainMenuWindow.ts","webpack://rock-raiders-web/./src/menu/LevelSelectLayer.ts","webpack://rock-raiders-web/./src/screen/MainMenuScreen.ts","webpack://rock-raiders-web/./src/menu/RewardScreenButton.ts","webpack://rock-raiders-web/./src/screen/RewardScreen.ts","webpack://rock-raiders-web/./src/main.ts","webpack://rock-raiders-web/./src/screen/LoadingScreen.ts","webpack://rock-raiders-web/./src/params.ts"],"names":["___CSS_LOADER_EXPORT___","push","module","id","ClearCacheButton","parentId","this","rootElement","document","getElementById","appendChild","createElement","classList","add","button","innerText","onclick","indexedDB","deleteDatabase","location","reload","style","visibility","GithubBox","link","href","img","src","alt","textContent","WadFileSelectionModal","onStart","tabIndex","setAttribute","modalDialog","modalContent","modalHeader","modalTitle","modalBody","navTabList","navFileBtn","appendNavButton","navUrlBtn","navTabContent","appendNavFileTab","appendNavUrlTab","modal","backdrop","keyboard","parent","active","controlTarget","navBtn","type","String","labelledBy","navFileTab","appendNavTab","wad0File","appendWadFileGroup","wad1File","btnStartFile","addEventListener","disabled","wad0FileUrl","URL","createObjectURL","files","wad1FileUrl","filename","wadFileGroup","wadFileLabel","innerHTML","wadFileInput","required","navUrlTab","urlHint","wad0Url","appendWadUrlGroup","wad1Url","btnStartUrl","value","navTab","example","wadUrlGroup","wadUrlLabel","wadUrlInput","show","hide","getPath","url","strUrl","toString","replace","startsWith","substring","lastInd","lastIndexOf","getFilename","iGet","obj","keys","forEach","keyname","Object","filter","key","toLowerCase","map","decodeString","data","TextDecoder","decode","decodeFilepath","getRandomInclusive","min","max","Math","ceil","floor","random","getRandom","getRandomSign","clearTimeoutSafe","timeout","clearTimeout","clearIntervalSafe","interval","clearInterval","Array","prototype","remove","element","index","indexOf","splice","last","length","undefined","count","callback","counter","e","partition","left","right","a","Map","getOrUpdate","updateCallback","get","set","equalsIgnoreCase","other","EntityType","EntitySuperType","RaiderTool","SurfaceType","options","shaping","matIndex","selectable","drillable","drillableHard","explodable","reinforcable","cursor","Cursor","C","cursorFulfiller","statsDrillName","canCarryFence","assign","typeNum","POWER_PATH_BUILDING","SOLID_ROCK","HARD_ROCK","LOOSE_ROCK","DIRT","LAVA","ORE_SEAM","WATER","CRYSTAL_SEAM","RECHARGE_SEAM","SLUG_HOLE","RUBBLE4","RUBBLE3","RUBBLE2","RUBBLE1","console","error","GROUND","name","POWER_PATH","POWER_PATH_BUILDING_SITE","POWER_PATH_CONSTRUCTION","AllRaiderTools","DRILL","HAMMER","SHOVEL","SPANNER","FREEZERGUN","LASER","PUSHERGUN","BIRDSCARER","RaiderTraining","AllRaiderTrainings","DRIVER","ENGINEER","GEOLOGIST","PILOT","SAILOR","DEMOLITION","RaiderTrainingSites","BARRACKS","UPGRADE","GEODOME","TELEPORT_PAD","DOCKS","TOOLSTATION","RaiderTrainingStatsProperty","SelectionType","LocalEvent","GameEvent","eventKey","super","isLocal","SelectionChanged","selectionType","NOTHING","selectedSurface","selectedBuilding","selectedRaiders","canDoTraining","everyHasTool","isGround","surfaceType","isPowerPath","isFloor","isSite","hasRubble","isDrillable","isDrillableHard","isReinforcable","canPlaceFence","GameState","buildings","some","b","entityType","POWER_STATION","isUsable","someCarries","r","carries","everyHasMaxLevel","every","level","stats","Levels","training","getTrainingSites","hasTraining","tool","hasTool","buildingCanUpgrade","canUpgrade","buildingCanSwitchPower","SelfPowered","PowerBuilding","AirLevelChanged","airLevel","SetupPriorityList","priorityList","BuildingsChangedEvent","usableBuildingsByTypeAndLevel","perLevel","event","building","minLevel","result","RaidersChangedEvent","numRaiders","raiders","GameResultState","resultState","RUNNING","numCrystal","numOre","numBrick","usedCrystals","neededCrystals","selectedEntities","buildingsUndiscovered","raidersUndiscovered","requestedRaiders","materials","materialsUndiscovered","buildingSites","spiders","spidersBySurface","bats","totalCrystals","totalOres","totalDiggables","remainingDiggables","totalCaverns","discoveredCaverns","levelStartTime","levelStopTime","oxygenRate","buildModeSelection","buildingTypes","bt","position","targetBuildings","getBuildingsByType","closest","minDist","bPos","getDropPosition","dist","distanceToSquared","entities","previouslySelected","stillSelected","deselect","freshlySelected","select","len","GROUP","getSelectionType","EventBus","surface","minX","x","minZ","y","maxX","maxZ","discoverEntities","undiscovered","discovered","pos","getPosition","z","onDiscover","round","SURFACE","BUILDING","RAIDER","entity","terrain","sceneMgr","currentSurface","getSurfaceFromWorld","nearbySpiders","getSurface","AnimationEntityType","carryNullName","depositNullName","toolNullName","mediumPoly","highPoly","fPPoly","activities","Stats","DebugHelper","setMode","domElement","top","body","begin","end","GuiCommand","CancelBuildMode","BarrierLocation","surfaceCenter","heading","clone","sub","angle","PI","WorldEvent","entityKey","JobEvent","job","guiForward","JobCreateEvent","JobDeleteEvent","RequestedRaidersChanged","numRequestedRaiders","MaterialAmountChanged","usedCrystal","neededCrystal","totalOre","CavernDiscovered","OreFoundEvent","BaseActivity","activityKey","AnimEntityActivity","Stand","BarrierActivity","Short","Expand","Long","Teleport","RaiderActivity","Route","RunPanic","Drill","Walk","Reinforce","Reverse","TurnLeft","TurnRight","CantDo","Collect","Clear","Carry","CarryTurnLeft","CarryTurnRight","CarryStand","Dynamite","Place","Deposit","TeleportIn","Repair","rest","routeRubble","CarryRubble","Eat","FireLaser","GetUp","ThrownByRockMonster","Slip","Train","Recharge","Waiting1","Waiting2","Waiting3","Waiting4","Hoverboard","Standhoverboard","HitLefthoverboard","HitRighthoverboard","HitFronthoverboard","HitBackhoverboard","SMALLTRUCK","StandSMALLTRUCK","HitLeftSMALLTRUCK","HitRightSMALLTRUCK","HitFrontSMALLTRUCK","HitBackSMALLTRUCK","SMALLheli","StandSMALLheli","HitLeftSMALLheli","HitRightSMALLheli","HitFrontSMALLheli","HitBackSMALLheli","SMALLCAT","StandSMALLCAT","HitLeftSMALLCAT","HitRightSMALLCAT","HitFrontSMALLCAT","HitBackSMALLCAT","SMALLMLP","StandSMALLMLP","HitLeftSMALLMLP","HitRightSMALLMLP","HitFrontSMALLMLP","HitBackSMALLMLP","LARGECAT","StandLARGECAT","HitLeftLARGECAT","HitRightLARGECAT","HitFrontLARGECAT","HitBackLARGECAT","SMALLDIGGER","StandSMALLDIGGER","PathTarget","targetLocation","item","addToScene","JobState","JobType","PriorityIdentifier","Job","fulfiller","jobState","INCOMPLETE","CANCELED","stopJob","COMPLETE","target","PublicJob","CompletePowerPathJob","placedItems","COMPLETE_POWER_PATH","workplaces","getRandomPosition","onJobComplete","placed","removeFromScene","setSurfaceTypeAndUpdateNeighbors","aiPriorityConstruction","BuildingSite","primarySurface","secondarySurface","primaryPathSurface","secondaryPathSurface","surfaces","neededByType","assignedByType","onSiteByType","complete","canceled","setSite","needed","onAddToSite","checkComplete","resetTarget","neededType","BARRIER","changeActivity","CRYSTAL","ORE","world","getCenterWorld2D","placeDown","items","itemsOnSite","s","worldMgr","placeMaterial","getPosition2D","clear","neighbors","find","n","site","isWalkable","WALL_TYPE","SurfaceGeometry","wallType","topLeftVertex","bottomRightVertex","topRightVertex","bottomLeftVertex","topLeftHeight","topRightHeight","bottomRightHeight","bottomLeftHeight","uvOffset","INVERTED_CORNER","WALL","WEIRD_CREVICE","Boolean","uv","bufferVertices","bufferNormals","addFaceAndNormals","c","normal","subVectors","cross","normalize","uvIndexes","bufferVertexUvs","i","bufferGeometry","BufferAttribute","Float32Array","copyVector3sArray","copyVector2sArray","BuildPlacementMarkerMesh","standardColor","geometry","shininess","transparent","opacity","color","visible","primaryPosition","multiplyScalar","applyAxisAngle","isValid","material","setHex","create","BuildPlacementMarker","group","markers","buildingMarkerPrimary","buildingMarkerSecondary","powerPathMarkerPrimary","powerPathMarkerSecondary","waterPathMarker","sdx","sdz","lastCheck","buildingMarkerColor","pathMarkerColor","waterMarkerColor","addMarker","marker","worldPosition","updateAllMarker","markAsValid","hideAllMarker","copy","getFloorPosition","sdxv","sdzv","abs","sign","atan2","updateState","secondaryBuildingPart","primaryPowerPath","secondaryPowerPath","waterPathSurface","allSurfacesAreGround","m","barrierLocations","getBarrierLocations","CostCrystal","neededOre","CostOre","closestToolstation","getClosestBuildingByType","getCenterWorld","spawnBarriers","spawnMaterials","centerPrimary","barrierOffset","centerSecondary","dx","dy","pathTo","node","curr","path","unshift","astar","graph","start","cleanDirty","heuristic","heuristics","manhattan","openHeap","BinaryHeap","f","closestNode","h","markDirty","size","currentNode","pop","closed","il","neighbor","isWall","gScore","g","getCost","beenVisited","visited","rescoreElement","pos0","pos1","D2","sqrt","d1","d2","Graph","gridIn","nodes","grid","dirtyNodes","diagonal","row","GridNode","init","cleanNode","ret","graphString","rowDebug","weight","join","fromNeighbor","scoreFunction","content","sinkDown","bubbleUp","parentN","elemScore","child2N","child1N","child1Score","swap","child1","child2","WorldLocationEvent","CrystalFoundEvent","LandslideEvent","RaiderDiscoveredEvent","AnimClip","looping","transcoef","firstFrame","lastFrame","framesPerSecond","bodies","degToRad","AnimSubObj","pivot","relPos","relRot","relScale","parentObjInd","model","degX","degY","degZ","animationFrameIndex","infos","radVec","AnimatedMesh","mesh","textureSequences","dispose","isArray","mat","SURF_VTRN","getVector3AtOffset","view","offset","vector","getFloat32","LWOLoader","verbose","vertices","indices","uvs","sequenceIntervals","log","chunkOffset","chunkSize","numVertices","vertexIndex","vertexOffset","buffer","surfaceNames","Uint8Array","split","new_material","side","alphaToCoverage","totalNumIndices","numIndices","getInt16","materialIndex","addGroup","currentIndex","Uint16Array","faceIndices","Int16Array","COUNTER_CLOCKWISE","getUint8","materialName","textureFlags","textureSize","textureCenter","subchunkOffset","subchunkType","getInt32","subchunkSize","colorArray","fromArray","flags","getUint16","warn","blending","depthWrite","edgeTransparencyThreshold","luminosity","emissiveIntensity","diffuse","specular","reflection","reflectivity","transparency","vLuminosity","vDiffuse","vSpecular","toArray","textureTypeName","textureValue","textureColorArray","textureFilepath","sequenceTexture","endsWith","match","textureFilename","textures","ResourceManager","filterTextureSequenceNames","getTexture","seqNum","setInterval","lTextureName","center","XAXIS_BIT","groups","uvIndex","u","v","planarMapUVS","DataView","getUint32","fileSize","byteLength","ID4_SIZE","magic","chunkType","parsePoints","parseSurfaceNames","parsePolygons","parseSurface","setIndex","computeVertexNormals","LWSCLoader","animationClip","lines","lineIndex","l","trim","sceneFileVersion","parseInt","line","parseFrameBlock","parseObjectBlock","lineParts","shift","parseLine","frameStep","subObj","slice","lwoBuffer","getResource","SceneManager","registerMesh","parse","lenInfos","lenFrames","Number","setFrameAndFollowing","numOfInformationChannels","numOfKeyframes","frameNum","setOpacityAndFollowing","AnimEntity","superType","floorOffset","rotation","radHeading","rotateOnAxis","scene","aeFilename","animationEntityType","poly","animation","animationTimeout","selectionFrame","pickSphere","carryJoint","depositJoint","getToolJoint","activity","radiusSq","getAnimationEntityType","moveUp","playPositionalSample","Sample","setTimeout","getDefaultActivity","onAnimationDone","durationTimeMs","lActivityKey","anim","bind","children","polyModel","polyPart","parentInd","sphere","setFromObject","getBoundingSphere","radius","animate","frameIndex","p","scale","hasOwnProperty","nextFrame","standardDurationTimeMs","that","timeoutTimeMs","pickSphereDiameter","PickSphere","pickSphereRadius","userData","pickSphereCenter","getPickSphereCenter","createSelectionFrame","getBoundingBoxCenter","getCenter","applyMatrix4","makeScale","selectionFrameTextureSize","ctx","fillStyle","strength","fillRect","selectionFrameTexture","canvas","selectionMaterial","depthTest","selectionFrameSize","sample","loop","audio","listener","setRefDistance","SoundManager","then","audioBuffer","setBuffer","play","sfxName","CarryJob","CARRY","actualTarget","getCarryTargets","getPriorityIdentifier","setTargetSite","getDropAction","canGatherItem","lookAt","dropItem","gatherItem","BuildingActivity","Explode","Unpowered","CarryPathTarget","SiteCarryPathTarget","addItem","BuildingCarryPathTarget","getDropPosition2D","ORE_REFINERY","addItemToStorage","MaterialEntity","MATERIAL","targetBuildingTypes","priorityIdentifier","targets","targetSite","positionPathTarget","updateTargets","sites","needs","getRandomDropPosition","getTargetBuildingTypes","t","isInvalid","createCarryJob","unAssign","equals","Crystal","resource2","mesh2","resource","emissive","aiPriorityCrystal","PowerCrystal","DynamiteActivity","Normal","TickDown","CarryDynamiteJob","dynamite","ignite","DYNAMITE","targetSurface","aiPriorityDestruction","isExplodable","getDigPositions","collapse","Ore","aiPriorityOre","ClearRubbleJob","CLEAR_RUBBLE","lastRubblePositions","rubblePositions","surfaceRubblePositions","d","reduceRubble","aiPriorityClearing","DrillJob","digPositions","surfaceDigPositions","onDrillComplete","drillTimeInMsPerType","drillTime","drillTimeEntry","drillTimeMs","ReinforceJob","REINFORCE","reinforce","aiPriorityReinforce","PathMap","PredugMap","Surface","heightOffset","containedOres","containedCrystals","selected","reinforced","drillJob","reinforceJob","dynamiteJob","clearRubbleJob","surfaceRotation","seamLevel","fallinTimeout","fallinGrp","needsMeshUpdate","fence","hasPower","setDiscovered","floors","others","caveFound","o","isSupported","discoverSurface","drillPosition","vec","rotateAround","crystal","cancelJobs","discover","dropContainedOre","surf","updateSurfaceMeshes","floorGroup","updateWorldMatrix","dropAmount","safeRemoveJob","updateJobColor","updateTexture","surfLeft","surfTopLeft","surfTop","surfTopRight","surfRight","surfBottomRight","surfBottom","surfBottomLeft","isHighGround","surf1","surf2","surf3","force","avgHeight","args","reduce","updateGeometry","cancelReinforceJobs","updateGraphWalk","getGraphWalkWeight","graphWalk","textureName","textureSet","texturebasename","updatePowerPathTexture","CORNER","forEachMaterial","texture","isPath","bottom","pathSum","blocksPathSurface","digPosition","addScalar","getTerrainHeight","fallinLevel","originPos","targetPos","findFallInOrigin","findFallInTarget","scheduleFallin","targetX","targetY","createFallin","fallinPosition","makeRubble","worldX","worldZ","sx","sy","dy0","interpolate","dy1","y0","y1","containedOre","state","recursive","setHasPower","targetBuilding","getHeading","TerrainPath","locations","lengthSq","Terrain","width","height","roofGroup","cachedPaths","setScalar","getSurfaceFromWorldXZ","getSurfaceOrNull","forEachSurface","updateMesh","resetGraphWalk","gridStartX","gridStartY","gridEndX","gridEndY","cacheIdentifier","cachedPath","addLocation","searchPath","startNode","endNode","worldPath","search","gridNodeToWorldPos","gridNode","divideScalar","leftSurface","topSurface","rightSurface","bottomSurface","leftSurface2","isDigable","topSurface2","rightSurface2","bottomSurface2","each","maxFps","debugHelper","renderer","antialias","setClearColor","camera","controls","mouseButtons","LEFT","MIDDLE","RIGHT","listenToKeyEvents","keyPanSpeed","buildMarker","rx","ry","raycaster","setFromCamera","intersects","intersectObjects","object","selectEntities","r1x","r1y","r2x","r2y","startPoint","endPoint","EPSILON","updateProjectionMatrix","updateMatrixWorld","tmpPoint","vecNear","vecTopLeft","vecTopRight","vecDownRight","vecDownLeft","setFromMatrixPosition","matrixWorld","unproject","vectemp1","vectemp2","vectemp3","deep","MAX_VALUE","frustum","planes","setFromCoplanarPoints","containsPoint","getSelectionCenter","firstBuilding","levelConf","ambientRgb","cfg","maxAmbRgb","normalizedRgb","ambientColor","ambientLight","cursorTorchlight","distance","tileSize","blockSize","themeName","terrainMap","pathMap","surfaceMap","predugMap","cryOreMap","fallinMap","erodeMap","blockPointersMap","surfaceTypeNum","getByNum","predugLevel","CAVERN_EXPOSED","SLUG_HOLE_EXPOSED","SLUG_HOLE_HIDDEN","CAVERN_HIDDEN","pathMapLevel","NONE","RUBBLE","currentCryOre","weights","col","w","setFallinLevel","loadTerrain","countDiggables","countCrystals","countOres","renderInterval","animRequest","requestAnimationFrame","renderStart","render","renderDone","cancelAnimationFrame","meshRegistry","animatedMesh","setSize","point","floorY","getFloorHeight","intersect","intersectObject","InitLoadingMessage","MoveState","ResourceCache","startLoading","msg","worker","onmessage","WorkerMessageType","assetNames","assetName","resourceByName","assetObj","sfxKeys","sfxKey","sfxByKey","onAssetLoaded","onMessage","text","configuration","loadDefaultCursor","onInitialLoad","totalResources","onCacheMissed","loadAllCursor","loadingTimeSeconds","onLoadDone","postMessage","basename","lBasename","res","imgData","lSharedTextureName","needsUpdate","cfgRoot","root","polyname","polykey","act","file","isLws","loadModels","Worker","BuildingPathTarget","Barrier","CarryFenceJob","ElectricFence","ELECTRIC_FENCE","BuildingEntity","powerSwitch","spawning","upgradeCostOre","upgradeCostBrick","crystalsInUse","inBeam","pathTarget","turnOnPower","worldPos","getWorldPosition","isPowered","setBuilding","beamUp","hasMaxLevel","quantity","engineSound","playPositionalSfxName","EngineSound","stop","disableTeleportIn","getSurfaceFromWorld2D","secondaryOffset","pathOffset","createPickSphere","onPlaceDown","Barracks","Docks","Geodome","GunStation","GUNSTATION","OreRefinery","PowerStation","Powerstation","TeleportBig","TELEPORT_BIG","TeleportBIG","TeleportPad","Toolstation","Upgrade","PowerPathBuildingSite","EatJob","EAT","GetToolJob","toolstation","GET_TOOL","getPathTarget","addTool","TrainJob","TRAIN","getWorkplaces","getTrainingTargets","addTraining","UpgradeJob","GuiManager","setJob","spawnFence","increase","createDrillJob","createReinforceJob","createDynamiteJob","createClearRubbleJob","upgrade","turnOffPower","isDriving","buildingFromType","cancelSite","MoveJob","MOVE","EntityStep","targetReached","MovableEntity","currentPath","paths","findPathToTarget","sort","TARGET_UNREACHABLE","nextLocation","firstLocation","step","determineStep","TARGET_REACHED","getRouteActivity","MOVED","getEntityStep","stepLengthSq","entitySpeed","getSpeed","setLength","targetWorld","FulfillerEntity","workInterval","followUpJob","work","unassign","Raider","tools","trainings","slipped","Pilot","findPath","RouteSpeed","isOnPath","PathCoef","isOnRubble","moveToClosestTarget","setActualWorkplace","getNearbySpiders","spider","slip","onDeath","carryItem","getCarryItem","getPositionPathTarget","pickupItem","isReadyToComplete","workActivity","getWorkActivity","workAudio","completeJob","getWorkDuration","has","MonsterActivity","Monster","MONSTER","moveTimeout","Bat","BAT","onMove","bat","findTarget","currentCenter","targetZ","SmallSpider","SMALL_SPIDER","MOUSE_BUTTON","POINTER_EVENT","KEY_EVENT","Supervisor","jobs","assignInterval","checkRubbleInterval","cancel","assignJobs","checkUnclearedRubble","resetWorkInterval","availableJobs","j","isEnabled","getPriority","unemployedRaider","closestRaider","closestRaiderIndex","minDistance","closestToolRaider","closestToolRaiderIndex","minToolDistance","requiredTool","getRequiredTool","closestTrainingRaider","closestTrainingRaiderIndex","minTrainingDistance","closestTrainingArea","requiredTraining","getRequiredTraining","raider","hasRequiredTool","pathToJob","pathToTrainingSite","pathToToolstation","getWalkOutSurface","startSurface","rad","NerpRunner","debug","onLevelEnd","nerpInterval","registers","fill","timers","scriptLines","statements","macrosByName","labelsByName","halted","programCounter","messages","messagePermit","execute","register","num","isNaN","Error","checkRegister","checkRegisterValue","timer","Date","getTime","FAILED","messagesAllowed","typeName","setBuildingsUpgradeLevel","arg1","arg2","arg3","messageNumber","arrowDisabled","txt","blockNum","methodName","methodArgs","setRegisterMatch","setR","addRegisterMatch","addR","getRegisterMatch","getR","setTimerMatch","setTimer","getTimerMatch","getTimer","lMethodName","memberName","getOwnPropertyNames","apply","conditionResult","executeStatement","expression","invoke","argValues","callMethod","comparator","jump","statement","label","NerpParser","nerpScript","nerpRunner","includeName","includedRunner","concat","firstLine","macroLines","mLine","append","macroLine","macroCall","replaceMacros","labelMatch","preProcess","labelName","macro","RegExp","number","opSplit","brackets","spaceSplit","jumpMatch","PriorityList","levelDefault","current","priorities","reset","enabled","tmp","entry","PriorityEntry","priority","levelPriorityEntry","WorldManager","oxygenUpdateInterval","updateOxygen","reward","quota","caverns","setList","nerpFile","nerpMessageFile","startExecution","now","pauseExecution","diff","OxygenCoef","ScreenLayer","alpha","withContext","background","context","getContext","zIndex","layerA","layerB","aIndex","bIndex","onRedraw","isActive","redraw","windowX","windowY","clientRect","getBoundingClientRect","Promise","resolve","ScaledLayer","fixedWidth","fixedHeight","updateScale","scaleX","scaleY","cx","cy","toCanvasCoords","resize","GameKeyboardEvent","eventEnum","bubbles","code","GamePointerEvent","clientX","clientY","pointerType","ctrlKey","metaKey","shiftKey","GameWheelEvent","deltaX","deltaY","deltaZ","EventManager","screen","gameCanvasContainer","isInRect","preventDefault","DOWN","UP","eventType","nonBubblingClone","activeLayers","layers","compareZ","publishPointerEvent","publishKeyEvent","publishWheelEvent","handlePointerEvent","consumed","handleKeyEvent","handleWheelEvent","CursorLayer","currentCursor","timedCursor","cursorTimeout","activeCursor","registerEventListener","changeCursor","disableAnimation","determineCursor","VEHICLE","setCursor","getCursor","enableAnimation","BaseScreen","ratio","focus","eventMgr","window","onWindowResize","cursorLayer","addLayer","layer","setZIndex","maxWidth","offsetWidth","maxHeight","offsetHeight","idealHeight","oldCanvas","removeChild","firstLayer","rect","GameLayer","rightDown","intersectionPoint","getTerrainPositionFromEvent","setTorchPosition","update","MAIN","createBuildingSite","SECONDARY","assignSurfaceJob","publishEvent","dispatchEvent","PointerEvent","KeyboardEvent","getTerrainIntersectionPoint","WheelEvent","generateUUID","OffscreenLayer","resolveCallbackByEventId","sendMessage","response","eventResponse","eventId","eventConsumed","delete","gameEvent","message","transfer","transferControlToOffscreen","canvasX","canvasY","sendEventMessage","inputEvent","GuiMainLayer","onOptionsShow","messageState","OverlayLayer","onSetSpaceToContinue","onAbortGame","onRestartGame","objectiveText","objectiveBackImgCfg","SelectionLayer","selectStart","startSelection","changeSelection","screenX","screenY","clearRect","strokeStyle","lineWidth","strokeRect","selectEntitiesByRay","selectEntitiesInFrustum","GameScreen","spawnRaiderInterval","gameLayer","selectionLayer","guiLayer","overlayLayer","jobSupervisor","guiMgr","showOptions","setSpaceToContinue","restartLevel","checkSpawnRaiders","levelName","setupAndStartLevel","fullName","setup","setupScene","objective","objectiveImage640x480","objectListConf","oListFile","disableStartTeleport","values","olObject","lTypeName","xPos","yPos","buildingType","cameraOffset","cameraPos","createBuildingByName","startMoving","startRandomMove","typename","loadObjectList","startScene","disposeScene","getMaxRaiders","spawnBuildings","station","walkOutPos","MainMenuBaseItem","scrollAffected","needsRedraw","hover","pressed","actionName","targetIndex","onHoverChange","MainMenuIconButton","imgNormal","imgHover","imgPressed","tooltip","getImage","autoCenter","draw","drawImage","MainMenuLabelButton","labelImgLo","labelImgHi","loFont","createTextImage","hiFont","MainMenuLayer","menuCfg","scrollY","scrollSpeedY","scrollInterval","getBitmapFont","menuImage","titleImage","itemsLabel","displayTitle","setScrollY","toScaledCoords","hovered","setReleased","absY","checkHover","canScroll","scrollAreaHeight","setScrollSpeedY","checkSetPressed","showMainMenu","selectLevel","levelKey","pow","scrollYBefore","MainMenuLevelButton","levelCfg","imgActive","imgInactive","imgCross","unlocked","frontEndX","frontEndY","menuBMP","frontEndOpen","MainMenuPanel","area","putImageData","getImageData","MainMenuWindow","font","imgFirstLine","imgSecondLine","LevelSelectLayer","modeLevel","levelsCfg","levelTextCfg","LevelTextCfg","panelImgData","panelPos","levelTextWindow","getDefaultFont","setFirstLine","tutorial","levelsByName","levelButton","setSecondLine","winCfg","panelCfg","parseLabel","MainMenuScreen","onLevelSelected","menus","title","menu","RewardScreenButton","conf","imgNormalFilepath","imgHoverFilepath","imgPressedFilepath","imgDisabledFilepath","imgDisabled","RewardScreen","resultIndex","resultLastIndex","images","boxes","fonts","texts","uncoverTimeout","titleFont","backgroundImg","wallpaper","filePath","boxImages","fontKey","labelFont","backFont","resultsLayer","btnSave","btnAdvance","descriptionTextLayer","btnLayer","saveButton","advanceButton","onAdvance","uncoverResult","resultText","quitText","completeText","failedText","resultValues","percentString","timeString","gameTimeSeconds","score","gameResultTextImg","box","levelFullNameImg","vertSpacing","descriptionTextImg","textPos","tx","ty","rewardConfig","importance","scoreCrystals","crystals","Infinity","scoreTimer","scoreCaverns","scoreConstructions","constructions","scoreOxygen","oxygen","scoreFigures","figures","actual","lessIsMore","padding","seconds","ss","padLeft","minutes","mm","levelFullName","loadingScreen","assetIndex","setLoadingMessage","fillText","imgBackground","imgProgress","imgLoading","loadingBarWidth","wadFileSelectModal","githubBox","clearCacheButton","startLoadingFromUrl","enableGraphicMode","increaseLoadingState","mainMenuScreen","gameScreen","rewardScreen","startLevel","showLevelSelection","params","URLSearchParams","substr","startLoadingFromCache","DEV_MODE","WAD_CACHE_DB_NAME","JOB_SCHEDULE_INTERVAL","CHECK_CLEARRUBBLE_INTERVAL","JOB_ACTION_RANGE","CHECK_SPANW_RAIDER_TIMER","MAX_RAIDER_BASE","ADDITIONAL_RAIDER_PER_SUPPORT","UPDATE_OXYGEN_TIMER","HEIGHT_MULTIPLER","SEQUENCE_TEXTURE_FRAMERATE","SPRITE_RESOLUTION_WIDTH","SPRITE_RESOLUTION_HEIGHT","TILESIZE","NATIVE_FRAMERATE"],"mappings":"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","file":"677.index.js","sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".clear-cache-box {\\n    z-index: 2000;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./site/clearcache/clearCacheButton.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,aAAa;IACb,kBAAkB;IAClB,OAAO;IACP,MAAM;AACV\",\"sourcesContent\":[\".clear-cache-box {\\n    z-index: 2000;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".github-box {\\n    z-index: 2000;\\n    padding: 16px;\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    background-color: rgba(0, 0, 0, 0.6);\\n    color: #fff;\\n}\\n\\n.github-box a {\\n    color: #fff;\\n    text-decoration: none;\\n    padding: 8px;\\n}\\n\\n.github-box a:hover {\\n    color: #fff;\\n    text-decoration: underline;\\n}\\n\\n.github-logo {\\n    width: 16px;\\n    height: 16px;\\n    margin-right: 8px;\\n    vertical-align: middle;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./site/github/github.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,aAAa;IACb,aAAa;IACb,kBAAkB;IAClB,MAAM;IACN,QAAQ;IACR,oCAAoC;IACpC,WAAW;AACf;;AAEA;IACI,WAAW;IACX,qBAAqB;IACrB,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,0BAA0B;AAC9B;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,iBAAiB;IACjB,sBAAsB;AAC1B\",\"sourcesContent\":[\".github-box {\\n    z-index: 2000;\\n    padding: 16px;\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    background-color: rgba(0, 0, 0, 0.6);\\n    color: #fff;\\n}\\n\\n.github-box a {\\n    color: #fff;\\n    text-decoration: none;\\n    padding: 8px;\\n}\\n\\n.github-box a:hover {\\n    color: #fff;\\n    text-decoration: underline;\\n}\\n\\n.github-logo {\\n    width: 16px;\\n    height: 16px;\\n    margin-right: 8px;\\n    vertical-align: middle;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","import api from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../node_modules/css-loader/dist/cjs.js!./clearCacheButton.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import { WAD_CACHE_DB_NAME } from '../../src/params'\nimport './clearCacheButton.css'\n\nexport class ClearCacheButton {\n\n    rootElement: HTMLDivElement\n\n    constructor(parentId: string) {\n        this.rootElement = document.getElementById(parentId).appendChild(document.createElement('div'))\n        this.rootElement.classList.add('clear-cache-box')\n\n        const button = this.rootElement.appendChild(document.createElement('button'))\n        button.classList.add('btn', 'btn-info')\n        button.innerText = 'Clear cached wad files and restart'\n        button.onclick = () => {\n            indexedDB.deleteDatabase(WAD_CACHE_DB_NAME)\n            location.reload()\n        }\n    }\n\n    hide() {\n        this.rootElement.style.visibility = 'hidden'\n    }\n\n}\n","import api from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../node_modules/css-loader/dist/cjs.js!./github.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import './github.css'\nimport GithubIcon from './github.png'\n\nexport class GithubBox {\n\n    rootElement: HTMLDivElement\n\n    constructor(parentId: string) {\n        this.rootElement = document.getElementById(parentId).appendChild(document.createElement('div'))\n        this.rootElement.classList.add('github-box')\n\n        const link = this.rootElement.appendChild(document.createElement('a'))\n        link.href = 'https://github.com/scarabol/rock-raiders-web'\n\n        const img = link.appendChild(document.createElement('img'))\n        img.src = GithubIcon\n        img.classList.add('github-logo')\n        img.alt = 'Fork on GitHub'\n\n        const txt = link.appendChild(document.createElement('span'))\n        txt.textContent = img.alt\n    }\n\n    hide() {\n        this.rootElement.style.visibility = 'hidden'\n    }\n\n}\n","import { Modal } from 'bootstrap'\n\nexport class WadFileSelectionModal {\n\n    public onStart: (wad0Url, wad1Url) => any = null\n\n    private readonly modal: Modal\n\n    constructor(parentId: string) {\n        const rootElement = document.getElementById(parentId).appendChild(document.createElement('div'))\n        rootElement.classList.add('modal')\n        rootElement.tabIndex = -1\n        rootElement.setAttribute('role', 'dialog')\n        rootElement.setAttribute('aria-hidden', 'true')\n\n        const modalDialog = rootElement.appendChild(document.createElement('div'))\n        modalDialog.classList.add('modal-dialog')\n        rootElement.setAttribute('role', 'document')\n\n        const modalContent = modalDialog.appendChild(document.createElement('div'))\n        modalContent.classList.add('modal-content')\n\n        const modalHeader = modalContent.appendChild(document.createElement('div'))\n        modalHeader.classList.add('modal-header')\n        const modalTitle = modalHeader.appendChild(document.createElement('h5'))\n        modalTitle.classList.add('modal-title')\n        modalTitle.innerText = 'Load .wad files'\n        modalTitle.id = 'wadfileSelectModalLabel'\n        rootElement.setAttribute('aria-labelledby', modalTitle.id)\n\n        const modalBody = modalContent.appendChild(document.createElement('div'))\n        modalBody.classList.add('modal-body')\n\n        const hint = modalBody.appendChild(document.createElement('p'))\n        hint.innerText = 'Assets not included! In order to play the game, please select the game files.'\n\n        const navTabs = modalBody.appendChild(document.createElement('nav'))\n        const navTabList = navTabs.appendChild(document.createElement('div'))\n        navTabList.id = 'nav-tab'\n        navTabList.classList.add('nav', 'nav-tabs')\n        navTabList.setAttribute('role', 'tablist')\n\n        const navFileBtn = WadFileSelectionModal.appendNavButton(navTabList, true, 'nav-file-tab', 'nav-file', 'Local files (recommended)')\n        const navUrlBtn = WadFileSelectionModal.appendNavButton(navTabList, false, 'nav-url-tab', 'nav-url', 'Online from URL')\n\n        const navTabContent = modalBody.appendChild(document.createElement('div'))\n        navTabContent.classList.add('tab-content')\n        this.appendNavFileTab(navTabContent, navFileBtn.id)\n        this.appendNavUrlTab(navTabContent, navUrlBtn.id)\n\n        // rootElement has to be a valid bootstrap HTML modal before we can instantiate it\n        this.modal = new Modal(rootElement, {backdrop: 'static', keyboard: false})\n    }\n\n    private static appendNavButton(parent: HTMLDivElement, active: boolean, id: string, controlTarget: string, innerText: string) {\n        const navBtn = parent.appendChild(document.createElement('button'))\n        navBtn.classList.add('nav-link')\n        if (active) navBtn.classList.add('active')\n        navBtn.id = id\n        navBtn.setAttribute('data-bs-toggle', 'tab')\n        navBtn.setAttribute('data-bs-target', '#' + controlTarget)\n        navBtn.type = 'button'\n        navBtn.setAttribute('role', 'tab')\n        navBtn.setAttribute('aria-controls', controlTarget)\n        navBtn.setAttribute('aria-selected', String(active))\n        navBtn.innerText = innerText\n        return navBtn\n    }\n\n    private appendNavFileTab(parent: HTMLDivElement, labelledBy: string) {\n        const navFileTab = WadFileSelectionModal.appendNavTab(parent, true, 'nav-file', labelledBy)\n\n        const wad0File = WadFileSelectionModal.appendWadFileGroup(navFileTab, 'wad0-file', 'LegoRR0.wad')\n        const wad1File = WadFileSelectionModal.appendWadFileGroup(navFileTab, 'wad1-file', 'LegoRR1.wad')\n\n        const btnStartFile = navFileTab.appendChild(document.createElement('button'))\n        btnStartFile.type = 'submit'\n        btnStartFile.classList.add('btn', 'btn-primary', 'float-end')\n        btnStartFile.id = 'button-start-file'\n        btnStartFile.innerText = 'Start Game'\n        btnStartFile.addEventListener('click', () => {\n            btnStartFile.disabled = true\n            const wad0FileUrl = URL.createObjectURL(wad0File.files[0])\n            const wad1FileUrl = URL.createObjectURL(wad1File.files[0])\n            this.onStart(wad0FileUrl, wad1FileUrl)\n        })\n    }\n\n    private static appendWadFileGroup(parent: HTMLDivElement, id: string, filename: string) {\n        const wadFileGroup = parent.appendChild(document.createElement('div'))\n        wadFileGroup.classList.add('my-3')\n        const wadFileLabel = wadFileGroup.appendChild(document.createElement('label'))\n        wadFileLabel.setAttribute('for', id)\n        wadFileLabel.classList.add('form-label')\n        wadFileLabel.innerHTML = 'Select <span class=\"fw-bold\">' + filename + '</span> here:'\n        const wadFileInput = wadFileGroup.appendChild(document.createElement('input'))\n        wadFileInput.type = 'file'\n        wadFileInput.classList.add('form-control')\n        wadFileInput.id = id\n        wadFileInput.required = true\n        return wadFileInput\n    }\n\n    private appendNavUrlTab(parent: HTMLDivElement, labelledBy: string) {\n        const navUrlTab = WadFileSelectionModal.appendNavTab(parent, false, 'nav-url', labelledBy)\n\n        const urlHint = navUrlTab.appendChild(document.createElement('div'))\n        urlHint.classList.add('my-3')\n        urlHint.innerText = 'Direct links with correct Allow-Origin-CORS-Headers required here.'\n\n        const wad0Url = WadFileSelectionModal.appendWadUrlGroup(navUrlTab, 'wad0-url', 'LegoRR0.wad', 'https://drive.google.com/uc?export=download&id=11t9AJnGCWnEWlLxSsYQeB_Y4jrKfxVxQ')\n        const wad1Url = WadFileSelectionModal.appendWadUrlGroup(navUrlTab, 'wad1-url', 'LegoRR1.wad', 'https://drive.google.com/uc?export=download&id=11t9AJnGCWnEWlLxSsYQeB_Y4jrKfxVxQ')\n\n        const btnStartUrl = navUrlTab.appendChild(document.createElement('button'))\n        btnStartUrl.type = 'submit'\n        btnStartUrl.classList.add('btn', 'btn-primary', 'float-end')\n        btnStartUrl.id = 'button-start-url'\n        btnStartUrl.innerText = 'Start Game'\n        btnStartUrl.addEventListener('click', () => {\n            btnStartUrl.disabled = true\n            // XXX show loading progress for WAD files\n            this.onStart(wad0Url.value, wad1Url.value)\n        })\n    }\n\n    private static appendNavTab(parent: HTMLDivElement, active: boolean, id: string, labelledBy: string) {\n        const navTab = parent.appendChild(document.createElement('div'))\n        navTab.classList.add('tab-pane', 'fade')\n        if (active) navTab.classList.add('show', 'active')\n        navTab.id = id\n        navTab.setAttribute('role', 'tabpanel')\n        navTab.setAttribute('aria-labelledby', labelledBy)\n        return navTab\n    }\n\n    private static appendWadUrlGroup(parent: HTMLDivElement, id: string, filename: string, example: string) {\n        const wadUrlGroup = parent.appendChild(document.createElement('div'))\n        wadUrlGroup.classList.add('my-3')\n        const wadUrlLabel = wadUrlGroup.appendChild(document.createElement('label'))\n        wadUrlLabel.setAttribute('for', id)\n        wadUrlLabel.classList.add('form-label')\n        wadUrlLabel.innerHTML = 'Enter url for <span class=\"fw-bold\">' + filename + '</span> here:'\n        const wadUrlInput = wadUrlGroup.appendChild(document.createElement('input'))\n        wadUrlInput.type = 'url'\n        wadUrlInput.classList.add('form-control')\n        wadUrlInput.id = id\n        wadUrlInput.required = true\n        wadUrlInput.value = example\n        return wadUrlInput\n    }\n\n    public show() {\n        this.modal.show()\n    }\n\n    public hide() {\n        this.modal.hide()\n    }\n\n}\n","export function getPath(url: string): string {\n    if (!url) return url\n    let strUrl = url.toString().replace(/\\\\/g, '/')\n    if (strUrl.startsWith('/')) strUrl = strUrl.substring(1)\n    const lastInd = strUrl.lastIndexOf('/')\n    strUrl = strUrl.substring(0, lastInd + 1)\n    if (strUrl.startsWith('/')) strUrl = strUrl.substring(1)\n    return strUrl\n}\n\nexport function getFilename(url: string): string {\n    if (!url) return url\n    let strUrl = url.toString().replace(/\\\\/g, '/')\n    if (strUrl.startsWith('/')) strUrl = strUrl.substring(1)\n    const lastInd = strUrl.lastIndexOf('/')\n    return strUrl.substring(lastInd + 1)\n}\n\nexport function iGet(obj, ...keys: string[]): any {\n    keys.forEach((keyname) => {\n        obj = Object.keys(obj)\n            .filter((key) => key.toLowerCase() === keyname.toLowerCase())\n            .map((key) => obj[key])\n        obj = obj ? obj[0] : obj\n    })\n    return obj\n}\n\nexport function decodeString(data) {\n    return new TextDecoder().decode(data).replace(/\\0/g, '')\n}\n\nexport function decodeFilepath(data) {\n    return decodeString(data).replace(/\\\\/g, '/')\n}\n\nexport function getRandomInclusive(min, max) {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\nexport function getRandom(max) {\n    return getRandomInclusive(0, max)\n}\n\nexport function getRandomSign() {\n    return -1 + getRandomInclusive(0, 1) * 2\n}\n\nexport function clearTimeoutSafe(timeout: NodeJS.Timeout) {\n    if (timeout) clearTimeout(timeout)\n    return null\n}\n\nexport function clearIntervalSafe(interval: NodeJS.Timeout) {\n    if (interval) clearInterval(interval)\n    return null\n}\n\ndeclare global {\n\n    interface Array<T> {\n        remove(element: T): void\n\n        last(): T\n\n        count(callback: (element: T) => boolean): number\n\n        partition(filter: (element: T) => boolean): [T[], T[]]\n    }\n\n    interface Map<K, V> {\n        getOrUpdate(key: K, updateCallback: () => V): V\n    }\n\n    interface String {\n        equalsIgnoreCase(other: string): boolean\n    }\n\n}\n\nArray.prototype.remove = function <T>(element: T): void {\n    const index = this.indexOf(element)\n    if (index !== -1) this.splice(index, 1)\n}\n\nArray.prototype.last = function <T>(): T {\n    return this.length > 0 ? this[this.length - 1] : undefined\n}\n\nArray.prototype.count = function <T>(callback: (element: T) => boolean): number {\n    let counter = 0\n    this.forEach((e) => callback(e) && counter++)\n    return counter\n}\n\nArray.prototype.partition = function <T>(filter: (element: T) => boolean): [T[], T[]] {\n    const left: T[] = [], right: T[] = []\n    this.forEach((a) => filter(a) ? left.push(a) : right.push(a))\n    return [left, right]\n}\n\n// noinspection JSUnusedGlobalSymbols\nMap.prototype.getOrUpdate = function <K, V>(key: K, updateCallback: () => V): V {\n    let value = this.get(key)\n    if (value === undefined) {\n        value = updateCallback()\n        this.set(key, value)\n    }\n    return value\n}\n\nString.prototype.equalsIgnoreCase = function (other: string): boolean {\n    return this.toLowerCase() === other?.toLowerCase()\n}\n","export enum EntityType {\n\n    // RAIDER\n    PILOT,\n\n    // BUILDING\n    TOOLSTATION,\n    TELEPORT_PAD,\n    DOCKS,\n    POWER_STATION,\n    BARRACKS,\n    UPGRADE,\n    GEODOME,\n    ORE_REFINERY,\n    GUNSTATION,\n    TELEPORT_BIG,\n\n    // MONSTER\n    BAT,\n    SMALL_SPIDER,\n\n    // MATERIAL\n    DYNAMITE,\n    ELECTRIC_FENCE,\n    CRYSTAL,\n    ORE,\n    BRICK,\n    BARRIER,\n\n}\n\nexport enum EntitySuperType {\n\n    RAIDER,\n    BUILDING,\n    MONSTER,\n    MATERIAL,\n\n}\n","export enum RaiderTool {\n\n    DRILL,\n    HAMMER,\n    SHOVEL,\n    SPANNER,\n    FREEZERGUN,\n    LASER,\n    PUSHERGUN,\n    BIRDSCARER,\n\n}\n\nexport const AllRaiderTools: RaiderTool[] = [\n    RaiderTool.DRILL,\n    RaiderTool.HAMMER,\n    RaiderTool.SHOVEL,\n    RaiderTool.SPANNER,\n    RaiderTool.FREEZERGUN,\n    RaiderTool.LASER,\n    RaiderTool.PUSHERGUN,\n    RaiderTool.BIRDSCARER,\n]\n","import { Cursor } from '../../../screen/Cursor'\n\nexport class SurfaceType {\n\n    name: string // human readable, maybe used as label later on\n    shaping: boolean = false\n    matIndex: string = '00'\n    floor: boolean = false\n    selectable: boolean = false\n    drillable: boolean = false\n    drillableHard: boolean = false\n    explodable: boolean = false\n    reinforcable: boolean = false\n    cursor: Cursor = Cursor.Pointer_Standard\n    cursorFulfiller: Cursor = Cursor.Pointer_Standard\n    statsDrillName: string = null\n    canCarryFence: boolean = false\n\n    constructor(options: Partial<SurfaceType> = {}) {\n        Object.assign(this, options)\n    }\n\n    static readonly GROUND = new SurfaceType({\n        name: 'ground',\n        floor: true,\n        selectable: true,\n        canCarryFence: true,\n    })\n    static readonly SOLID_ROCK = new SurfaceType({\n        name: 'solid rock',\n        shaping: true,\n        matIndex: '5',\n        cursor: Cursor.Pointer_SurfaceType_Immovable,\n    })\n    static readonly HARD_ROCK = new SurfaceType({\n        name: 'hard rock',\n        shaping: true,\n        matIndex: '4',\n        selectable: true,\n        drillableHard: true,\n        explodable: true,\n        reinforcable: true,\n        cursor: Cursor.Pointer_SurfaceType_Hard,\n        statsDrillName: 'HardDrillTime',\n    })\n    static readonly LOOSE_ROCK = new SurfaceType({\n        name: 'loose rock',\n        shaping: true,\n        matIndex: '3',\n        selectable: true,\n        drillable: true,\n        drillableHard: true,\n        explodable: true,\n        reinforcable: true,\n        cursor: Cursor.Pointer_SurfaceType_Medium,\n        statsDrillName: 'LooseDrillTime',\n    })\n    static readonly DIRT = new SurfaceType({\n        name: 'dirt',\n        shaping: true,\n        matIndex: '2',\n        selectable: true,\n        drillable: true,\n        drillableHard: true,\n        explodable: true,\n        reinforcable: true,\n        cursor: Cursor.Pointer_SurfaceType_Loose,\n        statsDrillName: 'SoilDrillTime',\n    })\n    static readonly SLUG_HOLE = new SurfaceType({name: 'slug hole', floor: true, matIndex: '30'})\n    static readonly LAVA = new SurfaceType({name: 'lava', floor: true, matIndex: '46'})\n    static readonly ORE_SEAM = new SurfaceType({\n        name: 'ore seam',\n        matIndex: '40',\n        selectable: true,\n        drillable: true,\n        drillableHard: true,\n        explodable: true,\n        reinforcable: true,\n        cursor: Cursor.Pointer_SurfaceType_OreSeam,\n        statsDrillName: 'SeamDrillTime',\n    })\n    static readonly WATER = new SurfaceType({name: 'water', floor: true, matIndex: '45'})\n    static readonly CRYSTAL_SEAM = new SurfaceType({\n        name: 'energy crystal seam',\n        matIndex: '20',\n        selectable: true,\n        drillable: true,\n        drillableHard: true,\n        explodable: true,\n        reinforcable: true,\n        cursor: Cursor.Pointer_SurfaceType_CrystalSeam,\n        statsDrillName: 'SeamDrillTime',\n    })\n    static readonly RECHARGE_SEAM = new SurfaceType({\n        name: 'recharge seam',\n        matIndex: '67',\n        cursor: Cursor.Pointer_SurfaceType_RechargeSeam,\n    })\n    static readonly POWER_PATH = new SurfaceType({\n        name: 'power path all',\n        floor: true,\n        matIndex: '60',\n        selectable: true,\n        canCarryFence: true,\n    })\n    static readonly POWER_PATH_BUILDING_SITE = new SurfaceType({\n        name: 'power path building site',\n        floor: true,\n        matIndex: '61',\n        selectable: true,\n        canCarryFence: true,\n    })\n    static readonly POWER_PATH_BUILDING = new SurfaceType({\n        name: 'power path building',\n        floor: true,\n        matIndex: '76',\n    })\n    static readonly POWER_PATH_CONSTRUCTION = new SurfaceType({\n        name: 'power path construction',\n        floor: true,\n        matIndex: '76',\n        selectable: true,\n    })\n    static readonly RUBBLE1 = new SurfaceType({\n        name: 'rubble 1',\n        floor: true,\n        matIndex: '13',\n        selectable: true,\n        canCarryFence: true,\n        cursorFulfiller: Cursor.Pointer_Clear,\n    })\n    static readonly RUBBLE2 = new SurfaceType({\n        name: 'rubble 2',\n        floor: true,\n        matIndex: '12',\n        selectable: true,\n        canCarryFence: true,\n        cursorFulfiller: Cursor.Pointer_Clear,\n    })\n    static readonly RUBBLE3 = new SurfaceType({\n        name: 'rubble 3',\n        floor: true,\n        matIndex: '11',\n        selectable: true,\n        canCarryFence: true,\n        cursorFulfiller: Cursor.Pointer_Clear,\n    })\n    static readonly RUBBLE4 = new SurfaceType({\n        name: 'rubble 4',\n        floor: true,\n        matIndex: '10',\n        selectable: true,\n        canCarryFence: true,\n        cursorFulfiller: Cursor.Pointer_Clear,\n    })\n\n    static getByNum(typeNum: number) {\n        switch (typeNum) {\n            case 0:\n                return SurfaceType.POWER_PATH_BUILDING\n            case 1:\n                return SurfaceType.SOLID_ROCK\n            case 2:\n                return SurfaceType.HARD_ROCK\n            case 3:\n                return SurfaceType.LOOSE_ROCK\n            case 4:\n            case 5: // soil(5) was removed pre-release, so replace it with dirt(4)\n                return SurfaceType.DIRT\n            case 6:\n                return SurfaceType.LAVA\n            case 8:\n                return SurfaceType.ORE_SEAM\n            case 9:\n                return SurfaceType.WATER\n            case 10:\n                return SurfaceType.CRYSTAL_SEAM\n            case 11:\n                return SurfaceType.RECHARGE_SEAM\n            case 30:\n            case 40:\n                return SurfaceType.SLUG_HOLE\n            case 100:\n                return SurfaceType.RUBBLE4\n            case 101:\n                return SurfaceType.RUBBLE3\n            case 102:\n                return SurfaceType.RUBBLE2\n            case 103:\n                return SurfaceType.RUBBLE1\n            default:\n                console.error('Unexpected surface type num: ' + typeNum)\n                return SurfaceType.SOLID_ROCK\n        }\n    }\n}\n","import { EntityType } from '../EntityType'\n\nexport enum RaiderTraining {\n    DRIVER,\n    ENGINEER,\n    GEOLOGIST,\n    PILOT,\n    SAILOR,\n    DEMOLITION,\n}\n\nexport const AllRaiderTrainings: RaiderTraining[] = [\n    RaiderTraining.DRIVER,\n    RaiderTraining.ENGINEER,\n    RaiderTraining.GEOLOGIST,\n    RaiderTraining.PILOT,\n    RaiderTraining.SAILOR,\n    RaiderTraining.DEMOLITION,\n]\n\nexport const RaiderTrainingSites: EntityType[] = []\nRaiderTrainingSites[RaiderTraining.DRIVER] = EntityType.BARRACKS\nRaiderTrainingSites[RaiderTraining.DRIVER] = EntityType.BARRACKS\nRaiderTrainingSites[RaiderTraining.ENGINEER] = EntityType.UPGRADE\nRaiderTrainingSites[RaiderTraining.GEOLOGIST] = EntityType.GEODOME\nRaiderTrainingSites[RaiderTraining.PILOT] = EntityType.TELEPORT_PAD\nRaiderTrainingSites[RaiderTraining.SAILOR] = EntityType.DOCKS\nRaiderTrainingSites[RaiderTraining.DEMOLITION] = EntityType.TOOLSTATION\n\nexport const RaiderTrainingStatsProperty: string[] = []\nRaiderTrainingStatsProperty[RaiderTraining.DRIVER] = 'TrainDriver'\nRaiderTrainingStatsProperty[RaiderTraining.ENGINEER] = 'TrainRepair'\nRaiderTrainingStatsProperty[RaiderTraining.GEOLOGIST] = 'TrainScanner'\nRaiderTrainingStatsProperty[RaiderTraining.PILOT] = 'TrainPilot'\nRaiderTrainingStatsProperty[RaiderTraining.SAILOR] = 'TrainSailor'\nRaiderTrainingStatsProperty[RaiderTraining.DEMOLITION] = 'TrainDynamite'\n","import { Vector3 } from 'three'\n\nexport interface Selectable {\n\n    getSelectionType(): SelectionType\n\n    select(): boolean\n\n    deselect(): any\n\n    getSelectionCenter(): Vector3\n\n}\n\nexport enum SelectionType {\n\n    NOTHING,\n    SURFACE,\n    RAIDER,\n    BUILDING,\n    VEHICLE,\n    GROUP,\n\n}\n","import { Sample } from '../audio/Sample'\nimport { BuildingEntity } from '../game/model/building/BuildingEntity'\nimport { EntityType } from '../game/model/EntityType'\nimport { GameState } from '../game/model/GameState'\nimport { PriorityEntry } from '../game/model/job/PriorityList'\nimport { Surface } from '../game/model/map/Surface'\nimport { SurfaceType } from '../game/model/map/SurfaceType'\nimport { Raider } from '../game/model/raider/Raider'\nimport { AllRaiderTools, RaiderTool } from '../game/model/raider/RaiderTool'\nimport { AllRaiderTrainings, RaiderTraining } from '../game/model/raider/RaiderTraining'\nimport { SelectionType } from '../game/model/Selectable'\nimport { Cursor } from '../screen/Cursor'\nimport { EventKey } from './EventKeyEnum'\nimport { GameEvent } from './GameEvent'\n\nexport class LocalEvent extends GameEvent {\n\n    constructor(eventKey: EventKey) {\n        super(eventKey)\n        this.isLocal = true\n    }\n\n}\n\nexport class SelectionChanged extends LocalEvent {\n\n    selectionType: SelectionType\n    isGround: boolean\n    isPowerPath: boolean\n    canPlaceFence: boolean\n    isFloor: boolean\n    isSite: boolean\n    hasRubble: boolean\n    isDrillable: boolean\n    isDrillableHard: boolean\n    isReinforcable: boolean\n    someCarries: boolean\n    everyHasMaxLevel: boolean\n    canDoTraining: Map<RaiderTraining, boolean> = new Map()\n    everyHasTool: Map<RaiderTool, boolean> = new Map()\n    buildingCanUpgrade: boolean\n    buildingCanSwitchPower: boolean\n\n    constructor(selectionType: SelectionType = SelectionType.NOTHING, selectedSurface: Surface = null, selectedBuilding: BuildingEntity = null, selectedRaiders: Raider[] = null) {\n        super(EventKey.SELECTION_CHANGED)\n        this.selectionType = selectionType\n        this.isGround = selectedSurface?.surfaceType === SurfaceType.GROUND\n        this.isPowerPath = selectedSurface?.surfaceType === SurfaceType.POWER_PATH\n        this.isFloor = selectedSurface?.surfaceType.floor\n        this.isSite = selectedSurface?.surfaceType === SurfaceType.POWER_PATH_CONSTRUCTION || selectedSurface?.surfaceType === SurfaceType.POWER_PATH_BUILDING_SITE\n        this.hasRubble = selectedSurface?.hasRubble()\n        this.isDrillable = selectedSurface?.isDrillable()\n        this.isDrillableHard = selectedSurface?.isDrillableHard()\n        this.isReinforcable = selectedSurface?.isReinforcable()\n        this.canPlaceFence = selectedSurface?.canPlaceFence() && GameState.buildings.some((b) => b.entityType === EntityType.POWER_STATION && b.isUsable())\n        this.someCarries = !!selectedRaiders?.some((r) => !!r.carries)\n        this.everyHasMaxLevel = !!selectedRaiders?.every((r) => r.level >= r.stats.Levels)\n        AllRaiderTrainings.forEach((training) => this.canDoTraining.set(training, GameState.getTrainingSites(training).length > 0 && selectedRaiders?.some((r) => !r.hasTraining(training))))\n        AllRaiderTools.forEach((tool) => this.everyHasTool.set(tool, !!selectedRaiders?.every((r) => r.hasTool(tool))))\n        this.buildingCanUpgrade = selectedBuilding?.canUpgrade()\n        this.buildingCanSwitchPower = !selectedBuilding?.stats.SelfPowered && !selectedBuilding?.stats.PowerBuilding\n    }\n\n}\n\nexport class AirLevelChanged extends LocalEvent {\n\n    airLevel: number\n\n    constructor(airLevel: number) {\n        super(EventKey.AIR_LEVEL_CHANGED)\n        this.airLevel = airLevel\n    }\n\n}\n\nexport class ChangeCursor extends LocalEvent {\n\n    cursor: Cursor\n    timeout: number\n\n    constructor(cursor: Cursor, timeout: number = null) {\n        super(EventKey.CHANGE_CURSOR)\n        this.cursor = cursor\n        this.timeout = timeout\n    }\n\n}\n\nexport class SetupPriorityList extends LocalEvent {\n\n    priorityList: PriorityEntry[]\n\n    constructor(priorityList: PriorityEntry[]) {\n        super(EventKey.SETUP_PRIORITY_LIST)\n        this.priorityList = priorityList\n    }\n\n}\n\nexport class BuildingsChangedEvent extends LocalEvent {\n\n    usableBuildingsByTypeAndLevel: Map<EntityType, Map<number, number>> = new Map()\n\n    constructor() {\n        super(EventKey.BUILDINGS_CHANGED)\n        GameState.buildings.forEach((b) => {\n            if (b.isUsable()) {\n                const perLevel = this.usableBuildingsByTypeAndLevel.getOrUpdate(b.entityType, () => new Map())\n                perLevel.set(b.level, perLevel.getOrUpdate(b.level, () => 0) + 1)\n            }\n        })\n    }\n\n    static countUsable(event: BuildingsChangedEvent, building: EntityType, minLevel: number = 0) {\n        let result = 0\n        event.usableBuildingsByTypeAndLevel.getOrUpdate(building, () => new Map()).forEach((count, level) => {\n            if (level >= minLevel) result += count\n        })\n        return result\n    }\n\n}\n\nexport class RaidersChangedEvent extends LocalEvent {\n\n    numRaiders: number\n    training: RaiderTraining\n\n    constructor(training: RaiderTraining = null) {\n        super(EventKey.RAIDERS_CHANGED)\n        this.numRaiders = GameState.raiders.length\n        this.training = training\n    }\n\n}\n\nexport class PlaySoundEvent extends LocalEvent {\n\n    sample: Sample\n\n    constructor(sample: Sample) {\n        super(EventKey.PLAY_SOUND)\n        this.sample = sample\n    }\n\n}\n","import { Vector3 } from 'three'\nimport { EventBus } from '../../event/EventBus'\nimport { SelectionChanged } from '../../event/LocalEvents'\nimport { ADDITIONAL_RAIDER_PER_SUPPORT, MAX_RAIDER_BASE, TILESIZE } from '../../params'\nimport { BaseEntity } from './BaseEntity'\nimport { BuildingEntity } from './building/BuildingEntity'\nimport { BuildingSite } from './building/BuildingSite'\nimport { MaterialEntity } from './collect/MaterialEntity'\nimport { EntityType } from './EntityType'\nimport { Surface } from './map/Surface'\nimport { Bat } from './monster/Bat'\nimport { SmallSpider } from './monster/SmallSpider'\nimport { Raider } from './raider/Raider'\nimport { RaiderTraining, RaiderTrainingSites, RaiderTrainingStatsProperty } from './raider/RaiderTraining'\nimport { Selectable, SelectionType } from './Selectable'\n\nexport enum GameResultState {\n\n    RUNNING,\n    COMPLETE,\n    FAILED,\n\n}\n\nexport class GameState {\n\n    static resultState: GameResultState = GameResultState.RUNNING\n    static numCrystal: number = 0\n    static numOre: number = 0\n    static numBrick: number = 0\n    static usedCrystals: number = 0\n    static neededCrystals: number = 0\n    static airLevel: number = 1 // air level in percent from 0 to 1.0\n    static selectedEntities: Selectable[] = []\n    static selectionType: SelectionType = null\n    static buildings: BuildingEntity[] = []\n    static buildingsUndiscovered: BuildingEntity[] = []\n    static raiders: Raider[] = []\n    static raidersUndiscovered: Raider[] = []\n    static requestedRaiders: number = 0\n    static materials: MaterialEntity[] = []\n    static materialsUndiscovered: MaterialEntity[] = []\n    static buildingSites: BuildingSite[] = []\n    static spiders: SmallSpider[] = []\n    static spidersBySurface: Map<Surface, SmallSpider[]> = new Map()\n    static bats: Bat[] = []\n    static totalCrystals: number = 0\n    static totalOres: number = 0\n    static totalDiggables: number = 0\n    static remainingDiggables: number = 0\n    static totalCaverns: number = 0\n    static discoveredCaverns: number = 0\n    static levelStartTime: number = 0\n    static levelStopTime: number = 0\n    static oxygenRate: number = 0\n    static buildModeSelection: BuildingEntity = null\n\n    static reset() {\n        this.resultState = GameResultState.RUNNING\n        this.numCrystal = 0\n        this.numOre = 0\n        this.numBrick = 0\n        this.usedCrystals = 0\n        this.neededCrystals = 0\n        this.airLevel = 1\n        this.selectedEntities = []\n        this.selectionType = null\n        this.buildings = []\n        this.buildingsUndiscovered = []\n        this.raiders = []\n        this.raidersUndiscovered = []\n        this.requestedRaiders = 0\n        this.materials = []\n        this.materialsUndiscovered = []\n        this.buildingSites = []\n        this.spiders = []\n        this.spidersBySurface = new Map()\n        this.bats = []\n        this.totalCrystals = 0\n        this.totalOres = 0\n        this.totalDiggables = 0\n        this.remainingDiggables = 0\n        this.totalCaverns = 0\n        this.discoveredCaverns = 0\n        this.levelStartTime = 0\n        this.levelStopTime = 0\n        this.oxygenRate = 0\n        this.buildModeSelection = null\n    }\n\n    static getBuildingsByType(...buildingTypes: EntityType[]): BuildingEntity[] {\n        return this.buildings.filter(b => b.isUsable() && buildingTypes.some(bt => b.entityType === bt))\n    }\n\n    static getClosestBuildingByType(position: Vector3, ...buildingTypes: EntityType[]): BuildingEntity {\n        const targetBuildings = GameState.getBuildingsByType(...buildingTypes)\n        let closest = null, minDist = null\n        targetBuildings.forEach((b) => {\n            const bPos = b.getDropPosition()\n            const dist = position.distanceToSquared(bPos) // TODO better use pathfinding\n            if (closest === null || dist < minDist) {\n                closest = b\n                minDist = dist\n            }\n        })\n        return closest\n    }\n\n    static getTrainingSites(training: RaiderTraining): BuildingEntity[] {\n        return this.buildings.filter((b) => b.entityType === RaiderTrainingSites[training] && b.isUsable() && b.stats[RaiderTrainingStatsProperty[training]][b.level])\n    }\n\n    static selectEntities(entities: Selectable[]) {\n        this.selectedEntities = this.selectedEntities.filter((previouslySelected) => {\n            const stillSelected = entities.indexOf(previouslySelected) !== -1\n            if (!stillSelected) previouslySelected.deselect()\n            return stillSelected\n        })\n        // add new entities that are selectable\n        entities.forEach((freshlySelected) => {\n            if (freshlySelected.select()) {\n                this.selectedEntities.push(freshlySelected)\n            }\n        })\n        // determine and set next selection type\n        const len = this.selectedEntities.length\n        if (len > 1) {\n            this.selectionType = SelectionType.GROUP\n        } else if (len === 1) {\n            this.selectionType = this.selectedEntities[0].getSelectionType()\n        } else if (this.selectionType !== null) {\n            this.selectionType = SelectionType.NOTHING\n        }\n        // AFTER updating selected entities and selection type, publish all events\n        EventBus.publishEvent(new SelectionChanged(this.selectionType, this.selectedSurface, this.selectedBuilding, this.selectedRaiders))\n    }\n\n    static getMaxRaiders(): number {\n        return MAX_RAIDER_BASE + GameState.buildings.count((b) => b.isUsable() && b.entityType === EntityType.BARRACKS) * ADDITIONAL_RAIDER_PER_SUPPORT\n    }\n\n    static discoverSurface(surface: Surface) {\n        const minX = surface.x * TILESIZE, minZ = surface.y * TILESIZE\n        const maxX = minX + TILESIZE, maxZ = minZ + TILESIZE\n        this.discoverEntities(this.raidersUndiscovered, minX, maxX, minZ, maxZ)\n        this.discoverEntities(this.buildingsUndiscovered, minX, maxX, minZ, maxZ)\n        this.discoverEntities(this.materialsUndiscovered, minX, maxX, minZ, maxZ)\n    }\n\n    static discoverEntities(undiscovered: BaseEntity[], minX, maxX, minZ, maxZ) {\n        const discovered = []\n        undiscovered.forEach((e) => {\n            const pos = e.getPosition()\n            if (pos.x >= minX && pos.x < maxX && pos.z >= minZ && pos.z < maxZ) {\n                e.onDiscover()\n                discovered.push(e)\n            }\n        })\n        discovered.forEach((r) => undiscovered.remove(r))\n    }\n\n    static get gameTimeSeconds() {\n        return Math.round((GameState.levelStopTime - GameState.levelStartTime) / 1000)\n    }\n\n    static get selectedSurface(): Surface {\n        return this.selectionType === SelectionType.SURFACE && this.selectedEntities.length > 0 ? this.selectedEntities[0] as Surface : null\n    }\n\n    static get selectedBuilding(): BuildingEntity {\n        return this.selectionType === SelectionType.BUILDING && this.selectedEntities.length > 0 ? this.selectedEntities[0] as BuildingEntity : null\n    }\n\n    static get selectedRaiders(): Raider[] {\n        return (this.selectionType === SelectionType.RAIDER || this.selectionType === SelectionType.GROUP) && this.selectedEntities.length > 0 ? this.selectedEntities as Raider[] : []\n    }\n\n    static get totalOre(): number {\n        return this.numOre + this.numBrick * 5\n    }\n\n    static getNearbySpiders(entity: BaseEntity): SmallSpider[] {\n        const terrain = entity.sceneMgr.terrain\n        const currentSurface = terrain.getSurfaceFromWorld(entity.getPosition())\n        const nearbySpiders: SmallSpider[] = []\n        for (let x = currentSurface.x; x <= currentSurface.x + 1; x++) {\n            for (let y = currentSurface.y; y <= currentSurface.y + 1; y++) {\n                const surface = terrain.getSurface(x, y)\n                nearbySpiders.push(...(GameState.spidersBySurface.get(surface) || []))\n            }\n        }\n        return nearbySpiders\n    }\n\n}\n","import { AnimClip } from './AnimClip'\n\nexport class AnimationEntityType {\n\n    carryNullName: string = ''\n    depositNullName: string = ''\n    toolNullName: string = ''\n    mediumPoly: {} = {}\n    highPoly: {} = {}\n    fPPoly: {} = {}\n    activities: Map<string, { file: string, transcoef: number, lwsfile: boolean, animation: AnimClip }> = new Map()\n\n}\n","const Stats = require('stats.js')\n\nexport class DebugHelper {\n\n    stats\n\n    constructor() {\n        this.stats = new Stats()\n        this.stats.setMode(0) // 0: fps, 1: ms\n\n        this.stats.domElement.style.position = 'absolute'\n        this.stats.domElement.style.left = '0px'\n        this.stats.domElement.style.top = '0px'\n\n        document.body.appendChild(this.stats.domElement)\n        this.hide()\n    }\n\n    show() {\n        this.stats.domElement.style.visibility = 'visible'\n    }\n\n    hide() {\n        this.stats.domElement.style.visibility = 'hidden'\n    }\n\n    renderStart() {\n        this.stats.begin()\n    }\n\n    renderDone() {\n        this.stats.end()\n    }\n\n}\n","import { EntityType } from '../game/model/EntityType'\nimport { PriorityEntry } from '../game/model/job/PriorityList'\nimport { RaiderTool } from '../game/model/raider/RaiderTool'\nimport { RaiderTraining } from '../game/model/raider/RaiderTraining'\nimport { EventKey } from './EventKeyEnum'\nimport { LocalEvent } from './LocalEvents'\n\nexport class GuiCommand extends LocalEvent {\n}\n\nexport class CancelBuildMode extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CANCEL_BUILD_MODE)\n    }\n\n}\n\nexport class SelectBuildMode extends GuiCommand {\n\n    entityType: EntityType\n\n    constructor(entityType: EntityType) {\n        super(EventKey.COMMAND_SELECT_BUILD_MODE)\n        this.entityType = entityType\n    }\n\n}\n\nexport class SelectedRaiderPickTool extends GuiCommand {\n\n    tool: RaiderTool\n\n    constructor(tool: RaiderTool) {\n        super(EventKey.COMMAND_PICK_TOOL)\n        this.tool = tool\n    }\n\n}\n\nexport class CreatePowerPath extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CREATE_POWER_PATH)\n    }\n\n}\n\nexport class PlaceFence extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_PLACE_FENCE)\n    }\n\n}\n\nexport class MakeRubble extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_MAKE_RUBBLE)\n    }\n\n}\n\nexport class ChangeRaiderSpawnRequest extends GuiCommand {\n\n    increase: boolean\n\n    constructor(increase: boolean) {\n        super(EventKey.COMMAND_CHANGE_RAIDER_SPAWN_REQUEST)\n        this.increase = increase\n    }\n\n}\n\nexport class CreateClearRubbleJob extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CREATE_CLEAR_RUBBLE_JOB)\n    }\n\n}\n\nexport class UpgradeBuilding extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_UPGRADE_BUILDING)\n    }\n\n}\n\nexport class BeamUpBuilding extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_BUILDING_BEAMUP)\n    }\n\n}\n\nexport class ChangePriorityList extends GuiCommand {\n\n    priorityList: PriorityEntry[]\n\n    constructor(priorityList: PriorityEntry[]) {\n        super(EventKey.CHANGE_PRIORITY_LIST)\n        this.priorityList = priorityList\n    }\n\n}\n\nexport class ChangeBuildingPowerState extends GuiCommand {\n\n    state: boolean\n\n    constructor(state: boolean) {\n        super(EventKey.COMMAND_CHANGE_BUILDING_POWER_STATE)\n        this.state = state\n    }\n\n}\n\nexport class CreateDrillJob extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CREATE_DRILL_JOB)\n    }\n\n}\n\nexport class CreateReinforceJob extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CREATE_REINFORCE_JOB)\n    }\n\n}\n\nexport class CreateDynamiteJob extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CREATE_DYNAMITE_JOB)\n    }\n\n}\n\nexport class CancelSurfaceJobs extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CANCEL_SURFACE_JOBS)\n    }\n\n}\n\nexport class RaiderEat extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_RAIDER_EAT)\n    }\n\n}\n\nexport class RaiderDrop extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_RAIDER_DROP)\n    }\n\n}\n\nexport class RaiderUpgrade extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_RAIDER_UPGRADE)\n    }\n\n}\n\nexport class RaiderBeamUp extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_RAIDER_BEAMUP)\n    }\n\n}\n\nexport class TrainRaider extends GuiCommand {\n\n    training: RaiderTraining\n\n    constructor(training: RaiderTraining) {\n        super(EventKey.COMMAND_TRAIN_RAIDER)\n        this.training = training\n    }\n\n}\n\nexport class CancelBuilding extends GuiCommand {\n\n    constructor() {\n        super(EventKey.COMMAND_CANCEL_CONSTRUCTION)\n    }\n\n}\n","import { Vector2 } from 'three'\n\nexport class BarrierLocation {\n\n    location: Vector2\n    heading: number\n\n    constructor(location: Vector2, surfaceCenter: Vector2) {\n        this.location = location\n        this.heading = location.clone().sub(surfaceCenter).angle()\n        if (location.y === surfaceCenter.y) {\n            this.heading -= Math.PI / 2\n        } else {\n            this.heading += Math.PI / 2\n        }\n    }\n\n}\n","import { GameState } from '../game/model/GameState'\nimport { PublicJob } from '../game/model/job/Job'\nimport { EventKey } from './EventKeyEnum'\nimport { GameEvent } from './GameEvent'\n\nexport class WorldEvent extends GameEvent {\n\n    constructor(entityKey: EventKey) {\n        super(entityKey)\n        this.isLocal = false\n    }\n\n}\n\nexport abstract class JobEvent extends WorldEvent {\n\n    job: PublicJob\n\n    protected constructor(eventKey: EventKey, job: PublicJob) {\n        super(eventKey)\n        this.guiForward = false\n        this.job = job\n    }\n\n}\n\nexport class JobCreateEvent extends JobEvent {\n\n    constructor(job: PublicJob) {\n        super(EventKey.JOB_CREATE, job)\n    }\n\n}\n\nexport class JobDeleteEvent extends JobEvent {\n\n    constructor(job: PublicJob) {\n        super(EventKey.JOB_DELETE, job)\n    }\n\n}\n\nexport class RequestedRaidersChanged extends WorldEvent {\n\n    numRequestedRaiders: number\n\n    constructor(requestedRaiders: number) {\n        super(EventKey.REQUESTED_RAIDERS_CHANGED)\n        this.numRequestedRaiders = requestedRaiders\n    }\n\n}\n\nexport class MaterialAmountChanged extends WorldEvent {\n\n    numCrystal: number\n    usedCrystal: number\n    neededCrystal: number\n    totalOre: number\n\n    constructor() {\n        super(EventKey.MATERIAL_AMOUNT_CHANGED)\n        this.numCrystal = GameState.numCrystal\n        this.usedCrystal = GameState.usedCrystals\n        this.neededCrystal = GameState.neededCrystals\n        this.totalOre = GameState.totalOre\n    }\n\n}\n\nexport class CavernDiscovered extends WorldEvent {\n\n    constructor() {\n        super(EventKey.CAVERN_DISCOVERED)\n    }\n\n}\n\nexport class OreFoundEvent extends WorldEvent {\n\n    constructor() {\n        super(EventKey.ORE_FOUND)\n    }\n\n}\n","export class BaseActivity {\n\n    activityKey: string\n\n    constructor(activityKey: string) {\n        this.activityKey = activityKey\n    }\n\n}\n","import { BaseActivity } from './BaseActivity'\n\nexport class AnimEntityActivity extends BaseActivity {\n\n    static Stand = new AnimEntityActivity('Activity_Stand')\n\n}\n","import { AnimEntityActivity } from './AnimEntityActivity'\n\nexport class BarrierActivity extends AnimEntityActivity {\n\n    static Short = new AnimEntityActivity('Short')\n    static Expand = new AnimEntityActivity('Expand')\n    static Long = new AnimEntityActivity('Long')\n    static Teleport = new AnimEntityActivity('Teleport')\n\n}\n","import { AnimEntityActivity } from './AnimEntityActivity'\n\n// noinspection JSUnusedGlobalSymbols\nexport class RaiderActivity extends AnimEntityActivity {\n\n    static Route = new RaiderActivity('Activity_Route')\n    static RunPanic = new RaiderActivity('Activity_RunPanic')\n    static Drill = new RaiderActivity('Activity_Drill')\n    static Walk = new RaiderActivity('!Activity_Walk')\n    static Reinforce = new RaiderActivity('Activity_Reinforce')\n    static Reverse = new RaiderActivity('!Activity_Reverse')\n    static TurnLeft = new RaiderActivity('!Activity_TurnLeft')\n    static TurnRight = new RaiderActivity('!Activity_TurnRight')\n    static CantDo = new RaiderActivity('!Activity_CantDo')\n    static Collect = new RaiderActivity('Activity_Collect')\n    static Clear = new RaiderActivity('Activity_Clear')\n    static Carry = new RaiderActivity('Activity_Carry')\n    static CarryTurnLeft = new RaiderActivity('!Activity_CarryTurnLeft')\n    static CarryTurnRight = new RaiderActivity('!Activity_CarryTurnRight')\n    static CarryStand = new RaiderActivity('Activity_CarryStand')\n    static Dynamite = new RaiderActivity('Activity_Dynamite')\n    static Place = new RaiderActivity('Activity_Place')\n    static Deposit = new RaiderActivity('!Activity_Deposit')\n    static TeleportIn = new RaiderActivity('Activity_TeleportIn')\n    static Repair = new RaiderActivity('Activity_Repair')\n    static rest = new RaiderActivity('Activity_rest')\n    static routeRubble = new RaiderActivity('!Activity_routeRubble')\n    static CarryRubble = new RaiderActivity('!Activity_CarryRubble')\n    static Eat = new RaiderActivity('Activity_Eat')\n    static FireLaser = new RaiderActivity('Activity_FireLaser')\n    static GetUp = new RaiderActivity('!Activity_GetUp')\n    static ThrownByRockMonster = new RaiderActivity('Activity_ThrownByRockMonster')\n    static Slip = new RaiderActivity('Activity_Slip')\n    static Train = new RaiderActivity('Activity_Train')\n    static Recharge = new RaiderActivity('!Activity_Recharge')\n\n    static Waiting1 = new RaiderActivity('Activity_Waiting1')\n    static Waiting2 = new RaiderActivity('Activity_Waiting2')\n    static Waiting3 = new RaiderActivity('Activity_Waiting3')\n    static Waiting4 = new RaiderActivity('Activity_Waiting4')\n\n    static Hoverboard = new RaiderActivity('Activity_Hoverboard')\n    static Standhoverboard = new RaiderActivity('Activity_Standhoverboard')\n    static HitLefthoverboard = new RaiderActivity('!Activity_HitLefthoverboard')\n    static HitRighthoverboard = new RaiderActivity('!Activity_HitRighthoverboard')\n    static HitFronthoverboard = new RaiderActivity('!Activity_HitFronthoverboard')\n    static HitBackhoverboard = new RaiderActivity('!Activity_HitBackhoverboard')\n\n    static SMALLTRUCK = new RaiderActivity('Activity_SMALLTRUCK')\n    static StandSMALLTRUCK = new RaiderActivity('Activity_StandSMALLTRUCK')\n    static HitLeftSMALLTRUCK = new RaiderActivity('!Activity_HitLeftSMALLTRUCK')\n    static HitRightSMALLTRUCK = new RaiderActivity('!Activity_HitRightSMALLTRUCK')\n    static HitFrontSMALLTRUCK = new RaiderActivity('!Activity_HitFrontSMALLTRUCK')\n    static HitBackSMALLTRUCK = new RaiderActivity('!Activity_HitBackSMALLTRUCK')\n\n    static SMALLheli = new RaiderActivity('Activity_SMALLheli')\n    static StandSMALLheli = new RaiderActivity('Activity_StandSMALLheli')\n    static HitLeftSMALLheli = new RaiderActivity('!Activity_HitLeftSMALLheli')\n    static HitRightSMALLheli = new RaiderActivity('!Activity_HitRightSMALLheli')\n    static HitFrontSMALLheli = new RaiderActivity('!Activity_HitFrontSMALLheli')\n    static HitBackSMALLheli = new RaiderActivity('!Activity_HitBackSMALLheli')\n\n    static SMALLCAT = new RaiderActivity('Activity_SMALLCAT')\n    static StandSMALLCAT = new RaiderActivity('Activity_StandSMALLCAT')\n    static HitLeftSMALLCAT = new RaiderActivity('!Activity_HitLeftSMALLCAT')\n    static HitRightSMALLCAT = new RaiderActivity('!Activity_HitRightSMALLCAT')\n    static HitFrontSMALLCAT = new RaiderActivity('!Activity_HitFrontSMALLCAT')\n    static HitBackSMALLCAT = new RaiderActivity('!Activity_HitBackSMALLCAT')\n\n    static SMALLMLP = new RaiderActivity('Activity_SMALLMLP')\n    static StandSMALLMLP = new RaiderActivity('Activity_StandSMALLMLP')\n    static HitLeftSMALLMLP = new RaiderActivity('!Activity_HitLeftSMALLMLP')\n    static HitRightSMALLMLP = new RaiderActivity('!Activity_HitRightSMALLMLP')\n    static HitFrontSMALLMLP = new RaiderActivity('!Activity_HitFrontSMALLMLP')\n    static HitBackSMALLMLP = new RaiderActivity('!Activity_HitBackSMALLMLP')\n\n    static LARGECAT = new RaiderActivity('Activity_LARGECAT')\n    static StandLARGECAT = new RaiderActivity('Activity_StandLARGECAT')\n    static HitLeftLARGECAT = new RaiderActivity('!Activity_HitLeftLARGECAT')\n    static HitRightLARGECAT = new RaiderActivity('!Activity_HitRightLARGECAT')\n    static HitFrontLARGECAT = new RaiderActivity('!Activity_HitFrontLARGECAT')\n    static HitBackLARGECAT = new RaiderActivity('!Activity_HitBackLARGECAT')\n\n    static SMALLDIGGER = new RaiderActivity('Activity_SMALLDIGGER')\n    static StandSMALLDIGGER = new RaiderActivity('Activity_StandSMALLDIGGER')\n\n}\n","import { Vector2 } from 'three'\nimport { RaiderActivity } from './activities/RaiderActivity'\nimport { MaterialEntity } from './collect/MaterialEntity'\n\nexport class PathTarget {\n\n    targetLocation: Vector2\n\n    constructor(location: Vector2) {\n        this.targetLocation = location\n    }\n\n    canGatherItem(): boolean {\n        return false\n    }\n\n    gatherItem(item: MaterialEntity) {\n        item.addToScene(null, null)\n    }\n\n    getDropAction(): RaiderActivity {\n        return RaiderActivity.Place\n    }\n\n}\n","export enum JobState {\n\n    INCOMPLETE,\n    COMPLETE,\n    CANCELED,\n\n}\n","export enum JobType {\n\n    DRILL,\n    REINFORCE,\n    CLEAR_RUBBLE,\n    CARRY,\n    MOVE,\n    TRAIN,\n    GET_TOOL,\n    EAT,\n    COMPLETE_POWER_PATH,\n\n}\n","export enum PriorityIdentifier {\n\n    aiPriorityTrain,\n    aiPriorityGetIn,\n    aiPriorityCrystal,\n    aiPriorityOre,\n    aiPriorityRepair,\n    aiPriorityClearing,\n    aiPriorityDestruction,\n    aiPriorityConstruction,\n    aiPriorityReinforce,\n    aiPriorityRecharge,\n\n}\n","import { RaiderActivity } from '../activities/RaiderActivity'\nimport { MaterialEntity } from '../collect/MaterialEntity'\nimport { FulfillerEntity } from '../FulfillerEntity'\nimport { PathTarget } from '../PathTarget'\nimport { RaiderTool } from '../raider/RaiderTool'\nimport { RaiderTraining } from '../raider/RaiderTraining'\nimport { JobState } from './JobState'\nimport { JobType } from './JobType'\nimport { PriorityIdentifier } from './PriorityIdentifier'\n\nexport abstract class Job {\n\n    type: JobType\n    jobState: JobState\n    fulfiller: FulfillerEntity[] = []\n\n    protected constructor(type: JobType) {\n        this.type = type\n        this.jobState = JobState.INCOMPLETE\n    }\n\n    assign(fulfiller: FulfillerEntity) {\n        const index = this.fulfiller.indexOf(fulfiller)\n        if (fulfiller && index === -1) {\n            this.fulfiller.push(fulfiller)\n        }\n    }\n\n    unassign(fulfiller: FulfillerEntity) {\n        this.fulfiller.remove(fulfiller)\n    }\n\n    cancel() {\n        this.jobState = JobState.CANCELED\n        const fulfiller = this.fulfiller // ensure consistency while processing\n        this.fulfiller = []\n        fulfiller.forEach((fulfiller) => fulfiller.stopJob())\n    }\n\n    getRequiredTool(): RaiderTool {\n        return null\n    }\n\n    getRequiredTraining(): RaiderTraining {\n        return null\n    }\n\n    isReadyToComplete(): boolean {\n        return true\n    }\n\n    onJobComplete() {\n        this.jobState = JobState.COMPLETE\n    }\n\n    abstract getWorkplaces(): PathTarget[];\n\n    setActualWorkplace(target: PathTarget) {\n    }\n\n    getCarryItem(): MaterialEntity {\n        return null\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return null\n    }\n\n    getWorkDuration(fulfiller: FulfillerEntity): number {\n        return null\n    }\n\n}\n\nexport abstract class PublicJob extends Job {\n\n    abstract getPriorityIdentifier(): PriorityIdentifier\n\n}\n","import { RaiderActivity } from '../../activities/RaiderActivity'\nimport { MaterialEntity } from '../../collect/MaterialEntity'\nimport { Surface } from '../../map/Surface'\nimport { SurfaceType } from '../../map/SurfaceType'\nimport { PathTarget } from '../../PathTarget'\nimport { RaiderTool } from '../../raider/RaiderTool'\nimport { PublicJob } from '../Job'\nimport { JobType } from '../JobType'\nimport { PriorityIdentifier } from '../PriorityIdentifier'\n\nexport class CompletePowerPathJob extends PublicJob {\n\n    surface: Surface\n    placedItems: MaterialEntity[]\n    workplaces: PathTarget[]\n\n    constructor(surface: Surface, placedItems: MaterialEntity[]) {\n        super(JobType.COMPLETE_POWER_PATH)\n        this.surface = surface\n        this.placedItems = placedItems\n        this.workplaces = [new PathTarget(surface.getRandomPosition())]\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        this.placedItems.forEach((placed) => placed.removeFromScene())\n        this.surface.setSurfaceTypeAndUpdateNeighbors(SurfaceType.POWER_PATH)\n    }\n\n    getRequiredTool(): RaiderTool {\n        return RaiderTool.SHOVEL\n    }\n\n    getPriorityIdentifier(): PriorityIdentifier {\n        return PriorityIdentifier.aiPriorityConstruction\n    }\n\n    getWorkplaces(): PathTarget[] {\n        return this.workplaces\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return RaiderActivity.Clear\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { EventBus } from '../../../event/EventBus'\nimport { SelectionChanged } from '../../../event/LocalEvents'\nimport { JobCreateEvent } from '../../../event/WorldEvents'\nimport { BarrierActivity } from '../activities/BarrierActivity'\nimport { RaiderActivity } from '../activities/RaiderActivity'\nimport { Barrier } from '../collect/Barrier'\nimport { Crystal } from '../collect/Crystal'\nimport { MaterialEntity } from '../collect/MaterialEntity'\nimport { Ore } from '../collect/Ore'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { CompletePowerPathJob } from '../job/surface/CompletePowerPathJob'\nimport { Surface } from '../map/Surface'\nimport { SurfaceType } from '../map/SurfaceType'\nimport { BuildingEntity } from './BuildingEntity'\n\nexport class BuildingSite {\n\n    primarySurface: Surface = null\n    secondarySurface: Surface = null\n    primaryPathSurface: Surface = null\n    surfaces: Surface[] = []\n    building: BuildingEntity\n    heading: number = 0\n    neededByType: Map<EntityType, number> = new Map()\n    assignedByType: Map<EntityType, MaterialEntity[]> = new Map()\n    onSiteByType: Map<EntityType, MaterialEntity[]> = new Map()\n    complete: boolean = false\n    canceled: boolean = false\n\n    constructor(primarySurface: Surface, secondarySurface: Surface, primaryPathSurface: Surface, secondaryPathSurface: Surface, building: BuildingEntity) {\n        this.primarySurface = primarySurface\n        this.primarySurface.setSite(this)\n        this.surfaces.push(this.primarySurface)\n        this.secondarySurface = secondarySurface\n        this.secondarySurface?.setSite(this)\n        this.surfaces.push(this.secondarySurface)\n        this.primaryPathSurface = primaryPathSurface\n        this.primaryPathSurface?.setSurfaceTypeAndUpdateNeighbors(SurfaceType.POWER_PATH_BUILDING)\n        this.surfaces.push(this.primaryPathSurface)\n        secondaryPathSurface?.setSurfaceTypeAndUpdateNeighbors(SurfaceType.POWER_PATH_BUILDING)\n        this.surfaces.push(secondaryPathSurface)\n        this.building = building\n    }\n\n    getRandomDropPosition(): Vector2 {\n        return this.primarySurface.getRandomPosition()\n    }\n\n    needs(EntityType: EntityType): boolean {\n        const needed = this.neededByType.getOrUpdate(EntityType, () => 0)\n        const assigned = this.assignedByType.getOrUpdate(EntityType, () => []).length\n        return needed > assigned\n    }\n\n    assign(item: MaterialEntity) {\n        this.assignedByType.getOrUpdate(item.entityType, () => []).push(item)\n    }\n\n    unAssign(item: MaterialEntity) {\n        this.assignedByType.getOrUpdate(item.entityType, () => []).remove(item)\n    }\n\n    addItem(item: MaterialEntity) {\n        const needed = this.neededByType.getOrUpdate(item.entityType, () => 0)\n        if (this.onSiteByType.getOrUpdate(item.entityType, () => []).length < needed) {\n            item.onAddToSite()\n            this.onSiteByType.getOrUpdate(item.entityType, () => []).push(item)\n            this.checkComplete()\n        } else {\n            item.resetTarget()\n        }\n    }\n\n    checkComplete() {\n        if (this.complete || this.canceled) return\n        this.complete = true\n        this.neededByType.forEach((needed, neededType) => {\n            this.complete = this.complete && this.onSiteByType.getOrUpdate(neededType, () => []).length >= needed\n        })\n        if (!this.complete) return\n        GameState.buildingSites.remove(this)\n        if (!this.building) {\n            const items = []\n            this.onSiteByType.forEach((itemsOnSite) => items.push(...itemsOnSite))\n            EventBus.publishEvent(new JobCreateEvent(new CompletePowerPathJob(this.primarySurface, items)))\n        } else {\n            this.onSiteByType.getOrUpdate(EntityType.BARRIER, () => []).forEach((item: Barrier) => {\n                item.changeActivity(BarrierActivity.Teleport, () => item.removeFromScene())\n            })\n            this.onSiteByType.getOrUpdate(EntityType.CRYSTAL, () => []).forEach((item: Crystal) => {\n                item.removeFromScene()\n            })\n            this.onSiteByType.getOrUpdate(EntityType.ORE, () => []).forEach((item: Ore) => {\n                item.removeFromScene()\n            })\n            const world = this.primarySurface.getCenterWorld2D()\n            this.building.placeDown(world, -this.heading + Math.PI / 2, false)\n        }\n    }\n\n    getDropAction(): RaiderActivity {\n        return RaiderActivity.Place\n    }\n\n    cancelSite() {\n        GameState.buildingSites.remove(this)\n        this.canceled = true\n        this.surfaces.forEach((s) => s?.setSite(null))\n        this.onSiteByType.forEach((materials) => materials.forEach((item) => {\n            item.worldMgr.placeMaterial(item, item.getPosition2D())\n        }))\n        this.onSiteByType.clear()\n        this.assignedByType.forEach((materials) => materials.forEach((item) => {\n            item.resetTarget()\n        }))\n        EventBus.publishEvent(new SelectionChanged())\n    }\n\n    getWalkOutSurface(): Surface {\n        return this.primaryPathSurface || this.primarySurface.neighbors.find((n) => !n.site && n.isWalkable()) ||\n            this.secondarySurface?.neighbors.find((n) => !n.site && n.isWalkable())\n    }\n\n}\n","export enum WALL_TYPE {\n\n    CORNER = 1,\n    WALL = 2,\n    INVERTED_CORNER = 3,\n    WEIRD_CREVICE = 20,\n\n}\n","import { BufferGeometry, Vector2, Vector3 } from 'three'\nimport { BufferAttribute } from 'three/src/core/BufferAttribute'\nimport { WALL_TYPE } from './WallType'\n\nexport class SurfaceGeometry {\n\n    public static create(wallType: WALL_TYPE,\n                         topLeftVertex: Vector3, bottomRightVertex: Vector3, topRightVertex: Vector3, bottomLeftVertex: Vector3,\n                         topLeftHeight: number, topRightHeight: number, bottomRightHeight: number, bottomLeftHeight: number,\n    ) {\n        let uvOffset = 0\n\n        // not-rotated\n        // 1 ?\n        // ? 0\n        if (topLeftVertex.y && !bottomRightVertex.y &&\n            (wallType === WALL_TYPE.INVERTED_CORNER || ((wallType === WALL_TYPE.WALL || wallType === WALL_TYPE.WEIRD_CREVICE) === Boolean(topRightVertex.y)))) {\n            uvOffset = 0\n        }\n\n        // 90 clock-wise\n        // ? 1\n        // 0 ?\n        if (topRightVertex.y && !bottomLeftVertex.y &&\n            (wallType === WALL_TYPE.INVERTED_CORNER || ((wallType === WALL_TYPE.WALL || wallType === WALL_TYPE.WEIRD_CREVICE) === Boolean(bottomRightVertex.y)))) {\n            uvOffset = 3\n        }\n\n        // 180 clock-wise\n        // 0 ?\n        // ? 1\n        if (bottomRightVertex.y && !topLeftVertex.y &&\n            (wallType === WALL_TYPE.INVERTED_CORNER || ((wallType === WALL_TYPE.WALL || wallType === WALL_TYPE.WEIRD_CREVICE) === Boolean(bottomLeftVertex.y)))) {\n            uvOffset = 2\n        }\n\n        // 270 clock-wise\n        // ? 0\n        // 1 ?\n        if (bottomLeftVertex.y && !topRightVertex.y &&\n            (wallType === WALL_TYPE.INVERTED_CORNER || ((wallType === WALL_TYPE.WALL || wallType === WALL_TYPE.WEIRD_CREVICE) === Boolean(topLeftVertex.y)))) {\n            uvOffset = 1\n        }\n\n        if (wallType === WALL_TYPE.WALL || wallType === WALL_TYPE.WEIRD_CREVICE) {\n            if (topLeftVertex.y && bottomRightVertex.y) {\n                uvOffset = 0\n            }\n            if (topRightVertex.y && bottomLeftVertex.y) {\n                uvOffset = 3\n            }\n        }\n\n        /*\n        //\t\t0---1                1         0---1\n        //\t\t|   |  becomes      /|   and   |  /\n        //\t\t|   |             /  |         |/\n        //\t\t3---2            3---2         3\n        //\n        //\t\tOR\n        //\n        //\t\t0---1            0             0---1\n        //\t\t|   |  becomes   |\\    \t and    \\  |\n        //\t\t|   |            |  \\             \\|\n        //\t\t3---2            3---2             2\n        //\n        //\t\tTriangles 0-1-3 and 0-3-2\n        //\t\tQuad 0-1-3-2\n        */\n\n        const uv = [\n            new Vector2(0, 1),\n            new Vector2(1, 1),\n            new Vector2(1, 0),\n            new Vector2(0, 0),\n        ]\n\n        const bufferVertices = []\n        const bufferNormals = []\n\n        function addFaceAndNormals(a, b, c) {\n            bufferVertices.push(a, b, c)\n            const normal = new Vector3().subVectors(c, b)\n            normal.cross(new Vector3().subVectors(a, b))\n            normal.normalize()\n            bufferNormals.push(normal, normal, normal)\n        }\n\n        const uvIndexes = []\n        if (topRightVertex.y !== bottomLeftVertex.y ||\n            ((wallType === WALL_TYPE.WALL || wallType === WALL_TYPE.WEIRD_CREVICE) && !(topRightVertex.y && bottomLeftVertex.y))) {\n            uvIndexes.push(1, 3, 2)\n            uvIndexes.push(1, 0, 3)\n\n            // apply height fine-tuning\n            topLeftVertex.y = topLeftHeight\n            topRightVertex.y = topRightHeight\n            bottomRightVertex.y = bottomRightHeight\n            bottomLeftVertex.y = bottomLeftHeight\n\n            addFaceAndNormals(topRightVertex, bottomLeftVertex, bottomRightVertex)\n            addFaceAndNormals(topRightVertex, topLeftVertex, bottomLeftVertex)\n        } else {\n            uvIndexes.push(0, 3, 2)\n            uvIndexes.push(0, 2, 1)\n\n            // apply height fine-tuning\n            topLeftVertex.y = topLeftHeight\n            topRightVertex.y = topRightHeight\n            bottomRightVertex.y = bottomRightHeight\n            bottomLeftVertex.y = bottomLeftHeight\n\n            addFaceAndNormals(topLeftVertex, bottomLeftVertex, bottomRightVertex)\n            addFaceAndNormals(topLeftVertex, bottomRightVertex, topRightVertex)\n        }\n\n        const bufferVertexUvs = uvIndexes.map(i => uv[(i + uvOffset) % 4])\n\n        const bufferGeometry = new BufferGeometry()\n        bufferGeometry.setAttribute('position', new BufferAttribute(new Float32Array(18), 3).copyVector3sArray(bufferVertices))\n        bufferGeometry.setAttribute('normal', new BufferAttribute(new Float32Array(18), 3).copyVector3sArray(bufferNormals))\n        bufferGeometry.setAttribute('uv', new BufferAttribute(new Float32Array(12), 2).copyVector2sArray(bufferVertexUvs))\n        return bufferGeometry\n    }\n}\n","import { Mesh, MeshPhongMaterial, Vector3 } from 'three'\nimport { TILESIZE } from '../../../params'\nimport { SceneManager } from '../../SceneManager'\nimport { Surface } from '../map/Surface'\nimport { SurfaceGeometry } from '../map/SurfaceGeometry'\nimport { WALL_TYPE } from '../map/WallType'\n\nexport class BuildPlacementMarkerMesh extends Mesh {\n\n    static readonly geometry = SurfaceGeometry.create(WALL_TYPE.WALL,\n        new Vector3(0, 0, 0), new Vector3(TILESIZE, 0, TILESIZE),\n        new Vector3(TILESIZE, 0, 0), new Vector3(0, 0, TILESIZE),\n        1, 1, 1, 1,\n    )\n\n    sceneMgr: SceneManager\n    standardColor: number\n\n    constructor(sceneMgr: SceneManager, standardColor: number) {\n        super(BuildPlacementMarkerMesh.geometry, new MeshPhongMaterial({\n            shininess: 0,\n            transparent: true,\n            opacity: 0.4,\n            color: standardColor,\n        }))\n        this.sceneMgr = sceneMgr\n        this.standardColor = standardColor\n        this.visible = false\n    }\n\n    updateState(position: { x: number, y: number }, heading: number, primaryPosition: Vector3) {\n        this.visible = !!position\n        if (position) {\n            this.position.set(position.x, 0, position.y).multiplyScalar(TILESIZE)\n                .applyAxisAngle(new Vector3(0, 1, 0), -heading + Math.PI / 2)\n                .add(primaryPosition)\n        }\n    }\n\n    markAsValid(isValid: boolean) {\n        const color = isValid ? this.standardColor : 0x500000;\n        (this.material as MeshPhongMaterial).color.setHex(color)\n    }\n\n    get surface(): Surface {\n        return this.visible ? this.sceneMgr.terrain.getSurfaceFromWorld(this.position) : null\n    }\n\n}\n","import { Group, Vector2 } from 'three'\nimport { EventBus } from '../../../event/EventBus'\nimport { CancelBuildMode } from '../../../event/GuiCommand'\nimport { SelectionChanged } from '../../../event/LocalEvents'\nimport { TILESIZE } from '../../../params'\nimport { SceneManager } from '../../SceneManager'\nimport { BarrierLocation } from '../collect/BarrierLocation'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { SurfaceType } from '../map/SurfaceType'\nimport { BuildingSite } from './BuildingSite'\nimport { BuildPlacementMarkerMesh } from './BuildPlacementMarkerMesh'\n\nexport class BuildPlacementMarker {\n\n    static readonly buildingMarkerColor: number = 0x005000\n    static readonly pathMarkerColor: number = 0x505000\n    static readonly waterMarkerColor: number = 0x000050\n\n    sceneMgr: SceneManager\n    group: Group = new Group()\n    markers: BuildPlacementMarkerMesh[] = []\n    buildingMarkerPrimary: BuildPlacementMarkerMesh = null\n    buildingMarkerSecondary: BuildPlacementMarkerMesh = null\n    powerPathMarkerPrimary: BuildPlacementMarkerMesh = null\n    powerPathMarkerSecondary: BuildPlacementMarkerMesh = null\n    waterPathMarker: BuildPlacementMarkerMesh = null\n    heading: number = 0\n    sdx: number = 0\n    sdz: number = 0\n    lastCheck: boolean = false\n\n    constructor(sceneMgr: SceneManager) {\n        this.sceneMgr = sceneMgr\n        this.buildingMarkerPrimary = new BuildPlacementMarkerMesh(this.sceneMgr, BuildPlacementMarker.buildingMarkerColor)\n        this.buildingMarkerSecondary = new BuildPlacementMarkerMesh(this.sceneMgr, BuildPlacementMarker.buildingMarkerColor)\n        this.powerPathMarkerPrimary = new BuildPlacementMarkerMesh(this.sceneMgr, BuildPlacementMarker.pathMarkerColor)\n        this.powerPathMarkerSecondary = new BuildPlacementMarkerMesh(this.sceneMgr, BuildPlacementMarker.pathMarkerColor)\n        this.waterPathMarker = new BuildPlacementMarkerMesh(this.sceneMgr, BuildPlacementMarker.waterMarkerColor)\n        this.addMarker(this.buildingMarkerPrimary)\n        this.addMarker(this.buildingMarkerSecondary)\n        this.addMarker(this.powerPathMarkerPrimary)\n        this.addMarker(this.powerPathMarkerSecondary)\n        this.addMarker(this.waterPathMarker)\n    }\n\n    private addMarker(marker: BuildPlacementMarkerMesh) {\n        this.group.add(marker)\n        this.markers.push(marker)\n    }\n\n    update(worldPosition: Vector2) {\n        if (!worldPosition || !GameState.buildModeSelection) {\n            this.hideAllMarker()\n        } else {\n            const isValid = this.updateAllMarker(worldPosition)\n            this.markers.forEach((c) => c.markAsValid(isValid))\n        }\n    }\n\n    private updateAllMarker(worldPosition: Vector2 = null): boolean {\n        // TODO use surface height offsets, refactor terrain map/data handling before\n        this.buildingMarkerPrimary.visible = true\n        this.buildingMarkerPrimary.position.copy(this.sceneMgr.getFloorPosition(new Vector2(Math.floor(worldPosition.x / TILESIZE) * TILESIZE, Math.floor(worldPosition.y / TILESIZE) * TILESIZE)))\n        const sdxv = worldPosition.x - this.buildingMarkerPrimary.position.x - TILESIZE / 2\n        const sdzv = worldPosition.y - this.buildingMarkerPrimary.position.z - TILESIZE / 2\n        const sdx = Math.abs(sdxv) > Math.abs(sdzv) ? Math.sign(sdxv) : 0\n        const sdz = Math.abs(sdzv) > Math.abs(sdxv) ? Math.sign(sdzv) : 0\n        if (this.sdx === sdx && this.sdz === sdz) return this.lastCheck\n        this.sdx = sdx\n        this.sdz = sdz\n        this.heading = Math.atan2(sdz, sdx)\n        this.buildingMarkerSecondary.updateState(GameState.buildModeSelection.secondaryBuildingPart, this.heading, this.buildingMarkerPrimary.position)\n        this.powerPathMarkerPrimary.updateState(GameState.buildModeSelection.primaryPowerPath, this.heading, this.buildingMarkerPrimary.position)\n        this.powerPathMarkerSecondary.updateState(GameState.buildModeSelection.secondaryPowerPath, this.heading, this.buildingMarkerPrimary.position)\n        this.waterPathMarker.updateState(GameState.buildModeSelection.waterPathSurface, this.heading, this.buildingMarkerPrimary.position)\n        const allSurfacesAreGround = [this.buildingMarkerPrimary, this.buildingMarkerSecondary, this.powerPathMarkerPrimary, this.powerPathMarkerSecondary]\n            .filter((c) => c.visible).map((c) => this.sceneMgr.terrain.getSurfaceFromWorld(c.position)).every((s) => s.surfaceType === SurfaceType.GROUND)\n        this.lastCheck = allSurfacesAreGround && (\n            [this.powerPathMarkerPrimary, this.powerPathMarkerSecondary].some((c) => c.visible && c.surface.neighbors.some((n) => n.surfaceType === SurfaceType.POWER_PATH)) ||\n            (!GameState.buildModeSelection.primaryPowerPath && (this.buildingMarkerPrimary.surface.neighbors.some((n) => n.surfaceType === SurfaceType.POWER_PATH ||\n                (this.buildingMarkerSecondary.visible && this.buildingMarkerSecondary.surface.neighbors.some((n) => n.surfaceType === SurfaceType.POWER_PATH)))))\n        ) && (!this.waterPathMarker.visible || this.waterPathMarker.surface.surfaceType === SurfaceType.WATER)\n        return this.lastCheck\n    }\n\n    hideAllMarker() {\n        this.markers.forEach((m) => m.visible = false)\n        this.lastCheck = false\n    }\n\n    createBuildingSite() {\n        const barrierLocations = this.getBarrierLocations()\n        const stats = GameState.buildModeSelection.stats\n        const neededCrystals = stats?.CostCrystal || 0\n        const neededOre = stats?.CostOre || 0\n        const primarySurface = this.buildingMarkerPrimary.surface\n        const site = new BuildingSite(primarySurface, this.buildingMarkerSecondary.surface, this.powerPathMarkerPrimary.surface, this.powerPathMarkerSecondary.surface, GameState.buildModeSelection)\n        site.heading = this.heading\n        site.neededByType.set(EntityType.BARRIER, barrierLocations.length)\n        site.neededByType.set(EntityType.CRYSTAL, neededCrystals)\n        site.neededByType.set(EntityType.ORE, neededOre)\n        GameState.buildingSites.push(site)\n        const closestToolstation = GameState.getClosestBuildingByType(primarySurface.getCenterWorld(), EntityType.TOOLSTATION)\n        if (closestToolstation) {\n            closestToolstation.spawnBarriers(barrierLocations, site)\n            closestToolstation.spawnMaterials(EntityType.CRYSTAL, neededCrystals)\n            closestToolstation.spawnMaterials(EntityType.ORE, neededOre)\n        }\n        EventBus.publishEvent(new SelectionChanged())\n        EventBus.publishEvent(new CancelBuildMode())\n    }\n\n    getBarrierLocations(): BarrierLocation[] {\n        const barrierLocations: BarrierLocation[] = []\n        const centerPrimary = this.buildingMarkerPrimary.surface.getCenterWorld2D()\n        const barrierOffset = TILESIZE * 9 / 20\n        if (this.buildingMarkerSecondary.visible) {\n            const centerSecondary = this.buildingMarkerSecondary.surface.getCenterWorld2D()\n            const dx = Math.sign(centerSecondary.x - centerPrimary.x)\n            const dy = Math.sign(centerSecondary.y - centerPrimary.y)\n            if (dx !== 0) {\n                barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x - dx * barrierOffset, centerPrimary.y), centerPrimary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x, centerPrimary.y - barrierOffset), centerPrimary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x, centerPrimary.y + barrierOffset), centerPrimary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerSecondary.x + dx * barrierOffset, centerSecondary.y), centerSecondary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerSecondary.x, centerSecondary.y - barrierOffset), centerSecondary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerSecondary.x, centerSecondary.y + barrierOffset), centerSecondary))\n            } else {\n                barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x, centerPrimary.y - dy * barrierOffset), centerPrimary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x - barrierOffset, centerPrimary.y), centerPrimary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x + barrierOffset, centerPrimary.y), centerPrimary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerSecondary.x, centerSecondary.y + dy * barrierOffset), centerSecondary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerSecondary.x - barrierOffset, centerSecondary.y), centerSecondary))\n                barrierLocations.push(new BarrierLocation(new Vector2(centerSecondary.x + barrierOffset, centerSecondary.y), centerSecondary))\n            }\n        } else {\n            barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x - barrierOffset, centerPrimary.y), centerPrimary))\n            barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x, centerPrimary.y - barrierOffset), centerPrimary))\n            barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x + barrierOffset, centerPrimary.y), centerPrimary))\n            barrierLocations.push(new BarrierLocation(new Vector2(centerPrimary.x, centerPrimary.y + barrierOffset), centerPrimary))\n        }\n        return barrierLocations\n    }\n\n}\n","// javascript-astar 0.4.1 (converted to typescript by Scarabol)\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node) {\n    let curr = node\n    const path = []\n    while (curr.parent) {\n        path.unshift(curr)\n        curr = curr.parent\n    }\n    return path\n}\n\nfunction getHeap() {\n    return new BinaryHeap(function (node) {\n        return node.f\n    })\n}\n\nexport const astar = {\n\n    /**\n     * Perform an A* Search on a graph given a start and end node.\n     * @param {Graph} graph\n     * @param {GridNode} start\n     * @param {GridNode} end\n     * @param {Object} [options]\n     * @param {boolean} [options.closest] Specifies whether to return the\n     path to the closest node if the target is unreachable.\n     * @param {Function} [options.heuristic] Heuristic function (see\n     *          astar.heuristics).\n     */\n    search(graph: Graph, start: GridNode, end: GridNode, options = null): GridNode[] {\n        graph.cleanDirty()\n        options = options || {}\n        const heuristic = options.heuristic || astar.heuristics.manhattan\n        const closest = options.closest || false\n\n        const openHeap = getHeap()\n        let closestNode = start  // set the start node to be the closest if required\n\n        start.h = heuristic(start, end)\n        graph.markDirty(start)\n\n        openHeap.push(start)\n\n        while (openHeap.size() > 0) {\n\n            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n            const currentNode = openHeap.pop()\n\n            // End case -- result has been found, return the traced path.\n            if (currentNode === end) {\n                return pathTo(currentNode)\n            }\n\n            // Normal case -- move currentNode from open to closed, process each of its neighbors.\n            currentNode.closed = true\n\n            // Find all neighbors for the current node.\n            const neighbors = graph.neighbors(currentNode)\n\n            let i = 0\n            const il = neighbors.length\n            for (; i < il; ++i) {\n                const neighbor = neighbors[i]\n\n                if (neighbor.closed || neighbor.isWall()) {\n                    // Not a valid node to process, skip to next neighbor.\n                    continue\n                }\n\n                // The g score is the shortest distance from start to current node.\n                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n                const gScore = currentNode.g + neighbor.getCost(currentNode)\n                const beenVisited = neighbor.visited\n\n                if (!beenVisited || gScore < neighbor.g) {\n\n                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                    neighbor.visited = true\n                    neighbor.parent = currentNode\n                    neighbor.h = neighbor.h || heuristic(neighbor, end)\n                    neighbor.g = gScore\n                    neighbor.f = neighbor.g + neighbor.h\n                    graph.markDirty(neighbor)\n                    if (closest) {\n                        // If the neighbour is closer than the current closestNode or if it's equally close but has\n                        // a cheaper path than the current closest node then it becomes the closest node\n                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n                            closestNode = neighbor\n                        }\n                    }\n\n                    if (!beenVisited) {\n                        // Pushing to heap will put it in proper place based on the 'f' value.\n                        openHeap.push(neighbor)\n                    } else {\n                        // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                        openHeap.rescoreElement(neighbor)\n                    }\n                }\n            }\n        }\n\n        if (closest) {\n            return pathTo(closestNode)\n        }\n\n        // No result was found - empty array signifies failure to find path.\n        return []\n    },\n\n    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n    heuristics: {\n        manhattan(pos0, pos1) {\n            const d1 = Math.abs(pos1.x - pos0.x)\n            const d2 = Math.abs(pos1.y - pos0.y)\n            return d1 + d2\n        },\n\n        diagonal(pos0, pos1) {\n            const D = 1\n            const D2 = Math.sqrt(2)\n            const d1 = Math.abs(pos1.x - pos0.x)\n            const d2 = Math.abs(pos1.y - pos0.y)\n            return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2))\n        },\n    },\n\n    cleanNode(node) {\n        node.f = 0\n        node.g = 0\n        node.h = 0\n        node.visited = false\n        node.closed = false\n        node.parent = null\n    },\n}\n\nexport class Graph {\n\n    readonly nodes: GridNode[] = []\n    readonly diagonal: boolean\n    readonly grid: GridNode[][] = []\n    dirtyNodes: GridNode[] = []\n\n    /**\n     * A graph memory structure\n     * @param {Array} gridIn 2D array of input weights\n     * @param {Object} [options]\n     * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\n     */\n    constructor(gridIn: number[][], options = null) {\n        options = options || {}\n        this.diagonal = !!options.diagonal\n        for (let x = 0; x < gridIn.length; x++) {\n            this.grid[x] = []\n\n            let y = 0\n            const row = gridIn[x]\n            for (; y < row.length; y++) {\n                const node = new GridNode(x, y, row[y])\n                this.grid[x][y] = node\n                this.nodes.push(node)\n            }\n        }\n        this.init()\n    }\n\n    init() {\n        this.dirtyNodes = []\n        for (let i = 0; i < this.nodes.length; i++) {\n            astar.cleanNode(this.nodes[i])\n        }\n    }\n\n    cleanDirty() {\n        for (let i = 0; i < this.dirtyNodes.length; i++) {\n            astar.cleanNode(this.dirtyNodes[i])\n        }\n        this.dirtyNodes = []\n    }\n\n    markDirty(node) {\n        this.dirtyNodes.push(node)\n    }\n\n    neighbors(node: GridNode) {\n        const ret: GridNode[] = []\n        const x = node.x\n        const y = node.y\n        const grid = this.grid\n\n        // West\n        if (grid[x - 1] && grid[x - 1][y]) {\n            ret.push(grid[x - 1][y])\n        }\n\n        // East\n        if (grid[x + 1] && grid[x + 1][y]) {\n            ret.push(grid[x + 1][y])\n        }\n\n        // South\n        if (grid[x] && grid[x][y - 1]) {\n            ret.push(grid[x][y - 1])\n        }\n\n        // North\n        if (grid[x] && grid[x][y + 1]) {\n            ret.push(grid[x][y + 1])\n        }\n\n        if (this.diagonal) {\n            // Southwest\n            if (grid[x - 1] && grid[x - 1][y - 1]) {\n                ret.push(grid[x - 1][y - 1])\n            }\n\n            // Southeast\n            if (grid[x + 1] && grid[x + 1][y - 1]) {\n                ret.push(grid[x + 1][y - 1])\n            }\n\n            // Northwest\n            if (grid[x - 1] && grid[x - 1][y + 1]) {\n                ret.push(grid[x - 1][y + 1])\n            }\n\n            // Northeast\n            if (grid[x + 1] && grid[x + 1][y + 1]) {\n                ret.push(grid[x + 1][y + 1])\n            }\n        }\n\n        return ret\n    }\n\n    toString() {\n        const graphString = []\n        const nodes = this.grid\n        for (let x = 0; x < nodes.length; x++) {\n            const rowDebug = []\n            const row = nodes[x]\n            for (let y = 0; y < row.length; y++) {\n                rowDebug.push(row[y].weight)\n            }\n            graphString.push(rowDebug.join(' '))\n        }\n        return graphString.join('\\n')\n    }\n}\n\nclass GridNode {\n\n    x: number\n    y: number\n    weight: number\n    h: number\n    closed: boolean\n    visited: boolean\n    g: number\n    parent: GridNode\n    f: number\n\n    constructor(x, y, weight) {\n        this.x = x\n        this.y = y\n        this.weight = weight\n    }\n\n    toString() {\n        return '[' + this.x + ' ' + this.y + ']'\n    }\n\n    getCost(fromNeighbor: GridNode) {\n        // Take diagonal weight into consideration.\n        if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n            return this.weight * 1.41421\n        }\n        return this.weight\n    }\n\n    isWall() {\n        return this.weight === 0\n    }\n}\n\nclass BinaryHeap {\n\n    content = []\n    scoreFunction\n\n    constructor(scoreFunction) {\n        this.content = []\n        this.scoreFunction = scoreFunction\n    }\n\n    push(element) {\n        // Add the new element to the end of the array.\n        this.content.push(element)\n\n        // Allow it to sink down.\n        this.sinkDown(this.content.length - 1)\n    }\n\n    pop() {\n        // Store the first element so we can return it later.\n        const result = this.content[0]\n        // Get the element at the end of the array.\n        const end = this.content.pop()\n        // If there are any elements left, put the end element at the\n        // start, and let it bubble up.\n        if (this.content.length > 0) {\n            this.content[0] = end\n            this.bubbleUp(0)\n        }\n        return result\n    }\n\n    remove(node) {\n        const i = this.content.indexOf(node)\n\n        // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n        const end = this.content.pop()\n\n        if (i !== this.content.length - 1) {\n            this.content[i] = end\n\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\n                this.sinkDown(i)\n            } else {\n                this.bubbleUp(i)\n            }\n        }\n    }\n\n    size() {\n        return this.content.length\n    }\n\n    rescoreElement(node) {\n        this.sinkDown(this.content.indexOf(node))\n    }\n\n    sinkDown(n) {\n        // Fetch the element that has to be sunk.\n        const element = this.content[n]\n\n        // When at 0, an element can not sink any further.\n        while (n > 0) {\n\n            // Compute the parent element's index, and fetch it.\n            const parentN = ((n + 1) >> 1) - 1\n            const parent = this.content[parentN]\n            // Swap the elements if the parent is greater.\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n                this.content[parentN] = element\n                this.content[n] = parent\n                // Update 'n' to continue at the new position.\n                n = parentN\n            }\n            // Found a parent that is less, no need to sink any further.\n            else {\n                break\n            }\n        }\n    }\n\n    bubbleUp(n) {\n        // Look up the target element and its score.\n        const length = this.content.length\n        const element = this.content[n]\n        const elemScore = this.scoreFunction(element)\n\n        while (true) {\n            // Compute the indices of the child elements.\n            const child2N = (n + 1) << 1\n            const child1N = child2N - 1\n            // This is used to store the new position of the element, if any.\n            let swap = null\n            let child1Score\n            // If the first child exists (is inside the array)...\n            if (child1N < length) {\n                // Look it up and compute its score.\n                const child1 = this.content[child1N]\n                child1Score = this.scoreFunction(child1)\n\n                // If the score is less than our element's, we need to swap.\n                if (child1Score < elemScore) {\n                    swap = child1N\n                }\n            }\n\n            // Do the same checks for the other child.\n            if (child2N < length) {\n                const child2 = this.content[child2N]\n                const child2Score = this.scoreFunction(child2)\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\n                    swap = child2N\n                }\n            }\n\n            // If the element needs to be moved, swap it, and continue.\n            if (swap !== null) {\n                this.content[n] = this.content[swap]\n                this.content[swap] = element\n                n = swap\n            }\n            // Otherwise, we are done.\n            else {\n                break\n            }\n        }\n    }\n}\n","import { Vector3 } from 'three'\nimport { EventKey } from './EventKeyEnum'\nimport { WorldEvent } from './WorldEvents'\n\nexport class WorldLocationEvent extends WorldEvent {\n\n    location: Vector3\n\n    constructor(entityKey: EventKey, location: Vector3) {\n        super(entityKey)\n        this.location = location\n    }\n\n}\n\nexport class GenericDeathEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_DEATH, location)\n    }\n\n}\n\nexport class GenericMonsterEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_MONSTER, location)\n    }\n\n}\n\nexport class CrystalFoundEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_CRYSTAL_FOUND, location)\n    }\n\n}\n\nexport class UnderAttackEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_UNDER_ATTACK, location)\n    }\n\n}\n\nexport class LandslideEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_LANDSLIDE, location)\n    }\n\n}\n\nexport class PowerDrainEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_POWER_DRAIN, location)\n    }\n\n}\n\nexport class SlugEmergeEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_SLUG_EMERGE, location)\n    }\n\n}\n\nexport class RaiderDiscoveredEvent extends WorldLocationEvent {\n\n    constructor(location: Vector3) {\n        super(EventKey.LOCATION_RAIDER_DISCOVERED, location)\n    }\n\n}\n","import { AnimSubObj } from './AnimSubObj'\n\nexport class AnimClip {\n\n    looping: boolean = false\n    transcoef: number = 1\n    firstFrame: number = null\n    lastFrame: number = null\n    framesPerSecond: number = null\n    bodies: AnimSubObj[] = []\n\n}\n","import { Euler, MathUtils, Object3D, Vector3 } from 'three'\nimport degToRad = MathUtils.degToRad\n\nexport class AnimSubObj {\n\n    name: string = ''\n    filename: string = ''\n    pivot: Vector3 = new Vector3(0, 0, 0)\n    relPos: Vector3[] = []\n    relRot: Euler[] = []\n    relScale: Vector3[] = []\n    opacity: number[] = []\n    parentObjInd: number = null\n    model: Object3D = null\n\n    radVec(degX: number, degY: number, degZ: number) {\n        return new Euler(degToRad(degY), degToRad(degX), degToRad(degZ), 'YXZ')\n    }\n\n    setFrameAndFollowing(animationFrameIndex: number, lastFrame: number, infos: number[]) {\n        this.relPos[animationFrameIndex] = new Vector3(infos[0], infos[1], infos[2])\n        this.relRot[animationFrameIndex] = this.radVec(infos[3], infos[4], infos[5])\n        this.relScale[animationFrameIndex] = new Vector3(infos[6], infos[7], infos[8])\n        for (let c = animationFrameIndex; c <= lastFrame; c++) {\n            this.relPos[c] = this.relPos[animationFrameIndex]\n            this.relRot[c] = this.relRot[animationFrameIndex]\n            this.relScale[c] = this.relScale[animationFrameIndex]\n        }\n    }\n\n    setOpacityAndFollowing(animationFrameIndex: number, lastFrame: number, value: number) {\n        for (let c = animationFrameIndex; c <= lastFrame; c++) {\n            this.opacity[c] = value\n        }\n    }\n\n}\n","import { Mesh } from 'three'\nimport { clearIntervalSafe } from '../core/Util'\n\nexport class AnimatedMesh {\n\n    mesh: Mesh = null\n    textureSequences = []\n\n    constructor(mesh: Mesh, textureSequences: any[]) {\n        this.mesh = mesh\n        this.textureSequences = textureSequences\n    }\n\n    dispose() {\n        this.textureSequences.forEach((s) => clearIntervalSafe(s))\n        this.mesh.geometry.dispose()\n        Array.isArray(this.mesh.material) ? this.mesh.material.forEach(mat => mat.dispose()) : this.mesh.material?.dispose()\n    }\n\n}\n","// noinspection JSUnusedLocalSymbols,JSBitwiseOperatorUsage\n\n/**\n * @author Marcus-Bizal https://github.com/marcbizal\n * patched by Scarabol\n *\n * This loader loads LWOB files exported from LW6.\n *\n * Support\n *  -\n */\n\nimport { AdditiveBlending, BufferAttribute, BufferGeometry, Color, DoubleSide, Mesh, MeshPhongMaterial, Vector3 } from 'three'\nimport { decodeFilepath, decodeString, getFilename } from '../core/Util'\nimport { SEQUENCE_TEXTURE_FRAMERATE } from '../params'\nimport { AnimatedMesh } from './AnimatedMesh'\nimport { ResourceManager } from './ResourceManager'\n\n// HEADER SPEC //\nconst LWO_MAGIC = 0x4C574F42 // \"LWOB\"\nconst OFF_MAGIC = 8\n\n/********************/\n/* TYPE SIZES START */\n/********************/\n\nconst ID4_SIZE = 4\nconst I1_SIZE = 1\nconst I2_SIZE = 2\nconst I4_SIZE = 4\nconst F4_SIZE = 4\n\nconst COL4_SIZE = 4\nconst VEC12_SIZE = 12\nconst IP2_SIZE = 2\nconst FP4_SIZE = 4\nconst DEG4_SIZE = 4\n\n/********************/\n/*  TYPE SIZES END  */\n/********************/\n\n/*********************/\n/* CHUNK TYPES START */\n/*********************/\n\nconst LWO_FORM = 0x464F524D\nconst LWO_PNTS = 0x504E5453\nconst LWO_SFRS = 0x53524653\nconst LWO_POLS = 0x504F4C53\nconst LWO_CRVS = 0x43525653\nconst LWO_PCHS = 0x50434853\nconst LWO_SURF = 0x53555246\n\nconst CHUNK_HEADER_SIZE = 8\nconst SUBCHUNK_HEADER_SIZE = 6\n\n/*********************/\n/*  CHUNK TYPES END  */\n/*********************/\n\n/**************************/\n/* SURF DEFINITIONS START */\n/**************************/\n\n/**************************/\n/* SURF DEFINITIONS START */\n/**************************/\n\nconst SURF_COLR = 0x434F4C52\nconst SURF_FLAG = 0x464C4147\n\n// Base Shading Values (Fixed Point)\nconst SURF_LUMI = 0x4C554D49\nconst SURF_DIFF = 0x44494646\nconst SURF_SPEC = 0x53504543\nconst SURF_REFL = 0x5245464C\nconst SURF_TRAN = 0x5452414E\n\n// Base Shading Values (Floating Point)\nconst SURF_VLUM = 0x564C554D\nconst SURF_VDIF = 0x56444946\nconst SURF_VSPC = 0x56535043\nconst SURF_VRFL = 0x5646524C\nconst SURF_VTRN = 0x5654524E\n\nconst SURF_GLOS = 0x474C4F53\nconst SURF_RFLT = 0x52464C54\nconst SURF_RIMG = 0x52494D47\nconst SURF_RIND = 0x52494E44\nconst SURF_EDGE = 0x45444745\nconst SURF_SMAN = 0x534D414E\n\n/**************************/\n/*  SURF DEFINITIONS END  */\n/**************************/\n\n/*****************************/\n/* TEXTURE DEFINITIONS START */\n/*****************************/\n\n// Start of Definition\nconst SURF_CTEX = 0x43544558\nconst SURF_DTEX = 0x44544558\nconst SURF_STEX = 0x53544558\nconst SURF_RTEX = 0x52544558\nconst SURF_TTEX = 0x54544558\nconst SURF_LTEX = 0x4C544558\nconst SURF_BTEX = 0x42544558\n\n// Flags\nconst SURF_TFLG = 0x54464C47\n\n// Location and Size\nconst SURF_TSIZ = 0x5453495A\nconst SURF_TCTR = 0x54435452\nconst SURF_TFAL = 0x5446414C\nconst SURF_TVEL = 0x5456454C\n\n// Color\nconst SURF_TCLR = 0x54434C52\n\n// Value\nconst SURF_TVAL = 0x54434C52\n\n// Bump Amplitude\nconst SURF_TAMP = 0x54414D50\n\n// Image Map\nconst SURF_TIMG = 0x54494D47\n\n// Image Alpha\nconst SURF_TALP = 0x54414C50\n\n// Image Wrap Options\nconst SURF_TWRP = 0x54575250\n\n// Antialiasing Strength\nconst SURF_TAAS = 0x54414153\n\n// Texture Opacity\nconst SURF_TOPC = 0x544F5043\n\n/*****************************/\n/*  TEXTURE DEFINITIONS END  */\n/*****************************/\n\n/*************************/\n/* FLAG DEFINITION START */\n/*************************/\n\nconst LUMINOUS_BIT = 1\nconst OUTLINE_BIT = 2\nconst SMOOTHING_BIT = 4\nconst COLORHIGHLIGHTS_BIT = 8\nconst COLORFILTER_BIT = 16\nconst OPAQUEEDGE_BIT = 32\nconst TRANSPARENTEDGE_BIT = 64\nconst SHARPTERMINATOR_BIT = 128\nconst DOUBLESIDED_BIT = 256\nconst ADDITIVE_BIT = 512\nconst SHADOWALPHA_BIT = 1024\n\n/*************************/\n/*  FLAG DEFINITION END  */\n/*************************/\n\n/*************************/\n/* TFLG DEFINITION START */\n/*************************/\n\nconst XAXIS_BIT = 1\nconst YAXIS_BIT = 2\nconst ZAXIS_BIT = 4\nconst WORLDCOORDS_BIT = 8\nconst NEGATIVEIMAGE_BIT = 16\nconst PIXELBLENDING_BIT = 32\nconst ANTIALIASING_BIT = 64\n\n/*************************/\n/*  TFLG DEFINITION END  */\n\n/*************************/\n\nfunction getVector3AtOffset(view, offset) {\n    let vector = new Vector3()\n    vector.x = view.getFloat32(offset)\n    vector.y = view.getFloat32(offset + F4_SIZE)\n    vector.z = view.getFloat32(offset + (F4_SIZE * 2))\n    return vector\n}\n\nfunction planarMapUVS(geometry, vertices, uvs, indices, materialIndex, size, center, flags) {\n    // Check to ensure that one of the flags is set, if not throw an error.\n    const mask = XAXIS_BIT | YAXIS_BIT | ZAXIS_BIT\n    if (flags & mask) {\n        for (let group of geometry.groups) {\n            if (group.materialIndex !== materialIndex) continue\n\n            for (let i = group.start; i < group.start + group.count; i++) {\n\n                let vertexIndex = indices[i] * 3\n                let x = vertices[vertexIndex] - center.x\n                let y = vertices[vertexIndex + 1] - center.y\n                let z = vertices[vertexIndex + 2] - center.z\n\n                let uvIndex = indices[i] * 2\n                let u = 0\n                let v = 0\n\n                if (flags & XAXIS_BIT) {\n                    u = z / size.z + 0.5\n                    v = y / size.y + 0.5\n                } else if (flags & YAXIS_BIT) {\n                    u = x / size.x + 0.5\n                    v = z / size.z + 0.5\n                } else if (flags & ZAXIS_BIT) {\n                    u = x / size.x + 0.5\n                    v = y / size.y + 0.5\n                }\n\n                uvs[uvIndex] = u\n                uvs[uvIndex + 1] = v\n            }\n        }\n    } else {\n        // console.warn(\"LWOLoader.planarMapUVS: No axis bit is set!\"); // XXX what is this about\n    }\n}\n\nexport class LWOLoader {\n\n    COUNTER_CLOCKWISE: false\n\n    path: string = ''\n    verbose: boolean = false\n    materials: MeshPhongMaterial[] = []\n    geometry: BufferGeometry = new BufferGeometry()\n    vertices: Float32Array = null\n    indices: Uint16Array = null\n    uvs: Float32Array = null\n    sequenceIntervals = []\n\n    constructor(path: string, verbose: boolean = false) {\n        this.path = path\n        this.verbose = verbose\n        if (this.verbose) console.log('LWO path: ' + this.path)\n    }\n\n    parsePoints(view, chunkOffset, chunkSize) {\n        if (chunkSize % VEC12_SIZE !== 0) {\n            console.error('LWOLoader.parse: F12 does not evenly divide into chunk size (' + chunkSize + '). Possible corruption.')\n            return\n        }\n\n        let numVertices = (chunkSize / F4_SIZE) / 3\n        this.vertices = new Float32Array(numVertices * 3)\n        this.uvs = new Float32Array(numVertices * 2)\n\n        for (let i = 0; i < numVertices; i++) {\n            let vertexIndex = i * 3\n            let vertexOffset = vertexIndex * F4_SIZE\n            this.vertices[vertexIndex] = view.getFloat32(chunkOffset + vertexOffset) \t\t\t\t// x\n            this.vertices[vertexIndex + 1] = view.getFloat32(chunkOffset + vertexOffset + F4_SIZE) \t// y\n            this.vertices[vertexIndex + 2] = view.getFloat32(chunkOffset + vertexOffset + (F4_SIZE * 2)) \t// z\n        }\n    }\n\n    parseSurfaceNames(buffer, chunkOffset, chunkSize) {\n        let textChunk = new TextDecoder().decode(new Uint8Array(buffer, chunkOffset, chunkSize))\n        let surfaceNames = textChunk.split('\\0').filter(function (s) {\n            return s !== ''\n        })\n\n        for (let i = 0; i < surfaceNames.length; i++) {\n            const new_material = new MeshPhongMaterial()\n            new_material.name = surfaceNames[i]\n            new_material.side = DoubleSide\n            new_material.alphaToCoverage = true\n\n            this.materials.push(new_material)\n        }\n        if (this.verbose) console.log('LWO contains ' + this.materials.length + ' materials with following names: ' + surfaceNames)\n    }\n\n    parsePolygons(view, chunkOffset, chunkSize) {\n        // Gather some initial data so that we can get the proper size\n        let totalNumIndices = 0\n        let offset = 0\n        while (offset < chunkSize) {\n            const numIndices = view.getInt16(chunkOffset + offset)\n            const materialIndex = view.getInt16(chunkOffset + offset + 2 + (numIndices * 2))\n\n            this.geometry.addGroup(totalNumIndices, (numIndices - 2) * 3, materialIndex - 1)\n\n            totalNumIndices += (numIndices - 2) * 3\n            offset += 4 + (numIndices * 2)\n        }\n\n        offset = 0\n        let currentIndex = 0\n        this.indices = new Uint16Array(totalNumIndices)\n        while (offset < chunkSize) {\n            let numIndices = view.getInt16(chunkOffset + offset)\n\n            offset += 2\n\n            let faceIndices = new Int16Array(numIndices)\n            for (let i = 0; i <= numIndices; i++) {\n                faceIndices[i] = view.getInt16(chunkOffset + offset + (i * 2))\n            }\n\n            for (let i = 0; i < numIndices - 2; i++) {\n                if (this.COUNTER_CLOCKWISE) {\n                    this.indices[currentIndex++] = faceIndices[0]\n                    this.indices[currentIndex++] = faceIndices[i + 2]\n                    this.indices[currentIndex++] = faceIndices[i + 1]\n                } else {\n                    this.indices[currentIndex++] = faceIndices[0]\n                    this.indices[currentIndex++] = faceIndices[i + 1]\n                    this.indices[currentIndex++] = faceIndices[i + 2]\n                }\n            }\n\n            offset += 2 + (numIndices * 2)\n        }\n    }\n\n    parseSurface(view, buffer, chunkOffset, chunkSize) {\n        let offset = 0\n        while (view.getUint8(chunkOffset + offset) !== 0) offset++\n\n        let materialName = decodeString(new Uint8Array(buffer, chunkOffset, offset))\n        if (this.verbose) console.log('Parsing surface: ' + materialName)\n        let materialIndex = -1\n        let material: MeshPhongMaterial = null\n\n        let textureFlags = 0\n        let textureSize = new Vector3(0, 0, 0)\n        let textureCenter = new Vector3(0, 0, 0)\n        // let textureFalloff = new Vector3(0, 0, 0);\n        // let textureVelocity = new Vector3(0, 0, 0);\n\n        for (let i = 0; i < this.materials.length; i++) {\n            if (this.materials[i].name === materialName) {\n                materialIndex = i\n                material = this.materials[i]\n            }\n        }\n\n        if (!material) {\n            console.error('LWOLoader.parse: Surface in SURF chunk does not exist in SRFS')\n            return\n        }\n\n        material.shininess = 0\n\n        while (offset < chunkSize) {\n            const subchunkOffset = chunkOffset + offset\n            if (view.getUint8(subchunkOffset) === 0) {\n                offset++\n            } else {\n                const subchunkType = view.getInt32(subchunkOffset)\n                const subchunkSize = view.getInt16(subchunkOffset + ID4_SIZE)\n\n                if (this.verbose) console.log('Parsing subchunk ' + new TextDecoder().decode(new Uint8Array(buffer, subchunkOffset, ID4_SIZE)) + ' at ' + subchunkOffset + '; length ' + subchunkSize)\n\n                switch (subchunkType) {\n                    case SURF_COLR:\n                        const colorArray = [\n                            view.getUint8(subchunkOffset + SUBCHUNK_HEADER_SIZE + 0) / 255,\n                            view.getUint8(subchunkOffset + SUBCHUNK_HEADER_SIZE + 1) / 255,\n                            view.getUint8(subchunkOffset + SUBCHUNK_HEADER_SIZE + 2) / 255,\n                        ]\n                        material.color = new Color().fromArray(colorArray)\n                        if (this.verbose) console.log('Material color (COLR): ' + colorArray.join(' '))\n                        break\n                    case SURF_FLAG:\n                        const flags = view.getUint16(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        if (this.verbose) console.log('Flags (FLAG): ' + flags.toString(2))\n                        // if (this.verbose && flags & LUMINOUS_BIT) console.warn('Flag is set but unhandled: luminous') // flag replaced with LUMI below\n                        if (this.verbose && flags & OUTLINE_BIT) console.warn('Flag is set but unhandled: outline')\n                        if (this.verbose && flags & SMOOTHING_BIT) console.warn('Flag is set but unhandled: smoothing')\n                        if (this.verbose && flags & COLORHIGHLIGHTS_BIT) console.warn('Flag is set but unhandled: colorHighlights')\n                        if (this.verbose && flags & COLORFILTER_BIT) console.warn('Flag is set but unhandled: colorFilter')\n                        if (this.verbose && flags & OPAQUEEDGE_BIT) console.warn('Flag is set but unhandled: opaqueEdge')\n                        if (this.verbose && flags & TRANSPARENTEDGE_BIT) console.warn('Flag is set but unhandled: transparentEdge')\n                        if (this.verbose && flags & SHARPTERMINATOR_BIT) console.warn('Flag is set but unhandled: sharpTerminator')\n                        if (flags & DOUBLESIDED_BIT) material.side = DoubleSide\n                        if (flags & ADDITIVE_BIT) {\n                            material.blending = AdditiveBlending\n                            material.depthWrite = false // otherwise transparent parts \"carve out\" objects behind\n                        }\n                        if (this.verbose && flags & SHADOWALPHA_BIT) console.warn('Flag is set but unhandled: shadowAlpha')\n                        break\n                    case SURF_EDGE:\n                        const edgeTransparencyThreshold = view.getFloat32(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        if (this.verbose) console.warn('Edge transparency threshold (0.0 to 1.0): ' + edgeTransparencyThreshold)\n                        break\n                    case SURF_LUMI:\n                        const luminosity = view.getInt16(subchunkOffset + SUBCHUNK_HEADER_SIZE) / 256\n                        if (this.verbose) console.log('Luminosity (LUMI): ' + luminosity)\n                        material.emissiveIntensity = luminosity\n                        break\n                    case SURF_DIFF:\n                        const diffuse = view.getInt16(subchunkOffset + SUBCHUNK_HEADER_SIZE) / 256\n                        if (this.verbose) console.log('Diffuse (DIFF): ' + diffuse)\n                        if (!diffuse) material.color = null\n                        break\n                    case SURF_SPEC:\n                        const specular = view.getInt16(subchunkOffset + SUBCHUNK_HEADER_SIZE) / 256\n                        // material.specular = material.color.multiplyScalar(specular);\n                        if (this.verbose) console.warn('Specular (SPEC): ' + specular)\n                        break\n                    case SURF_REFL:\n                        let reflection = 0\n                        if (reflection === SURF_VRFL) {\n                            reflection = view.getFloat32(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        } else {\n                            reflection = view.getInt16(subchunkOffset + SUBCHUNK_HEADER_SIZE) / 256\n                        }\n                        material.reflectivity = reflection\n                        if (this.verbose) console.log('Reflectivity (REFL): ' + material.reflectivity)\n                        break\n                    case SURF_TRAN:\n                    case SURF_VTRN:\n                        let transparency = 0\n                        if (subchunkType === SURF_VTRN) {\n                            transparency = view.getFloat32(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        } else {\n                            transparency = view.getInt16(subchunkOffset + SUBCHUNK_HEADER_SIZE) / 256\n                        }\n                        material.opacity = 1 - transparency\n                        if (this.verbose) console.log('Opacity (TRAN/VTRN): ' + material.opacity)\n                        material.transparent = material.transparent || material.opacity < 1\n                        break\n                    case SURF_VLUM:\n                        const vLuminosity = view.getFloat32(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        if (this.verbose) console.log('Luminosity (VLUM): ' + vLuminosity)\n                        material.emissiveIntensity = vLuminosity\n                        break\n                    case SURF_VDIF:\n                        let vDiffuse = view.getFloat32(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        if (this.verbose) console.log('Diffuse (VDIF): ' + vDiffuse)\n                        // material.vertexColors = !!vDiffuse // XXX push vertex colors first\n                        break\n                    case SURF_VSPC:\n                        let vSpecular = view.getFloat32(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        // material.specular = material.color.multiplyScalar(vSpecular);\n                        if (this.verbose) console.warn('Specular (VSPC): ' + vSpecular)\n                        break\n                    case SURF_TFLG:\n                        textureFlags = view.getUint16(subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        if (this.verbose) console.log('Flags (TFLG): ' + textureFlags.toString(2))\n                        if (this.verbose && textureFlags & XAXIS_BIT) console.warn('Flag is set but unhandled: X Axis')\n                        if (this.verbose && textureFlags & YAXIS_BIT) console.warn('Flag is set but unhandled: Y Axis')\n                        if (this.verbose && textureFlags & ZAXIS_BIT) console.warn('Flag is set but unhandled: Z Axis')\n                        if (this.verbose && textureFlags & WORLDCOORDS_BIT) console.warn('Flag is set but unhandled: World Coords')\n                        if (this.verbose && textureFlags & NEGATIVEIMAGE_BIT) console.warn('Flag is set but unhandled: Negative Image')\n                        if (this.verbose && textureFlags & PIXELBLENDING_BIT) console.warn('Flag is set but unhandled: Pixel Blending')\n                        if (this.verbose && textureFlags & ANTIALIASING_BIT) console.log('Flag is set: Antialiasing') // turned on by default\n                        break\n                    case SURF_TSIZ:\n                        textureSize = getVector3AtOffset(view, subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        if (this.verbose) console.warn('Texture size (TSIZ): ' + textureSize.toArray().join(' '))\n                        break\n                    case SURF_TCTR:\n                        textureCenter = getVector3AtOffset(view, subchunkOffset + SUBCHUNK_HEADER_SIZE)\n                        if (this.verbose) console.warn('Texture center (TCTR): ' + textureCenter.toArray().join(' '))\n                        break\n                    case SURF_CTEX:\n                    case SURF_DTEX:\n                    case SURF_STEX:\n                    case SURF_RTEX:\n                    case SURF_TTEX:\n                    case SURF_BTEX:\n                        const textureTypeName = decodeFilepath(new Uint8Array(buffer, subchunkOffset + SUBCHUNK_HEADER_SIZE, subchunkSize))\n                        if (this.verbose) console.log('Texture typename: ' + textureTypeName)\n                        // XXX handle different texture types\n                        break\n                    case SURF_TVAL: // always 0 in the game\n                        const textureValue = view.getUint16(subchunkOffset + SUBCHUNK_HEADER_SIZE) / 256\n                        if (this.verbose) console.warn('Texture value (TVAL): ' + textureValue)\n                        break\n                    case SURF_TCLR:\n                        const textureColorArray = [\n                            view.getUint8(subchunkOffset + SUBCHUNK_HEADER_SIZE + 0) / 255,\n                            view.getUint8(subchunkOffset + SUBCHUNK_HEADER_SIZE + 1) / 255,\n                            view.getUint8(subchunkOffset + SUBCHUNK_HEADER_SIZE + 2) / 255,\n                            view.getUint8(subchunkOffset + SUBCHUNK_HEADER_SIZE + 3) / 255,\n                        ]\n                        // const textureColor = new Color().fromArray(textureColorArray);\n                        // seems to be 0 0 0 anyway...\n                        if (this.verbose) console.log('Texture color (TCLR): ' + textureColorArray.join(' '))\n                        break\n                    case SURF_TIMG:\n                        let textureFilepath = decodeFilepath(new Uint8Array(buffer, subchunkOffset + SUBCHUNK_HEADER_SIZE, subchunkSize))\n                        if (this.verbose) console.log('Texture filepath (TIMG): ' + textureFilepath)\n                        if (textureFilepath === '(none)') break\n                        let sequenceTexture = false\n                        if (textureFilepath.endsWith(' (sequence)')) {\n                            sequenceTexture = true\n                            textureFilepath = textureFilepath.substring(0, textureFilepath.length - ' (sequence)'.length)\n                        }\n                        let filename = getFilename(textureFilepath)\n                        material.transparent = material.transparent || !!filename.match(/^a\\d+.+.bmp/i)\n                        const textureFilename = this.path + filename\n                        if (sequenceTexture) {\n                            const match = textureFilename.match(/(.+\\D)0+(\\d+)\\..+/)\n                            const textures = ResourceManager.filterTextureSequenceNames(match[1])\n                                .map((name) => ResourceManager.getTexture(name))\n                            if (textures) {\n                                let seqNum = 0\n                                material.color = null // no need for color, when color map (texture) in use\n                                this.sequenceIntervals.push(setInterval(() => {\n                                    material.map = textures[seqNum++]\n                                    if (seqNum >= textures.length) seqNum = 0\n                                }, 1000 / SEQUENCE_TEXTURE_FRAMERATE))\n                            }\n                        }\n                        const lTextureName = textureFilename.toLowerCase()\n                        if (lTextureName === 'miscanims/barrier/a_side.bmp' // workaround (TODO actually never add unknown textures?)\n                            || lTextureName === 'miscanims/barrier/a_top.bmp'\n                            || lTextureName === 'world/shared/teofoilreflections.jpg'\n                            || lTextureName === 'buildings/barracks/wingbase3.bmp') {\n                            break\n                        }\n                        material.map = ResourceManager.getTexture(textureFilename)\n                        material.color = null // no need for color, when color map (texture) in use\n                        break\n                    default: // TODO implement all LWO features\n                        if (this.verbose) console.warn('Found unrecognised SURF subchunk type ' + new TextDecoder().decode(new Uint8Array(buffer, subchunkOffset, ID4_SIZE)) + ' at ' + subchunkOffset + '; length ' + subchunkSize)\n                        break\n                }\n\n                offset += SUBCHUNK_HEADER_SIZE + subchunkSize\n            }\n        }\n\n        planarMapUVS(this.geometry, this.vertices, this.uvs, this.indices, materialIndex, textureSize, textureCenter, textureFlags)\n    }\n\n    parse(buffer: ArrayBuffer): AnimatedMesh {\n        const view = new DataView(buffer)\n\n        if (view.getUint32(0) !== LWO_FORM) {\n            console.error('LWOLoader.parse: Cannot find header.')\n            return\n        }\n\n        const fileSize = view.getUint32(ID4_SIZE)\n        if (fileSize + CHUNK_HEADER_SIZE !== view.byteLength) {\n            console.warn('LWOLoader.parse: Discrepancy between size in header (' + (fileSize + CHUNK_HEADER_SIZE) + ' bytes) and actual size (' + view.byteLength + ' bytes).')\n        }\n\n        let magicOffset = ID4_SIZE + I4_SIZE\n        if (view.getUint32(magicOffset) !== LWO_MAGIC) {\n            const magic = decodeString(new Uint8Array(buffer, magicOffset, ID4_SIZE))\n            console.error('LWOLoader.parse: Invalid magic ID (' + magic + ') in LWO header.')\n            return\n        }\n\n        let cursor = 12\n        while (cursor < view.byteLength) {\n            // Skip null byte padding\n            if (view.getUint8(cursor) === 0) {\n                cursor++\n            } else {\n                const chunkType = view.getInt32(cursor)\n                const chunkSize = view.getInt32(cursor + ID4_SIZE)\n\n                cursor += CHUNK_HEADER_SIZE\n\n                switch (chunkType) {\n                    case LWO_PNTS:\n                        this.parsePoints(view, cursor, chunkSize)\n                        break\n                    case LWO_SFRS:\n                        this.parseSurfaceNames(buffer, cursor, chunkSize)\n                        break\n                    case LWO_POLS:\n                        this.parsePolygons(view, cursor, chunkSize)\n                        break\n                    case LWO_SURF:\n                        this.parseSurface(view, buffer, cursor, chunkSize)\n                        break\n                    default:\n                        console.warn('Found unrecognised chunk type ' + decodeString(new Uint8Array(buffer, cursor - CHUNK_HEADER_SIZE, ID4_SIZE)) + ' at ' + cursor)\n                }\n\n                cursor += chunkSize\n            }\n\n        }\n\n        this.geometry.setAttribute('position', new BufferAttribute(this.vertices, 3))\n        this.geometry.setAttribute('uv', new BufferAttribute(this.uvs, 2))\n        this.geometry.setIndex(new BufferAttribute(this.indices, 1))\n        this.geometry.computeVertexNormals()\n\n        return new AnimatedMesh(new Mesh(this.geometry, this.materials), this.sequenceIntervals)\n    }\n}\n","/**\n * @author Scarabol https://github.com/scarabol\n *\n * This loader loads LWSC files exported from LW\n *\n * File format description: http://www.martinreddy.net/gfx/3d/LWSC.txt\n */\n\nimport { Group, Vector3 } from 'three'\nimport { getFilename } from '../core/Util'\nimport { AnimClip } from '../game/model/anim/AnimClip'\nimport { AnimSubObj } from '../game/model/anim/AnimSubObj'\nimport { SceneManager } from '../game/SceneManager'\nimport { LWOLoader } from './LWOLoader'\nimport { ResourceManager } from './ResourceManager'\n\nexport class LWSCLoader {\n\n    path: string = ''\n    verbose: boolean = false\n    animationClip: AnimClip = new AnimClip()\n    lines: string[] = []\n    lineIndex: number = 0\n\n    constructor(path: string, verbose: boolean = false) {\n        this.path = path\n        this.verbose = verbose\n        if (this.verbose) console.log('Using verbose mode')\n    }\n\n    parse(content): AnimClip {\n        this.lines = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n') // normalize newlines\n            .replace(/\\t/g, ' ') // tabs to spaces\n            .split('\\n')\n            .map(l => l.trim())\n\n        if (this.lines[0] !== 'LWSC') {\n            throw 'Invalid start of file! Expected \\'LWSC\\' in first line'\n        }\n\n        const sceneFileVersion = parseInt(this.lines[1], 10)\n        if (sceneFileVersion !== 1) {\n            console.warn('Unexpected scene file version: ' + sceneFileVersion)\n        }\n\n        for (this.lineIndex = 2; this.lineIndex < this.lines.length; this.lineIndex++) {\n            let line = this.lines[this.lineIndex]\n            if (!line) continue // empty line: object separator\n            const key = line.split(' ')[0]\n            if (key === 'FirstFrame') {\n                this.parseFrameBlock()\n            } else if (key === 'AddNullObject' || key === 'LoadObject') {\n                this.parseObjectBlock()\n                if (this.verbose) console.log(this.animationClip.bodies[this.animationClip.bodies.length - 1])\n            } else if (line.startsWith('PreviewFirstFrame ') || line.startsWith('PreviewLastFrame ') || line.startsWith('PreviewFrameStep ')) {\n                // only used in editor\n            } else {\n                // console.warn('Unexpected line: ' + line); // TODO analyze remaining entries\n            }\n        }\n\n        if (this.verbose) console.log(this.animationClip)\n        return this.animationClip\n    }\n\n    parseLine(line: string): string[] {\n        const lineParts = line.split(' ').filter((l: string) => l !== '')\n        const key = lineParts.shift()\n        const value = lineParts.join(' ')\n        return [key, value]\n    }\n\n    parseFrameBlock() {\n        for (; this.lineIndex < this.lines.length; this.lineIndex++) {\n            const line = this.lines[this.lineIndex]\n            if (!line) return\n            const [key, value] = this.parseLine(line)\n            if (key === 'FirstFrame') {\n                this.animationClip.firstFrame = parseInt(value)\n            } else if (key === 'LastFrame') {\n                this.animationClip.lastFrame = parseInt(value)\n            } else if (key === 'FrameStep') {\n                const frameStep = parseInt(value)\n                if (frameStep !== 1) console.error('Animation frameStep has unexpected value: ' + frameStep)\n            } else if (key === 'FramesPerSecond') {\n                this.animationClip.framesPerSecond = parseInt(value)\n            } else if (key === 'PreviewFirstFrame' || key === 'PreviewLastFrame' || key === 'PreviewFrameStep') {\n                // only used in editor\n            } else {\n                console.warn('Unexpected key in frame block')\n            }\n        }\n        console.error('Parsing block reached content end')\n    }\n\n    parseObjectBlock(): AnimSubObj {\n        const subObj = new AnimSubObj()\n        this.animationClip.bodies.push(subObj)\n        for (; this.lineIndex < this.lines.length; this.lineIndex++) {\n            let line = this.lines[this.lineIndex]\n            if (!line) return\n            const [key, value] = this.parseLine(line)\n            if (key === 'AddNullObject' || key === 'LoadObject') {\n                if (key === 'LoadObject') {\n                    const filename = getFilename(value)\n                    subObj.name = filename.slice(0, filename.length - '.lwo'.length)\n                    subObj.filename = this.path + filename\n                    const lwoBuffer = ResourceManager.getResource(subObj.filename)\n                    subObj.model = SceneManager.registerMesh(new LWOLoader(this.path).parse(lwoBuffer))\n                } else if (key === 'AddNullObject') {\n                    subObj.name = value\n                    subObj.model = new Group()\n                } else {\n                    throw 'Unexpected line: ' + line\n                }\n            } else if (key === 'ObjectMotion') {\n                let line = this.lines[++this.lineIndex]\n                const lenInfos = parseInt(line)\n                line = this.lines[++this.lineIndex]\n                const lenFrames = parseInt(line)\n                this.lineIndex++\n                for (let c = 0; c < lenFrames; c++) {\n                    let line = this.lines[this.lineIndex + c * 2]\n                    if (line.startsWith('EndBehavior')) break\n                    const infos = line.split(' ').map(Number)\n                    if (infos.length !== lenInfos) console.warn('Number of infos (' + infos.length + ') does not match if specified count (' + lenInfos + ')')\n                    line = this.lines[this.lineIndex + c * 2 + 1]\n                    const animationFrameIndex = parseInt(line.split(' ')[0]) // other entries in line should be zeros\n                    subObj.setFrameAndFollowing(animationFrameIndex, this.animationClip.lastFrame, infos)\n                }\n                this.lineIndex += lenFrames * 2\n            } else if (key === 'ParentObject') {\n                subObj.parentObjInd = Number(value) - 1 // index is 1 based\n                if (this.verbose) console.log('parent obj ind is: ' + subObj.parentObjInd)\n            } else if (key === 'ShowObject' || key === 'LockedChannels') {\n                // only used in editor\n            } else if (key === 'ShadowOptions') { // TODO implement shadow options (bitwise)\n                // 0 - Self Shadow\n                // 1 - Cast Shadow\n                // 2 - Receive Shadow\n            } else if (key === 'ObjDissolve') {\n                if (value == '(envelope)') {\n                    let line = this.lines[++this.lineIndex]\n                    const numOfInformationChannels = parseInt(line)\n                    if (numOfInformationChannels !== 1) console.error('Number of information channels for opacity is not 1, but: ' + numOfInformationChannels)\n                    line = this.lines[++this.lineIndex]\n                    const numOfKeyframes = parseInt(line)\n                    this.lineIndex++\n                    for (let c = 0; c < numOfKeyframes; c++) {\n                        let line = this.lines[this.lineIndex + c * 2]\n                        if (line.startsWith('EndBehavior')) break\n                        const opacity = 1 - Number(line)\n                        line = this.lines[this.lineIndex + c * 2 + 1]\n                        const frameNum = Number(line.split(' ')[0])\n                        subObj.setOpacityAndFollowing(frameNum, this.animationClip.lastFrame, opacity)\n                    }\n                    this.lineIndex += numOfKeyframes * 2\n                } else {\n                    const opacity = 1 - Number(value)\n                    subObj.setOpacityAndFollowing(0, this.animationClip.lastFrame, opacity)\n                }\n            } else if (key === 'PivotPoint') {\n                subObj.pivot = new Vector3().fromArray(value.split(' ').map((n) => Number(n)))\n            } else if (this.verbose) {\n                console.warn('Unhandled line in object block: ' + line + '; key: ' + key + '; value: ' + value) // TODO analyze unhandled lines\n            }\n        }\n        console.error('Parsing block reached content end')\n        return subObj\n    }\n\n}\n","import { Box3, CanvasTexture, Matrix4, Mesh, MeshBasicMaterial, MeshPhongMaterial, Object3D, PositionalAudio, Sphere, SphereGeometry, Sprite, SpriteMaterial, Vector3 } from 'three'\nimport { Sample } from '../../../audio/Sample'\nimport { SoundManager } from '../../../audio/SoundManager'\nimport { createContext } from '../../../core/ImageHelper'\nimport { clearTimeoutSafe, iGet } from '../../../core/Util'\nimport { EventBus } from '../../../event/EventBus'\nimport { SelectionChanged } from '../../../event/LocalEvents'\nimport { NATIVE_FRAMERATE, TILESIZE } from '../../../params'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { AnimEntityActivity } from '../activities/AnimEntityActivity'\nimport { BaseActivity } from '../activities/BaseActivity'\nimport { BaseEntity } from '../BaseEntity'\nimport { EntitySuperType, EntityType } from '../EntityType'\nimport { AnimationEntityType } from './AnimationEntityType'\nimport { AnimClip } from './AnimClip'\nimport { AnimSubObj } from './AnimSubObj'\n\nexport abstract class AnimEntity extends BaseEntity {\n\n    animationEntityType: AnimationEntityType = null\n    poly: Object3D[] = []\n    animation: AnimClip = null\n    animationTimeout: NodeJS.Timeout = null\n    selectionFrame: Sprite = null\n    pickSphere: Mesh = null\n    carryJoint: Object3D = null\n    depositJoint: Object3D = null\n    getToolJoint: Object3D = null\n    activity: BaseActivity = null\n    radiusSq: number = 0\n\n    protected constructor(worldMgr: WorldManager, sceneMgr: SceneManager, superType: EntitySuperType, entityType: EntityType, aeFilename: string) {\n        super(worldMgr, sceneMgr, superType, entityType)\n        if (aeFilename) this.animationEntityType = ResourceManager.getAnimationEntityType(aeFilename)\n    }\n\n    beamUp() {\n        // TODO avoid all further state changes and mark as unavailable here\n        // TODO publish event: check jobs with this target, update power state...\n        EventBus.publishEvent(new SelectionChanged())\n        this.changeActivity()\n        // TODO insert beam animation\n        AnimEntity.moveUp(this, 6 * TILESIZE)\n        this.playPositionalSample(Sample.SND_TeleUp)\n    }\n\n    private static moveUp(entity: AnimEntity, counter: number) {\n        if (counter > 0) {\n            counter--\n            entity.group.position.y += (TILESIZE / NATIVE_FRAMERATE) / 2\n            setTimeout(() => AnimEntity.moveUp(entity, counter), 1000 / NATIVE_FRAMERATE)\n        } else {\n            entity.removeFromScene()\n        }\n    }\n\n    changeActivity(activity: AnimEntityActivity = this.getDefaultActivity(), onAnimationDone: () => any = null, durationTimeMs: number = null) {\n        if (this.activity === activity || this.animationEntityType === null) return\n        this.activity = activity\n        let lActivityKey = activity.activityKey.toLowerCase()\n        let anim = this.animationEntityType.activities.get(lActivityKey)\n        if (!anim) { // find by prefix\n            this.animationEntityType.activities.forEach((a, key) => {\n                if (!anim && lActivityKey.startsWith(key)) anim = a\n            })\n        }\n        if (!anim?.animation) {\n            console.warn('Activity ' + activity.activityKey + ' unknown or has no animation defined')\n            console.log(this.animationEntityType.activities)\n            return\n        }\n        if (onAnimationDone) onAnimationDone.bind(this)\n        this.animation = anim.animation\n        this.animation.looping = true\n        this.animationTimeout = clearTimeoutSafe(this.animationTimeout)\n        this.group.remove(...this.poly)\n        this.poly = []\n        const carries = (this.carryJoint && this.carryJoint.children) || []\n        this.carryJoint = null\n        // bodies are defined in animation and second in high/medium/low poly groups\n        this.animation.bodies.forEach((body) => {\n            let model: Object3D = iGet(this.animationEntityType.highPoly, body.name)\n            if (!model) model = iGet(this.animationEntityType.mediumPoly, body.name)\n            if (!model) model = body.model\n            const polyModel = model.clone(true)\n            this.poly.push(polyModel)\n            if (body.name) {\n                if (body.name.equalsIgnoreCase(this.animationEntityType.carryNullName)) {\n                    this.carryJoint = polyModel\n                    if (carries.length > 0) this.carryJoint.add(...carries)\n                } else if (body.name.equalsIgnoreCase(this.animationEntityType.depositNullName)) {\n                    this.depositJoint = polyModel\n                } else if (body.name.equalsIgnoreCase(this.animationEntityType.toolNullName)) {\n                    this.getToolJoint = polyModel\n                }\n            }\n        })\n        this.animation.bodies.forEach((body, index) => { // not all bodies may have been added in first iteration\n            const polyPart = this.poly[index]\n            const parentInd = body.parentObjInd\n            if (parentInd !== undefined && parentInd !== null) { // can be 0\n                this.poly[parentInd].add(polyPart)\n            } else {\n                this.group.add(polyPart)\n            }\n        })\n        const sphere = new Sphere()\n        new Box3().setFromObject(this.group).getBoundingSphere(sphere)\n        this.radiusSq = sphere.radius * sphere.radius\n        this.animate(0, onAnimationDone, durationTimeMs)\n    }\n\n    private animate(frameIndex: number, onAnimationDone: () => any, durationTimeMs: number) {\n        if (this.poly.length !== this.animation.bodies.length) throw 'Cannot animate poly. Length differs from bodies length'\n        this.animation.bodies.forEach((body: AnimSubObj, index) => {\n            const p = this.poly[index]\n            p.position.copy(body.relPos[frameIndex]).sub(body.pivot)\n            p.rotation.copy(body.relRot[frameIndex])\n            p.scale.copy(body.relScale[frameIndex])\n            if (p.hasOwnProperty('material')) {\n                const material = p['material']\n                const opacity = body.opacity[frameIndex]\n                if (material && opacity !== undefined) {\n                    const matArr = Array.isArray(material) ? material : [material]\n                    matArr.forEach((mat: MeshPhongMaterial) => {\n                        mat.opacity = opacity\n                        mat.transparent = mat.transparent || mat.opacity < 1\n                    })\n                }\n            }\n        })\n        this.animationTimeout = clearTimeoutSafe(this.animationTimeout)\n        let nextFrame = frameIndex + 1\n        if (nextFrame <= this.animation.lastFrame || !onAnimationDone || (durationTimeMs !== null && durationTimeMs > 0)) {\n            if (nextFrame > this.animation.lastFrame) {\n                nextFrame = this.animation.firstFrame\n            }\n            const standardDurationTimeMs = 1000 / this.animation.framesPerSecond * this.animation.transcoef\n            if (durationTimeMs !== null) durationTimeMs -= standardDurationTimeMs\n            const that = this\n            const timeoutTimeMs = durationTimeMs !== null ? Math.max(0, Math.min(durationTimeMs, standardDurationTimeMs)) : standardDurationTimeMs\n            this.animationTimeout = setTimeout(() => that.animate(nextFrame, onAnimationDone, durationTimeMs), timeoutTimeMs) // TODO get this in sync with threejs\n        } else if (onAnimationDone) {\n            onAnimationDone()\n        }\n    }\n\n    getDefaultActivity(): AnimEntityActivity {\n        return AnimEntityActivity.Stand\n    }\n\n    createPickSphere() {\n        if (this.pickSphere) return\n        const pickSphereDiameter = this.stats.PickSphere\n        const pickSphereRadius = pickSphereDiameter / 2\n        const geometry = new SphereGeometry(pickSphereRadius, pickSphereRadius, pickSphereRadius)\n        const material = new MeshBasicMaterial({color: 0xffff00, visible: false}) // change visible to true for debugging\n        this.pickSphere = new Mesh(geometry, material)\n        this.pickSphere.userData = {selectable: this}\n        const pickSphereCenter = this.getPickSphereCenter()\n        this.pickSphere.position.copy(pickSphereCenter)\n        this.group.add(this.pickSphere)\n        this.createSelectionFrame(pickSphereDiameter, pickSphereCenter)\n    }\n\n    getPickSphereCenter(): Vector3 {\n        return this.getBoundingBoxCenter()\n    }\n\n    getBoundingBoxCenter() {\n        const center = new Vector3()\n        new Box3().setFromObject(this.group).getCenter(center)\n        center.sub(this.group.position)\n        center.applyMatrix4(new Matrix4().makeScale(-1, 1, 1))\n        return center\n    }\n\n    private createSelectionFrame(pickSphereDiameter: number, pickSphereCenter: Vector3) {\n        const selectionFrameTextureSize = 128\n        const ctx = createContext(selectionFrameTextureSize, selectionFrameTextureSize)\n        ctx.fillStyle = '#0f0'\n        const strength = Math.round(50 / pickSphereDiameter)\n        const length = selectionFrameTextureSize / 6\n        ctx.fillRect(0, 0, length, strength)\n        ctx.fillRect(0, 0, strength, length)\n        ctx.fillRect(selectionFrameTextureSize - length, 0, length, strength)\n        ctx.fillRect(selectionFrameTextureSize - strength, 0, strength, length)\n        ctx.fillRect(selectionFrameTextureSize - strength, selectionFrameTextureSize - length, strength, length)\n        ctx.fillRect(selectionFrameTextureSize - length, selectionFrameTextureSize - strength, length, strength)\n        ctx.fillRect(0, selectionFrameTextureSize - strength, length, strength)\n        ctx.fillRect(0, selectionFrameTextureSize - length, strength, length)\n        const selectionFrameTexture = new CanvasTexture(ctx.canvas as HTMLCanvasElement)\n        const selectionMaterial = new SpriteMaterial({map: selectionFrameTexture, depthTest: false})\n        this.selectionFrame = new Sprite(selectionMaterial)\n        this.selectionFrame.position.copy(pickSphereCenter)\n        const selectionFrameSize = pickSphereDiameter\n        this.selectionFrame.scale.set(selectionFrameSize, selectionFrameSize, selectionFrameSize)\n        this.selectionFrame.visible = false\n        this.group.add(this.selectionFrame)\n    }\n\n    playPositionalSample(sample: Sample, loop: boolean = false): PositionalAudio { // TODO duplicate code (see below)\n        const audio = new PositionalAudio(this.sceneMgr.listener)\n        audio.setRefDistance(TILESIZE * 2)\n        audio.loop = loop // TODO retry playing sound for looped ones, when audio context fails\n        this.group.add(audio)\n        SoundManager.getSampleBuffer(sample).then((audioBuffer) => {\n            audio.setBuffer(audioBuffer).play()\n            // TODO if (!loop) remove audio node from group, when done\n        })\n        return audio\n    }\n\n    playPositionalSfxName(sfxName: string, loop: boolean = false): PositionalAudio { // TODO duplicate code (see above)\n        const audio = new PositionalAudio(this.sceneMgr.listener)\n        audio.setRefDistance(TILESIZE * 2)\n        audio.loop = loop // TODO retry playing sound for looped ones, when audio context fails\n        this.group.add(audio)\n        SoundManager.getSound(sfxName).then((audioBuffer) => {\n            audio.setBuffer(audioBuffer).play()\n            // TODO if (!loop) remove audio node from group, when done\n        })\n        return audio\n    }\n\n    removeFromScene() {\n        super.removeFromScene()\n        this.animationTimeout = clearTimeoutSafe(this.animationTimeout)\n    }\n\n}\n","import { Group, Vector2, Vector3 } from 'three'\nimport { SceneManager } from '../SceneManager'\nimport { WorldManager } from '../WorldManager'\nimport { EntitySuperType, EntityType } from './EntityType'\nimport { Surface } from './map/Surface'\n\nexport abstract class BaseEntity {\n\n    worldMgr: WorldManager\n    sceneMgr: SceneManager\n\n    group: Group = new Group()\n\n    superType: EntitySuperType = null\n    entityType: EntityType = null\n    level: number = 0\n    floorOffset: number = 0\n\n    protected constructor(worldMgr: WorldManager, sceneMgr: SceneManager, superType: EntitySuperType, entityType: EntityType) {\n        this.worldMgr = worldMgr\n        this.sceneMgr = sceneMgr\n        this.superType = superType\n        this.entityType = entityType\n    }\n\n    get stats() {\n        return null\n    }\n\n    getPosition() {\n        return this.group.position.clone()\n    }\n\n    getPosition2D() {\n        return new Vector2(this.group.position.x, this.group.position.z)\n    }\n\n    getHeading(): number {\n        return this.group.rotation.y\n    }\n\n    onDiscover() {\n        this.group.visible = true\n    }\n\n    addToScene(worldPosition: Vector2, radHeading: number) {\n        if (worldPosition) {\n            this.group.position.copy(this.sceneMgr.getFloorPosition(worldPosition))\n            this.group.position.y += this.floorOffset\n        }\n        if (radHeading !== undefined && radHeading !== null) {\n            this.group.rotateOnAxis(new Vector3(0, 1, 0), radHeading)\n        }\n        this.group.visible = this.surfaces.some((s) => s.discovered)\n        this.sceneMgr.scene.add(this.group)\n    }\n\n    removeFromScene() {\n        this.sceneMgr.scene.remove(this.group)\n    }\n\n    get surfaces(): Surface[] {\n        return [this.sceneMgr.terrain.getSurfaceFromWorld(this.group.position)]\n    }\n\n}\n","import { Vector3 } from 'three'\nimport { RaiderActivity } from '../activities/RaiderActivity'\nimport { CarryPathTarget, SiteCarryPathTarget } from '../collect/CarryPathTarget'\nimport { MaterialEntity } from '../collect/MaterialEntity'\nimport { PublicJob } from './Job'\nimport { JobType } from './JobType'\nimport { PriorityIdentifier } from './PriorityIdentifier'\n\nexport class CarryJob<I extends MaterialEntity> extends PublicJob {\n\n    item: I\n    actualTarget: CarryPathTarget = null\n\n    constructor(item: I) {\n        super(JobType.CARRY)\n        this.item = item\n    }\n\n    getWorkplaces(): CarryPathTarget[] {\n        return this.item.getCarryTargets()\n    }\n\n    getPriorityIdentifier(): PriorityIdentifier {\n        return this.item.getPriorityIdentifier()\n    }\n\n    setActualWorkplace(target: CarryPathTarget) {\n        this.item.setTargetSite((target as SiteCarryPathTarget)?.site)\n        this.actualTarget = target\n    }\n\n    getCarryItem(): I {\n        return this.item\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return this.actualTarget.getDropAction()\n    }\n\n    isReadyToComplete(): boolean {\n        return this.actualTarget.canGatherItem()\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        const targetLocation = this.actualTarget.targetLocation\n        this.fulfiller.forEach((f) => {\n            f.group.lookAt(new Vector3(targetLocation.x, f.group.position.y, targetLocation.y))\n            f.dropItem()\n            this.item.group.position.copy(this.item.sceneMgr.getFloorPosition(targetLocation))\n        })\n        this.actualTarget.gatherItem(this.item)\n    }\n\n}\n","import { AnimEntityActivity } from './AnimEntityActivity'\n\nexport class BuildingActivity extends AnimEntityActivity {\n\n    static Teleport = new BuildingActivity('Activity_Teleport')\n    static Deposit = new BuildingActivity('Activity_Deposit')\n    static Explode = new BuildingActivity('Activity_Explode')\n    static Unpowered = new BuildingActivity('Activity_Unpowered')\n\n}\n","import { Vector2 } from 'three'\nimport { EventBus } from '../../../event/EventBus'\nimport { MaterialAmountChanged } from '../../../event/WorldEvents'\nimport { BuildingActivity } from '../activities/BuildingActivity'\nimport { RaiderActivity } from '../activities/RaiderActivity'\nimport { BuildingEntity } from '../building/BuildingEntity'\nimport { BuildingSite } from '../building/BuildingSite'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { PathTarget } from '../PathTarget'\nimport { MaterialEntity } from './MaterialEntity'\n\nexport class CarryPathTarget extends PathTarget {\n\n    constructor(location: Vector2) {\n        super(location)\n    }\n\n    canGatherItem(): boolean {\n        return true\n    }\n\n    gatherItem(item: MaterialEntity) {\n        item.addToScene(null, null)\n    }\n\n    getDropAction(): RaiderActivity {\n        return RaiderActivity.Place\n    }\n\n    isInvalid(): boolean {\n        return false\n    }\n\n}\n\nexport class SiteCarryPathTarget extends CarryPathTarget {\n\n    site: BuildingSite\n\n    constructor(location: Vector2, site: BuildingSite) {\n        super(location)\n        this.site = site\n    }\n\n    gatherItem(item: MaterialEntity) {\n        this.site.addItem(item)\n    }\n\n    getDropAction(): RaiderActivity {\n        return this.site.getDropAction()\n    }\n\n    isInvalid(): boolean {\n        return this.site.complete || this.site.canceled\n    }\n\n}\n\nexport class BuildingCarryPathTarget extends CarryPathTarget {\n\n    building: BuildingEntity\n\n    constructor(building: BuildingEntity) {\n        super(building.getDropPosition2D())\n        this.building = building\n    }\n\n    canGatherItem(): boolean {\n        return this.building.activity.activityKey === this.building.getDefaultActivity().activityKey\n    }\n\n    gatherItem(item: MaterialEntity) {\n        if (this.building.entityType === EntityType.POWER_STATION || this.building.entityType === EntityType.ORE_REFINERY) {\n            if (this.building.carryJoint) {\n                this.building.carryJoint.add(item.group)\n                item.group.position.set(0, 0, 0)\n            }\n            this.building.changeActivity(BuildingActivity.Deposit, () => {\n                this.building.changeActivity()\n                if (this.building.carryJoint) this.building.carryJoint.remove(item.group)\n                BuildingCarryPathTarget.addItemToStorage(item)\n                // TODO dispose item\n            })\n        } else {\n            item.removeFromScene()\n            BuildingCarryPathTarget.addItemToStorage(item)\n        }\n    }\n\n    private static addItemToStorage(item: MaterialEntity) {\n        switch (item.entityType) {\n            case EntityType.CRYSTAL:\n                GameState.numCrystal++\n                break\n            case EntityType.ORE:\n                GameState.numOre++\n                break\n        }\n        EventBus.publishEvent(new MaterialAmountChanged())\n    }\n\n    getDropAction(): RaiderActivity {\n        return this.building.getDropAction()\n    }\n\n    isInvalid(): boolean {\n        return !this.building.isUsable()\n    }\n\n}\n","import { EventBus } from '../../../event/EventBus'\nimport { JobCreateEvent } from '../../../event/WorldEvents'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { AnimEntity } from '../anim/AnimEntity'\nimport { BuildingSite } from '../building/BuildingSite'\nimport { EntitySuperType, EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { CarryJob } from '../job/CarryJob'\nimport { PriorityIdentifier } from '../job/PriorityIdentifier'\nimport { PathTarget } from '../PathTarget'\nimport { BuildingCarryPathTarget, CarryPathTarget, SiteCarryPathTarget } from './CarryPathTarget'\n\nexport abstract class MaterialEntity extends AnimEntity {\n\n    targetBuildingTypes: EntityType[] = []\n    priorityIdentifier: PriorityIdentifier = null\n    targets: CarryPathTarget[] = []\n    targetSite: BuildingSite = null\n    positionPathTarget: PathTarget[] = null\n\n    protected constructor(worldMgr: WorldManager, sceneMgr: SceneManager, entityType: EntityType, aeFilename: string = null) {\n        super(worldMgr, sceneMgr, EntitySuperType.MATERIAL, entityType, aeFilename)\n        this.targetBuildingTypes = [EntityType.TOOLSTATION]\n    }\n\n    getCarryTargets(): CarryPathTarget[] {\n        return this.updateTargets()\n    }\n\n    resetTarget() {\n        this.targets = []\n        this.targetSite = null\n        this.updateTargets()\n    }\n\n    protected updateTargets(): CarryPathTarget[] {\n        if (this.targets.length < 1) {\n            const sites = GameState.buildingSites.filter((b) => b.needs(this.entityType))\n            if (sites.length > 0) {\n                this.targets = sites.map((s) => new SiteCarryPathTarget(s.getRandomDropPosition(), s))\n            } else {\n                const buildings = GameState.getBuildingsByType(...this.getTargetBuildingTypes())\n                if (buildings.length > 0) {\n                    this.targets = buildings.map((b) => new BuildingCarryPathTarget(b))\n                }\n            }\n        } else if (this.targets.some((t) => t.isInvalid())) {\n            this.resetTarget()\n        }\n        return this.targets\n    }\n\n    onDiscover() {\n        super.onDiscover()\n        GameState.materialsUndiscovered.remove(this)\n        GameState.materials.push(this)\n        EventBus.publishEvent(new JobCreateEvent(this.createCarryJob()))\n    }\n\n    setTargetSite(site: BuildingSite) {\n        if (this.targetSite === site) return\n        this.targetSite?.unAssign(this)\n        this.targetSite = site\n        this.targetSite?.assign(this)\n    }\n\n    getPriorityIdentifier(): PriorityIdentifier {\n        return this.priorityIdentifier\n    }\n\n    getTargetBuildingTypes(): EntityType[] {\n        return this.targetBuildingTypes\n    }\n\n    createCarryJob(): CarryJob<MaterialEntity> {\n        return new CarryJob(this)\n    }\n\n    onAddToSite() {\n        this.addToScene(null, null)\n    }\n\n    getPositionPathTarget(): PathTarget[] {\n        const position = this.getPosition2D()\n        if (!this.positionPathTarget || !this.positionPathTarget[0].targetLocation.equals(position)) {\n            this.positionPathTarget = [new PathTarget(position)]\n        }\n        return this.positionPathTarget\n    }\n\n}\n","import { AdditiveBlending, Color, Material, MeshPhongMaterial } from 'three'\nimport { LWOLoader } from '../../../resource/LWOLoader'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { EntityType } from '../EntityType'\nimport { PriorityIdentifier } from '../job/PriorityIdentifier'\nimport { MaterialEntity } from './MaterialEntity'\n\nexport class Crystal extends MaterialEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.CRYSTAL)\n        const resource2 = ResourceManager.getResource('MiscAnims/Crystal/vlp_greencrystal.lwo')\n        const mesh2 = SceneManager.registerMesh(new LWOLoader('MiscAnims/Crystal/').parse(resource2));\n        (mesh2.material as Material[]).forEach((mat: MeshPhongMaterial) => {\n            mat.blending = AdditiveBlending\n            mat.depthWrite = false // otherwise transparent parts \"carve out\" objects behind\n            mat.opacity = 0.5 // XXX read from LWO file?\n            mat.transparent = mat.opacity < 1\n        })\n        mesh2.scale.set(1.75, 1.75, 1.75) // XXX derive from texture scale?\n        this.group.add(mesh2)\n        const resource = ResourceManager.getResource('World/Shared/Crystal.lwo') // high poly version\n        const mesh = SceneManager.registerMesh(new LWOLoader('World/Shared/').parse(resource));\n        (mesh.material as Material[]).forEach((mat: MeshPhongMaterial) => {\n            mat.emissive = new Color(0, 8, 0) // XXX read from LWO file?\n            mat.color = new Color(0, 0, 0) // XXX read from LWO file?\n            mat.opacity = 0.9 // XXX read from LWO file?\n            mat.transparent = mat.opacity < 1\n        })\n        this.group.add(mesh)\n        this.targetBuildingTypes = [EntityType.POWER_STATION, EntityType.TOOLSTATION]\n        this.priorityIdentifier = PriorityIdentifier.aiPriorityCrystal\n    }\n\n    get stats() {\n        return ResourceManager.stats.PowerCrystal\n    }\n\n}\n","import { BaseActivity } from './BaseActivity'\n\nexport class DynamiteActivity extends BaseActivity {\n\n    static Normal = new DynamiteActivity('Normal')\n    static TickDown = new DynamiteActivity('TickDown')\n\n}\n","import { Dynamite } from '../../collect/Dynamite'\nimport { RaiderTraining } from '../../raider/RaiderTraining'\nimport { CarryJob } from '../CarryJob'\n\nexport class CarryDynamiteJob extends CarryJob<Dynamite> {\n\n    color: number = 0xa06060\n\n    constructor(dynamite: Dynamite) {\n        super(dynamite)\n    }\n\n    getRequiredTraining(): RaiderTraining {\n        return RaiderTraining.DEMOLITION\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        this.item.ignite()\n    }\n\n}\n","import { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { AnimEntityActivity } from '../activities/AnimEntityActivity'\nimport { DynamiteActivity } from '../activities/DynamiteActivity'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { CarryJob } from '../job/CarryJob'\nimport { PriorityIdentifier } from '../job/PriorityIdentifier'\nimport { CarryDynamiteJob } from '../job/surface/CarryDynamiteJob'\nimport { Surface } from '../map/Surface'\nimport { CarryPathTarget } from './CarryPathTarget'\nimport { MaterialEntity } from './MaterialEntity'\n\nexport class Dynamite extends MaterialEntity {\n\n    targetSurface: Surface\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager, surface: Surface) {\n        super(worldMgr, sceneMgr, EntityType.DYNAMITE, 'MiscAnims/Dynamite/Dynamite.ae')\n        this.targetSurface = surface\n        this.priorityIdentifier = PriorityIdentifier.aiPriorityDestruction\n        this.changeActivity()\n    }\n\n    getCarryTargets(): CarryPathTarget[] {\n        if (this.targetSurface && this.targetSurface.isExplodable()) {\n            return this.targetSurface.getDigPositions().map((p) => new CarryPathTarget(p))\n        } else {\n            return GameState.getBuildingsByType(EntityType.TOOLSTATION).map((b) => b.getDropPosition2D())\n                .map((p) => new CarryPathTarget(p))\n        }\n    }\n\n    ignite() {\n        // TODO add as explosive and scare em all!\n        const center = this.targetSurface.getCenterWorld()\n        center.y = this.group.position.y\n        this.group.lookAt(center)\n        this.changeActivity(DynamiteActivity.TickDown, () => {\n            this.removeFromScene()\n            this.targetSurface.collapse()\n            // TODO add explosion animation\n            // TODO damage raider, vehicle, buildings\n        })\n    }\n\n    getDefaultActivity(): AnimEntityActivity {\n        return DynamiteActivity.Normal\n    }\n\n    createCarryJob(): CarryJob<Dynamite> {\n        return new CarryDynamiteJob(this)\n    }\n\n}\n","import { LWOLoader } from '../../../resource/LWOLoader'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { EntityType } from '../EntityType'\nimport { PriorityIdentifier } from '../job/PriorityIdentifier'\nimport { MaterialEntity } from './MaterialEntity'\n\nexport class Ore extends MaterialEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.ORE)\n        const resource = ResourceManager.getResource('MiscAnims/Ore/Ore1st.lwo')\n        const mesh = SceneManager.registerMesh(new LWOLoader('MiscAnims/Ore/').parse(resource))\n        this.group.add(mesh)\n        this.targetBuildingTypes = [EntityType.ORE_REFINERY, EntityType.TOOLSTATION]\n        this.priorityIdentifier = PriorityIdentifier.aiPriorityOre\n    }\n\n    get stats() {\n        return ResourceManager.stats.Ore\n    }\n\n}\n","import { RaiderActivity } from '../../activities/RaiderActivity'\nimport { Surface } from '../../map/Surface'\nimport { PathTarget } from '../../PathTarget'\nimport { RaiderTool } from '../../raider/RaiderTool'\nimport { PublicJob } from '../Job'\nimport { JobType } from '../JobType'\nimport { PriorityIdentifier } from '../PriorityIdentifier'\n\nexport class ClearRubbleJob extends PublicJob {\n\n    surface: Surface\n    lastRubblePositions: PathTarget[]\n\n    constructor(surface: Surface) {\n        super(JobType.CLEAR_RUBBLE)\n        this.surface = surface\n        this.lastRubblePositions = this.surface.rubblePositions.map((p) => new PathTarget(p))\n    }\n\n    getRequiredTool(): RaiderTool {\n        return RaiderTool.SHOVEL\n    }\n\n    getWorkplaces(): PathTarget[] { // TODO optimize performance and code duplication\n        const surfaceRubblePositions = this.surface.rubblePositions\n        if (!this.lastRubblePositions.every((d) => surfaceRubblePositions.some((p) => p.equals(d.targetLocation))) ||\n            !surfaceRubblePositions.every((p) => this.lastRubblePositions.some((d) => p.equals(d.targetLocation)))) {\n            this.lastRubblePositions = surfaceRubblePositions.map((p) => new PathTarget(p))\n        }\n        return this.lastRubblePositions\n    }\n\n    onJobComplete() {\n        this.fulfiller.forEach((f) => f.changeActivity())\n        this.surface.reduceRubble()\n        if (!this.surface.hasRubble()) {\n            super.onJobComplete()\n        }\n    }\n\n    getPriorityIdentifier(): PriorityIdentifier {\n        return PriorityIdentifier.aiPriorityClearing\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return RaiderActivity.Clear\n    }\n\n}\n","import { RaiderActivity } from '../../activities/RaiderActivity'\nimport { EntityType } from '../../EntityType'\nimport { FulfillerEntity } from '../../FulfillerEntity'\nimport { Surface } from '../../map/Surface'\nimport { PathTarget } from '../../PathTarget'\nimport { RaiderTool } from '../../raider/RaiderTool'\nimport { PublicJob } from '../Job'\nimport { JobType } from '../JobType'\nimport { PriorityIdentifier } from '../PriorityIdentifier'\n\nexport class DrillJob extends PublicJob {\n\n    color: number = 0xa0a0a0\n    surface: Surface\n    digPositions: PathTarget[]\n\n    constructor(surface: Surface) {\n        super(JobType.DRILL)\n        this.surface = surface\n        this.digPositions = this.surface.getDigPositions().map((p) => new PathTarget(p))\n    }\n\n    getRequiredTool(): RaiderTool {\n        return RaiderTool.DRILL\n    }\n\n    getWorkplaces(): PathTarget[] { // TODO optimize performance and code duplication\n        const surfaceDigPositions = this.surface.getDigPositions()\n        if (!this.digPositions.every((d) => surfaceDigPositions.some((p) => p.equals(d.targetLocation))) ||\n            !surfaceDigPositions.every((p) => this.digPositions.some((d) => p.equals(d.targetLocation)))) {\n            this.digPositions = surfaceDigPositions.map((p) => new PathTarget(p))\n        }\n        return this.digPositions\n    }\n\n    onJobComplete() {\n        if (this.surface.onDrillComplete(this.fulfiller.last().getPosition2D())) super.onJobComplete()\n    }\n\n    getPriorityIdentifier(): PriorityIdentifier {\n        return PriorityIdentifier.aiPriorityDestruction\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return RaiderActivity.Drill\n    }\n\n    getWorkDuration(fulfiller: FulfillerEntity): number {\n        const drillTimeInMsPerType: Map<EntityType, { drillTime: number, count: number }> = new Map()\n        this.fulfiller.forEach((f) => {\n            drillTimeInMsPerType.getOrUpdate(f.entityType, () => {\n                return {drillTime: f.stats[this.surface.surfaceType.statsDrillName][f.level] * 1000, count: 0}\n            }).count++\n        })\n        const drillTimeEntry = drillTimeInMsPerType.get(fulfiller.entityType)\n        const drillTimeMs = drillTimeEntry?.drillTime / (drillTimeEntry?.count || 1) || null\n        if (!drillTimeMs) console.warn('According to cfg this entity cannot drill this material')\n        return drillTimeMs\n    }\n\n}\n","import { RaiderActivity } from '../../activities/RaiderActivity'\nimport { FulfillerEntity } from '../../FulfillerEntity'\nimport { Surface } from '../../map/Surface'\nimport { PathTarget } from '../../PathTarget'\nimport { PublicJob } from '../Job'\nimport { JobType } from '../JobType'\nimport { PriorityIdentifier } from '../PriorityIdentifier'\n\nexport class ReinforceJob extends PublicJob {\n\n    color: number = 0x60a060\n    surface: Surface\n    digPositions: PathTarget[]\n\n    constructor(surface: Surface) {\n        super(JobType.REINFORCE)\n        this.surface = surface\n        this.digPositions = this.surface.getDigPositions().map((p) => new PathTarget(p))\n    }\n\n    getWorkplaces(): PathTarget[] { // TODO optimize performance and code duplication\n        const surfaceDigPositions = this.surface.getDigPositions()\n        if (!this.digPositions.every((d) => surfaceDigPositions.some((p) => p.equals(d.targetLocation))) ||\n            !surfaceDigPositions.every((p) => this.digPositions.some((d) => p.equals(d.targetLocation)))) {\n            this.digPositions = surfaceDigPositions.map((p) => new PathTarget(p))\n        }\n        return this.digPositions\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        this.surface.reinforce()\n    }\n\n    getPriorityIdentifier(): PriorityIdentifier {\n        return PriorityIdentifier.aiPriorityReinforce\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return RaiderActivity.Reinforce\n    }\n\n    getWorkDuration(fulfiller: FulfillerEntity): number {\n        return 2700\n    }\n\n}\n","import { Group, MathUtils, Mesh, MeshPhongMaterial, PositionalAudio, Vector2, Vector3 } from 'three'\nimport { Sample } from '../../../audio/Sample'\nimport { SoundManager } from '../../../audio/SoundManager'\nimport { clearTimeoutSafe, getRandom, getRandomSign } from '../../../core/Util'\nimport { EventBus } from '../../../event/EventBus'\nimport { SelectionChanged } from '../../../event/LocalEvents'\nimport { CavernDiscovered, JobCreateEvent, JobDeleteEvent, OreFoundEvent } from '../../../event/WorldEvents'\nimport { CrystalFoundEvent, LandslideEvent } from '../../../event/WorldLocationEvent'\nimport { HEIGHT_MULTIPLER, TILESIZE } from '../../../params'\nimport { LWSCLoader } from '../../../resource/LWSCLoader'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { AnimSubObj } from '../anim/AnimSubObj'\nimport { BuildingEntity } from '../building/BuildingEntity'\nimport { BuildingSite } from '../building/BuildingSite'\nimport { Crystal } from '../collect/Crystal'\nimport { Dynamite } from '../collect/Dynamite'\nimport { ElectricFence } from '../collect/ElectricFence'\nimport { Ore } from '../collect/Ore'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { CarryDynamiteJob } from '../job/surface/CarryDynamiteJob'\nimport { ClearRubbleJob } from '../job/surface/ClearRubbleJob'\nimport { DrillJob } from '../job/surface/DrillJob'\nimport { ReinforceJob } from '../job/surface/ReinforceJob'\nimport { Selectable, SelectionType } from '../Selectable'\nimport { SurfaceGeometry } from './SurfaceGeometry'\nimport { SurfaceType } from './SurfaceType'\nimport { Terrain } from './Terrain'\nimport { WALL_TYPE } from './WallType'\nimport degToRad = MathUtils.degToRad\n\nexport class Surface implements Selectable {\n\n    terrain: Terrain\n    worldMgr: WorldManager\n    sceneMgr: SceneManager\n    surfaceType: SurfaceType\n    x: number\n    y: number\n    containedOres: number = 0\n    containedCrystals: number = 0\n    heightOffset: number = null\n    discovered: boolean = false\n    selected: boolean = false\n    reinforced: boolean = false\n    drillJob: DrillJob = null\n    reinforceJob: ReinforceJob = null\n    dynamiteJob: CarryDynamiteJob = null\n    clearRubbleJob: ClearRubbleJob = null\n    surfaceRotation: number = 0\n    seamLevel: number = 0\n    fallinTimeout = null\n\n    fallinGrp: Group = null\n    animationTimeout = null\n\n    wallType: WALL_TYPE = null\n    mesh: Mesh = null\n    needsMeshUpdate: boolean = false\n\n    topLeftVertex: Vector3 = null\n    topRightVertex: Vector3 = null\n    bottomLeftVertex: Vector3 = null\n    bottomRightVertex: Vector3 = null\n\n    rubblePositions: Vector2[] = []\n\n    building: BuildingEntity = null\n    site: BuildingSite = null\n    fence: ElectricFence = null\n    hasPower: boolean = false\n\n    constructor(terrain: Terrain, surfaceType: SurfaceType, x: number, y: number, heightOffset: number) {\n        this.terrain = terrain\n        this.worldMgr = this.terrain.worldMgr\n        this.sceneMgr = this.terrain.sceneMgr\n        this.surfaceType = surfaceType\n        if (surfaceType === SurfaceType.CRYSTAL_SEAM || surfaceType === SurfaceType.ORE_SEAM) this.seamLevel = 4\n        this.x = x\n        this.y = y\n        this.heightOffset = heightOffset\n        if (surfaceType === SurfaceType.RUBBLE4 || surfaceType === SurfaceType.RUBBLE3 || surfaceType === SurfaceType.RUBBLE2 || surfaceType === SurfaceType.RUBBLE1) {\n            this.rubblePositions = [this.getRandomPosition(), this.getRandomPosition(), this.getRandomPosition(), this.getRandomPosition()]\n        }\n    }\n\n    /**\n     * @return {boolean} Returns true, if a new cave has been discovered\n     */\n    discover(): boolean { // TODO improve performance then test with level 20\n        this.setDiscovered()\n        this.needsMeshUpdate = true\n        if (!this.surfaceType.floor) return false\n        const floors: Surface[] = []\n        const others: Surface[] = []\n        for (let x = -1; x <= 1; x++) {\n            for (let y = -1; y <= 1; y++) {\n                if (x === 0 && y === 0) continue\n                const n = this.terrain.getSurface(this.x + x, this.y + y)\n                if ((x === 0 || y === 0) && n.surfaceType.floor) {\n                    floors.push(n)\n                } else {\n                    others.push(n)\n                }\n            }\n        }\n        let caveFound = false\n        let counter = 0\n        while (floors.length > 0) {\n            counter++\n            const neighbor = floors.shift()\n            neighbor.setDiscovered()\n            for (let x = -1; x <= 1; x++) {\n                for (let y = -1; y <= 1; y++) {\n                    if (x === 0 && y === 0) continue\n                    const n = neighbor.terrain.getSurface(neighbor.x + x, neighbor.y + y)\n                    if ((x === 0 || y === 0) && n.surfaceType.floor && !n.discovered) {\n                        floors.push(n)\n                        caveFound = true\n                    } else {\n                        others.push(n)\n                    }\n                }\n            }\n        }\n        others.forEach((o) => {\n            o.setDiscovered()\n            if (!o.isSupported()) {\n                o.collapse()\n            }\n        })\n        console.log('surface discover handled ' + counter + ' floors and ' + others.length + ' others')\n        return caveFound\n    }\n\n    private setDiscovered() {\n        if (!this.discovered) GameState.discoverSurface(this)\n        this.discovered = true\n        this.needsMeshUpdate = true\n    }\n\n    onDrillComplete(drillPosition: Vector2): boolean {\n        if (this.seamLevel > 0) {\n            this.seamLevel--\n            const vec = new Vector2().copy(drillPosition).sub(this.getCenterWorld2D())\n                .multiplyScalar(0.3 + getRandom(3) / 10)\n                .rotateAround(new Vector2(0, 0), degToRad(-10 + getRandom(20)))\n                .add(drillPosition)\n            if (this.surfaceType === SurfaceType.CRYSTAL_SEAM) {\n                const crystal = this.worldMgr.placeMaterial(new Crystal(this.worldMgr, this.sceneMgr), vec)\n                EventBus.publishEvent(new CrystalFoundEvent(crystal.getPosition()))\n            } else if (this.surfaceType === SurfaceType.ORE_SEAM) {\n                this.worldMgr.placeMaterial(new Ore(this.worldMgr, this.sceneMgr), vec)\n                EventBus.publishEvent(new OreFoundEvent())\n            }\n        }\n        if (this.seamLevel > 0) {\n            return false\n        } else {\n            this.collapse()\n            return true\n        }\n    }\n\n    collapse() {\n        this.cancelJobs()\n        this.fallinTimeout = clearTimeoutSafe(this.fallinTimeout)\n        this.surfaceType = SurfaceType.RUBBLE4\n        this.rubblePositions = [this.getRandomPosition(), this.getRandomPosition(), this.getRandomPosition(), this.getRandomPosition()]\n        this.containedOres += 4\n        this.needsMeshUpdate = true\n        const foundCave = this.discover()\n        if (foundCave) EventBus.publishEvent(new CavernDiscovered())\n        // drop contained ores and crystals\n        this.dropContainedOre(this.containedOres - 4)\n        for (let c = 0; c < this.containedCrystals; c++) {\n            const crystal = this.worldMgr.placeMaterial(new Crystal(this.worldMgr, this.sceneMgr), this.getRandomPosition())\n            EventBus.publishEvent(new CrystalFoundEvent(crystal.getPosition()))\n        }\n        // check for unsupported neighbors\n        for (let x = this.x - 1; x <= this.x + 1; x++) {\n            for (let y = this.y - 1; y <= this.y + 1; y++) {\n                if (x !== this.x || y !== this.y) {\n                    const surf = this.terrain.getSurface(x, y)\n                    surf.needsMeshUpdate = true\n                    if (!surf.isSupported()) surf.collapse()\n                }\n            }\n        }\n        // update meshes\n        this.terrain.updateSurfaceMeshes()\n        this.terrain.floorGroup.updateWorldMatrix(true, true)\n        this.playPositionalSample(Sample.SFX_RockBreak)\n    }\n\n    private dropContainedOre(dropAmount: number) {\n        for (let c = 0; c < dropAmount && this.containedOres > 0; c++) {\n            this.containedOres--\n            this.worldMgr.placeMaterial(new Ore(this.worldMgr, this.sceneMgr), this.getRandomPosition())\n            EventBus.publishEvent(new OreFoundEvent())\n        }\n    }\n\n    getRandomPosition(): Vector2 {\n        return new Vector2(this.x * TILESIZE + TILESIZE / 2 + getRandomSign() * getRandom(TILESIZE / 4),\n            this.y * TILESIZE + TILESIZE / 2 + getRandomSign() * getRandom(TILESIZE / 4))\n    }\n\n    cancelJobs() {\n        this.drillJob = Surface.safeRemoveJob(this.drillJob)\n        this.reinforceJob = Surface.safeRemoveJob(this.reinforceJob)\n        this.dynamiteJob = Surface.safeRemoveJob(this.dynamiteJob)\n        this.clearRubbleJob = Surface.safeRemoveJob(this.clearRubbleJob)\n        this.updateJobColor()\n    }\n\n    private static safeRemoveJob(job: DrillJob | ReinforceJob | CarryDynamiteJob | ClearRubbleJob) {\n        if (job) EventBus.publishEvent(new JobDeleteEvent(job))\n        return null\n    }\n\n    reduceRubble() {\n        this.rubblePositions.shift()\n        if (this.surfaceType === SurfaceType.RUBBLE4) this.surfaceType = SurfaceType.RUBBLE3\n        else if (this.surfaceType === SurfaceType.RUBBLE3) this.surfaceType = SurfaceType.RUBBLE2\n        else if (this.surfaceType === SurfaceType.RUBBLE2) this.surfaceType = SurfaceType.RUBBLE1\n        else if (this.surfaceType === SurfaceType.RUBBLE1) this.surfaceType = SurfaceType.GROUND\n        this.dropContainedOre(this.containedOres - this.rubblePositions.length)\n        this.updateTexture()\n        if (this.selected) EventBus.publishEvent(new SelectionChanged(SelectionType.SURFACE, this))\n    }\n\n    isSupported(): boolean {\n        if (this.surfaceType.floor) return true\n        const surfLeft = this.terrain.getSurface(this.x - 1, this.y)\n        const surfTopLeft = this.terrain.getSurface(this.x - 1, this.y - 1)\n        const surfTop = this.terrain.getSurface(this.x, this.y - 1)\n        const surfTopRight = this.terrain.getSurface(this.x + 1, this.y - 1)\n        const surfRight = this.terrain.getSurface(this.x + 1, this.y)\n        const surfBottomRight = this.terrain.getSurface(this.x + 1, this.y + 1)\n        const surfBottom = this.terrain.getSurface(this.x, this.y + 1)\n        const surfBottomLeft = this.terrain.getSurface(this.x - 1, this.y + 1)\n\n        function isHighGround(surf1: Surface, surf2: Surface, surf3: Surface) {\n            return !surf1.discovered || !surf2.discovered || !surf3.discovered ||\n                (!surf1.surfaceType.floor && !surf2.surfaceType.floor && !surf3.surfaceType.floor)\n        }\n\n        return isHighGround(surfLeft, surfTopLeft, surfTop)\n            || isHighGround(surfTop, surfTopRight, surfRight)\n            || isHighGround(surfRight, surfBottomRight, surfBottom)\n            || isHighGround(surfBottom, surfBottomLeft, surfLeft)\n    }\n\n    updateMesh(force: boolean = true) {\n        if (!force && !this.needsMeshUpdate) return\n        this.needsMeshUpdate = false\n\n        const topLeftVertex = new Vector3(this.x, 0, this.y)\n        const topRightVertex = new Vector3(this.x + 1, 0, this.y)\n        const bottomLeftVertex = new Vector3(this.x, 0, this.y + 1)\n        const bottomRightVertex = new Vector3(this.x + 1, 0, this.y + 1)\n\n        const surfLeft = this.terrain.getSurface(this.x - 1, this.y)\n        const surfTopLeft = this.terrain.getSurface(this.x - 1, this.y - 1)\n        const surfTop = this.terrain.getSurface(this.x, this.y - 1)\n        const surfTopRight = this.terrain.getSurface(this.x + 1, this.y - 1)\n        const surfRight = this.terrain.getSurface(this.x + 1, this.y)\n        const surfBottomRight = this.terrain.getSurface(this.x + 1, this.y + 1)\n        const surfBottom = this.terrain.getSurface(this.x, this.y + 1)\n        const surfBottomLeft = this.terrain.getSurface(this.x - 1, this.y + 1)\n\n        function isHighGround(surf1: Surface, surf2: Surface, surf3: Surface) {\n            return !surf1.discovered || !surf2.discovered || !surf3.discovered ||\n                (!surf1.surfaceType.floor && !surf2.surfaceType.floor && !surf3.surfaceType.floor)\n        }\n\n        if (!this.discovered) {\n            topLeftVertex.y = 1\n            topRightVertex.y = 1\n            bottomRightVertex.y = 1\n            bottomLeftVertex.y = 1\n        } else if (!this.surfaceType.floor || !this.neighbors.some((n) => n.surfaceType.floor && n.discovered)) {\n            if (isHighGround(surfLeft, surfTopLeft, surfTop)) topLeftVertex.y = 1\n            if (isHighGround(surfTop, surfTopRight, surfRight)) topRightVertex.y = 1\n            if (isHighGround(surfRight, surfBottomRight, surfBottom)) bottomRightVertex.y = 1\n            if (isHighGround(surfBottom, surfBottomLeft, surfLeft)) bottomLeftVertex.y = 1\n        }\n\n        // update mesh (geometry), if wall type changed\n        let wallType = topLeftVertex.y + topRightVertex.y + bottomRightVertex.y + bottomLeftVertex.y\n        if (wallType === WALL_TYPE.WALL && topLeftVertex.y === bottomRightVertex.y) wallType = WALL_TYPE.WEIRD_CREVICE\n\n        if (this.wallType !== wallType) {\n            this.wallType = wallType\n\n            function avgHeight(...args: Surface[]) {\n                return args.map((s) => s.heightOffset)\n                    .reduce((l, r) => (l || 0) + (r || 0), 0) / (args.length || 1)\n            }\n\n            this.topLeftVertex = topLeftVertex.clone()\n            this.topRightVertex = topRightVertex.clone()\n            this.bottomLeftVertex = bottomLeftVertex.clone()\n            this.bottomRightVertex = bottomRightVertex.clone()\n            this.topLeftVertex.y += avgHeight(surfTopLeft, surfTop, this, surfLeft) * HEIGHT_MULTIPLER\n            this.topRightVertex.y += avgHeight(surfTop, surfTopRight, surfRight, this) * HEIGHT_MULTIPLER\n            this.bottomRightVertex.y += avgHeight(this, surfRight, surfBottomRight, surfBottom) * HEIGHT_MULTIPLER\n            this.bottomLeftVertex.y += avgHeight(surfLeft, this, surfBottom, surfBottomLeft) * HEIGHT_MULTIPLER\n\n            this.updateGeometry(topLeftVertex, bottomRightVertex, topRightVertex, bottomLeftVertex)\n            if (this.wallType !== WALL_TYPE.WALL) this.cancelReinforceJobs()\n        }\n\n        this.updateTexture()\n        this.updateJobColor()\n        this.updateGraphWalk()\n    }\n\n    private updateGraphWalk() {\n        const weight = this.getGraphWalkWeight()\n        for (let x = 0; x < 3; x++) {\n            for (let y = 0; y < 3; y++) {\n                this.terrain.graphWalk.grid[this.x * 3 + x][this.y * 3 + y].weight = weight\n            }\n        }\n    }\n\n    cancelReinforceJobs() {\n        this.reinforceJob = Surface.safeRemoveJob(this.reinforceJob)\n        this.updateJobColor()\n    }\n\n    updateTexture() {\n        let textureName = this.terrain.textureSet.texturebasename\n        if (!this.discovered) {\n            textureName += '70'\n        } else if (this.surfaceType === SurfaceType.POWER_PATH) {\n            textureName += this.updatePowerPathTexture()\n        } else if (!this.surfaceType.shaping && this.neighbors.some((n) => n.discovered && n.surfaceType.floor)) {\n            if (this.surfaceType === SurfaceType.POWER_PATH_BUILDING && this.hasPower) {\n                textureName += '66'\n            } else {\n                textureName += this.surfaceType.matIndex.toString()\n            }\n        } else if (this.wallType === WALL_TYPE.WEIRD_CREVICE) {\n            textureName += '77'\n        } else {\n            if (this.wallType === WALL_TYPE.CORNER) {\n                textureName += '5'\n            } else if (this.wallType === WALL_TYPE.INVERTED_CORNER) {\n                textureName += '3'\n            } else if (this.reinforced) {\n                textureName += '2'\n            } else {\n                textureName += '0'\n            }\n            textureName += this.surfaceType.shaping ? this.surfaceType.matIndex : SurfaceType.SOLID_ROCK.matIndex\n        }\n        textureName += '.bmp'\n\n        this.forEachMaterial((mat) => mat.map?.dispose())\n        const texture = ResourceManager.getTexture(textureName)\n        texture.center.set(0.5, 0.5)\n        texture.rotation = this.surfaceRotation\n\n        this.forEachMaterial((mat) => mat.map = texture)\n    }\n\n    private updatePowerPathTexture(): string {\n        this.surfaceRotation = 0\n        const left = this.terrain.getSurface(this.x - 1, this.y).isPath()\n        const top = this.terrain.getSurface(this.x, this.y - 1).isPath()\n        const right = this.terrain.getSurface(this.x + 1, this.y).isPath()\n        const bottom = this.terrain.getSurface(this.x, this.y + 1).isPath()\n        const pathSum = (left ? 1 : 0) + (top ? 1 : 0) + (right ? 1 : 0) + (bottom ? 1 : 0)\n        if (pathSum === 0 || pathSum === 1) {\n            if (left) this.surfaceRotation = -Math.PI / 2\n            if (top) this.surfaceRotation = Math.PI\n            if (right) this.surfaceRotation = Math.PI / 2\n            return this.hasPower ? '75' : '65'\n        } else if (pathSum === 2) {\n            if (left === right) {\n                this.surfaceRotation = left ? Math.PI / 2 : 0\n                return this.hasPower ? '72' : '62'\n            } else {\n                if (left && bottom) this.surfaceRotation = -Math.PI / 2\n                if (left && top) this.surfaceRotation = Math.PI\n                if (top && right) this.surfaceRotation = Math.PI / 2\n                return this.hasPower ? '73' : '63'\n            }\n        } else if (pathSum === 3) {\n            if (!top) this.surfaceRotation = -Math.PI / 2\n            if (!right) this.surfaceRotation = Math.PI\n            if (!bottom) this.surfaceRotation = Math.PI / 2\n            return this.hasPower ? '74' : '64'\n        } else {\n            return this.hasPower ? '71' : '60'\n        }\n    }\n\n    forEachMaterial(callback: (mat: MeshPhongMaterial) => void): void {\n        if (!this.mesh?.material) return;\n        (Array.isArray(this.mesh.material) ? this.mesh.material : [this.mesh.material]).forEach((m) => callback(m as MeshPhongMaterial))\n    }\n\n    updateGeometry(topLeftVertex: Vector3, bottomRightVertex: Vector3, topRightVertex: Vector3, bottomLeftVertex: Vector3) {\n        if (this.mesh) this.terrain.floorGroup.remove(this.mesh)\n        this.mesh?.geometry?.dispose()\n\n        const geometry = SurfaceGeometry.create(this.wallType, topLeftVertex, bottomRightVertex, topRightVertex, bottomLeftVertex,\n            this.topLeftVertex.y, this.topRightVertex.y, this.bottomRightVertex.y, this.bottomLeftVertex.y)\n\n        this.mesh = new Mesh(geometry, new MeshPhongMaterial({shininess: 0}))\n        this.mesh.userData = {selectable: this, surface: this}\n\n        this.terrain.floorGroup.add(this.mesh)\n        this.terrain.floorGroup.updateWorldMatrix(true, true) // otherwise ray intersection is not working before rendering\n    }\n\n    getSelectionType(): SelectionType {\n        return SelectionType.SURFACE\n    }\n\n    select(): boolean {\n        if (this.surfaceType.selectable && (this.wallType !== WALL_TYPE.INVERTED_CORNER && this.wallType !== WALL_TYPE.WEIRD_CREVICE) && !this.selected && this.discovered) {\n            this.selected = true\n            this.forEachMaterial((mat) => mat.color.setHex(0x6060a0))\n            if (this.surfaceType.floor) SoundManager.playSample(Sample.SFX_Floor)\n            if (this.surfaceType.shaping) SoundManager.playSample(Sample.SFX_Wall)\n            console.log('Surface selected at ' + this.x + '/' + this.y)\n            return true\n        }\n        return false\n    }\n\n    deselect(): any {\n        if (this.selected) {\n            this.selected = false\n            this.updateJobColor()\n        }\n    }\n\n    getSelectionCenter(): Vector3 {\n        return null // not used\n    }\n\n    updateJobColor() {\n        const color = this.dynamiteJob?.color || this.reinforceJob?.color || this.drillJob?.color || 0xffffff\n        this.forEachMaterial((mat) => mat.color.setHex(color))\n    }\n\n    hasRubble(): boolean {\n        return this.rubblePositions.length > 0\n    }\n\n    isPath(): boolean {\n        return this.surfaceType === SurfaceType.POWER_PATH || this.surfaceType === SurfaceType.POWER_PATH_BUILDING\n    }\n\n    isWalkable(): boolean {\n        return this.surfaceType.floor && this.discovered && this.surfaceType !== SurfaceType.LAVA && this.surfaceType !== SurfaceType.WATER && !this.building?.blocksPathSurface\n    }\n\n    isDrillable(): boolean {\n        return this.surfaceType.drillable && this.discovered && (this.wallType === WALL_TYPE.WALL || this.wallType === WALL_TYPE.CORNER)\n    }\n\n    isDrillableHard(): boolean {\n        return this.surfaceType.drillableHard && this.discovered && (this.wallType === WALL_TYPE.WALL || this.wallType === WALL_TYPE.CORNER)\n    }\n\n    isReinforcable(): boolean {\n        return this.surfaceType.reinforcable && this.discovered && this.wallType === WALL_TYPE.WALL && !this.reinforced\n    }\n\n    isExplodable(): boolean {\n        return this.surfaceType.explodable && this.discovered && (this.wallType === WALL_TYPE.WALL || this.wallType === WALL_TYPE.CORNER)\n    }\n\n    isDigable(): boolean {\n        return this.isDrillable() || this.isExplodable()\n    }\n\n    getDigPositions(): Vector2[] {\n        const digPosition = []\n        if (this.terrain.getSurface(this.x - 1, this.y).isWalkable()) digPosition.push(new Vector2(this.x * TILESIZE - 1, this.y * TILESIZE + TILESIZE / 2))\n        if (this.terrain.getSurface(this.x, this.y - 1).isWalkable()) digPosition.push(new Vector2(this.x * TILESIZE + TILESIZE / 2, this.y * TILESIZE - 1))\n        if (this.terrain.getSurface(this.x + 1, this.y).isWalkable()) digPosition.push(new Vector2(this.x * TILESIZE + TILESIZE + 1, this.y * TILESIZE + TILESIZE / 2))\n        if (this.terrain.getSurface(this.x, this.y + 1).isWalkable()) digPosition.push(new Vector2(this.x * TILESIZE + TILESIZE / 2, this.y * TILESIZE + TILESIZE + 1))\n        return digPosition\n    }\n\n    reinforce() {\n        this.reinforced = true\n        this.cancelReinforceJobs()\n        this.fallinTimeout = clearTimeoutSafe(this.fallinTimeout)\n        this.updateTexture()\n    }\n\n    getCenterWorld2D(): Vector2 {\n        return new Vector2(this.x, this.y).addScalar(0.5).multiplyScalar(TILESIZE)\n    }\n\n    getCenterWorld(): Vector3 {\n        const center = this.getCenterWorld2D()\n        return new Vector3(center.x, this.sceneMgr.getTerrainHeight(center.x, center.y), center.y)\n    }\n\n    setFallinLevel(fallinLevel: number) {\n        if (fallinLevel < 1) return\n        let originPos\n        let targetPos\n        if (this.surfaceType.floor) {\n            originPos = this.terrain.findFallInOrigin(this.x, this.y)\n            targetPos = [this.x, this.y]\n        } else {\n            originPos = [this.x, this.y]\n            targetPos = this.terrain.findFallInTarget(this.x, this.y)\n        }\n        if (originPos && targetPos) {\n            this.terrain.getSurface(originPos[0], originPos[1]).scheduleFallin(targetPos[0], targetPos[1])\n        }\n    }\n\n    scheduleFallin(targetX: number, targetY: number) {\n        this.fallinTimeout = setTimeout(() => {\n            this.createFallin(targetX, targetY)\n            this.scheduleFallin(targetX, targetY)\n        }, (30 + getRandom(60)) * 1000) // TODO adapt timer to level multiplier and fallin value\n    }\n\n    createFallin(targetX: number, targetY: number) {\n        const fallinPosition = this.terrain.getSurface(targetX, targetY).getCenterWorld()\n        EventBus.publishEvent(new LandslideEvent(fallinPosition))\n        this.playPositionalSample(Sample.SFX_FallIn)\n\n        // TODO refactor mesh and animation handling\n        const content = ResourceManager.getResource('MiscAnims/RockFall/Rock3Sides.lws')\n        const animation = new LWSCLoader('MiscAnims/RockFall/').parse(content)\n        this.fallinGrp = new Group()\n        this.fallinGrp.position.copy(fallinPosition)\n        const dx = this.x - targetX, dy = targetY - this.y\n        this.fallinGrp.rotateOnAxis(new Vector3(0, 1, 0), Math.atan2(dy, dx) + Math.PI / 2)\n        this.sceneMgr.scene.add(this.fallinGrp)\n        const poly = []\n        animation.bodies.forEach((body) => {\n            const polyModel = body.model.clone(true)\n            poly.push(polyModel)\n        })\n        animation.bodies.forEach((body, index) => { // not all bodies may have been added in first iteration\n            const polyPart = poly[index]\n            const parentInd = body.parentObjInd\n            if (parentInd !== undefined && parentInd !== null) { // can be 0\n                poly[parentInd].add(polyPart)\n            } else {\n                this.fallinGrp.add(polyPart)\n            }\n        })\n        this.animate(poly, animation, 0)\n\n        this.terrain.getSurface(targetX, targetY).makeRubble()\n    }\n\n    animate(poly, animation, frameIndex) {\n        if (poly.length !== animation.bodies.length) throw 'Cannot animate poly. Length differs from bodies length'\n        animation.bodies.forEach((body: AnimSubObj, index) => {\n            const p = poly[index]\n            p.position.copy(body.relPos[frameIndex])\n            p.rotation.copy(body.relRot[frameIndex])\n            p.scale.copy(body.relScale[frameIndex])\n            if (p.hasOwnProperty('material')) {\n                const material = p['material']\n                const opacity = body.opacity[frameIndex]\n                if (material && opacity !== undefined) {\n                    const matArr = Array.isArray(material) ? material : [material]\n                    matArr.forEach((mat: MeshPhongMaterial) => {\n                        mat.opacity = opacity\n                        mat.transparent = mat.transparent || mat.opacity < 1\n                    })\n                }\n            }\n        })\n        this.animationTimeout = null\n        if (!(frameIndex + 1 > animation.lastFrame) || animation.looping) {\n            let nextFrame = frameIndex + 1\n            if (nextFrame > animation.lastFrame) {\n                nextFrame = animation.firstFrame\n            }\n            const that = this\n            this.animationTimeout = setTimeout(() => that.animate(poly, animation, nextFrame), 1000 / animation.framesPerSecond * animation.transcoef)\n        } else {\n            this.sceneMgr.scene.remove(this.fallinGrp)\n            this.fallinGrp = null\n        }\n    }\n\n    dispose() {\n        this.fallinTimeout = clearTimeoutSafe(this.fallinTimeout)\n        this.forEachMaterial(m => m.dispose())\n        this.mesh?.geometry?.dispose()\n    }\n\n    getFloorHeight(worldX: number, worldZ: number) {\n        const sx = worldX / TILESIZE - this.x\n        const sy = worldZ / TILESIZE - this.y\n        const dy0 = Surface.interpolate(this.topLeftVertex.y, this.topRightVertex.y, sx)\n        const dy1 = Surface.interpolate(this.bottomLeftVertex.y, this.bottomRightVertex.y, sx)\n        return Surface.interpolate(dy0, dy1, sy) * TILESIZE\n    }\n\n    private static interpolate(y0: number, y1: number, x: number): number {\n        return y0 + x * (y1 - y0)\n    }\n\n    get neighbors(): Surface[] {\n        return [this.terrain.getSurface(this.x - 1, this.y), this.terrain.getSurface(this.x, this.y - 1),\n            this.terrain.getSurface(this.x + 1, this.y), this.terrain.getSurface(this.x, this.y + 1)]\n    }\n\n    makeRubble(containedOre: number = 0) {\n        this.rubblePositions = [this.getRandomPosition(), this.getRandomPosition(), this.getRandomPosition(), this.getRandomPosition()]\n        this.containedOres += containedOre\n        this.setSurfaceTypeAndUpdateNeighbors(SurfaceType.RUBBLE4)\n    }\n\n    setBuilding(building: BuildingEntity) {\n        this.building = building\n        this.updateGraphWalk()\n        this.setSurfaceTypeAndUpdateNeighbors(this.building ? SurfaceType.POWER_PATH_BUILDING : SurfaceType.GROUND)\n    }\n\n    setSurfaceTypeAndUpdateNeighbors(surfaceType: SurfaceType) {\n        this.surfaceType = surfaceType\n        this.updateTexture()\n        this.neighbors.forEach((n) => n.updateTexture())\n    }\n\n    getGraphWalkWeight(): number {\n        return this.isWalkable() ? this.hasRubble() ? 4 : 1 : 0\n    }\n\n    setHasPower(state: boolean, recursive: boolean) {\n        if (this.hasPower === state) return\n        this.hasPower = state\n        this.updateTexture()\n        if (recursive) this.neighbors.forEach((n) => n.isPath() && n.setHasPower(state, recursive))\n    }\n\n    canPlaceFence(): boolean { // TODO performance this can be cached\n        return this.surfaceType.canCarryFence && !this.building && !this.fence &&\n            [1, 2].some((n) => {\n                return !!this.terrain.getSurface(this.x - n, this.y).building ||\n                    !!this.terrain.getSurface(this.x, this.y - n).building ||\n                    !!this.terrain.getSurface(this.x + n, this.y).building ||\n                    !!this.terrain.getSurface(this.x, this.y + n).building ||\n                    !!this.terrain.getSurface(this.x - n, this.y).fence ||\n                    !!this.terrain.getSurface(this.x, this.y - n).fence ||\n                    !!this.terrain.getSurface(this.x + n, this.y).fence ||\n                    !!this.terrain.getSurface(this.x, this.y + n).fence\n            })\n    }\n\n    createDrillJob(): DrillJob {\n        if (!this.drillJob) {\n            this.drillJob = new DrillJob(this)\n            this.updateJobColor()\n            EventBus.publishEvent(new JobCreateEvent(this.drillJob))\n        }\n        return this.drillJob\n    }\n\n    createReinforceJob(): ReinforceJob {\n        if (!this.reinforceJob) {\n            this.reinforceJob = new ReinforceJob(this)\n            this.updateJobColor()\n            EventBus.publishEvent(new JobCreateEvent(this.reinforceJob))\n        }\n        return this.reinforceJob\n    }\n\n    createDynamiteJob(): CarryDynamiteJob {\n        if (!this.dynamiteJob) {\n            const targetBuilding = GameState.getClosestBuildingByType(this.getCenterWorld(), EntityType.TOOLSTATION) // XXX performance cache this\n            if (!targetBuilding) throw 'Could not find toolstation to spawn dynamite'\n            const dynamite = new Dynamite(this.worldMgr, this.sceneMgr, this)\n            dynamite.addToScene(targetBuilding.getDropPosition2D(), targetBuilding.getHeading())\n            this.dynamiteJob = new CarryDynamiteJob(dynamite)\n            this.updateJobColor()\n            EventBus.publishEvent(new JobCreateEvent(this.dynamiteJob))\n        }\n        return this.dynamiteJob\n    }\n\n    createClearRubbleJob(): ClearRubbleJob {\n        if (!this.clearRubbleJob) {\n            this.clearRubbleJob = new ClearRubbleJob(this)\n            this.updateJobColor()\n            EventBus.publishEvent(new JobCreateEvent(this.clearRubbleJob))\n        }\n        return this.clearRubbleJob\n    }\n\n    setSite(site: BuildingSite) {\n        this.site = site\n        this.setSurfaceTypeAndUpdateNeighbors(this.site ? SurfaceType.POWER_PATH_CONSTRUCTION : SurfaceType.GROUND)\n    }\n\n    playPositionalSample(sample: Sample): PositionalAudio { // TODO merge with AnimEntity code (at least in SceneEntity maybe)\n        const audio = new PositionalAudio(this.sceneMgr.listener)\n        audio.setRefDistance(TILESIZE * 6)\n        this.mesh.add(audio)\n        SoundManager.getSampleBuffer(sample).then((audioBuffer) => {\n            audio.setBuffer(audioBuffer)\n            audio.play()\n        })\n        return audio\n    }\n\n}\n","import { LevelEntryCfg } from '../cfg/LevelsCfg'\nimport { TILESIZE } from '../params'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { Graph } from './model/map/astar'\nimport { Surface } from './model/map/Surface'\nimport { SurfaceType } from './model/map/SurfaceType'\nimport { Terrain } from './model/map/Terrain'\nimport { SceneManager } from './SceneManager'\nimport { WorldManager } from './WorldManager'\n\nexport class TerrainLoader {\n\n    static loadTerrain(levelConf: LevelEntryCfg, worldMgr: WorldManager, sceneMgr: SceneManager): Terrain {\n        const tileSize = levelConf.blockSize\n        if (tileSize !== TILESIZE) console.error('Unexpected tile size in level configuration: ' + tileSize)\n        const terrain = new Terrain(worldMgr, sceneMgr)\n\n        const themeName = levelConf.textureSet[1]\n        terrain.textureSet = ResourceManager.cfg('Textures', themeName)\n        // console.log(terrain.textureSet);\n\n        const terrainMap = ResourceManager.getResource(levelConf.terrainMap)\n        terrain.width = terrainMap.width\n        terrain.height = terrainMap.height\n        const pathMap = ResourceManager.getResource(levelConf.pathMap)?.level\n        const surfaceMap = ResourceManager.getResource(levelConf.surfaceMap)?.level\n        const predugMap = ResourceManager.getResource(levelConf.predugMap)?.level\n        const cryOreMap = ResourceManager.getResource(levelConf.cryOreMap)?.level\n        const fallinMap = ResourceManager.getResource(levelConf.fallinMap)?.level\n        const erodeMap = ResourceManager.getResource(levelConf.erodeMap)?.level\n        const blockMap = ResourceManager.getResource(levelConf.blockPointersMap)?.level\n\n        // maps parsed from WAD are row-wise saved, which means y (row) comes first and x (column) second\n        for (let r = 0; r < terrainMap.level.length; r++) {\n            for (let c = 0; c < (terrainMap.level)[r].length; c++) {\n                (terrain.surfaces)[c] = (terrain.surfaces)[c] || []\n                const surfaceTypeNum = (terrainMap.level)[r][c]\n                let surfaceType = SurfaceType.getByNum(surfaceTypeNum)\n                const predugLevel = predugMap[r][c]\n                if (predugLevel === PredugMap.CAVERN_EXPOSED) {\n                    if (surfaceType === SurfaceType.GROUND || surfaceType === SurfaceType.DIRT\n                        || surfaceType === SurfaceType.POWER_PATH_BUILDING) { // used by mods\n                        surfaceType = SurfaceType.GROUND\n                    } else if (surfaceType !== SurfaceType.WATER && surfaceType !== SurfaceType.LAVA) {\n                        console.warn('Unexpected cavern surface type: ' + surfaceType.name)\n                    }\n                } else if (predugLevel === PredugMap.SLUG_HOLE_EXPOSED || predugLevel === PredugMap.SLUG_HOLE_HIDDEN) {\n                    surfaceType = SurfaceType.SLUG_HOLE\n                } else if (predugLevel !== PredugMap.WALL && predugLevel !== PredugMap.CAVERN_HIDDEN) {\n                    console.warn('Unexpected predug level: ' + predugLevel)\n                }\n                // give the path map the highest priority, if it exists\n                const pathMapLevel = pathMap && surfaceType.floor ? pathMap[r][c] : PathMap.NONE\n                if (pathMapLevel === PathMap.RUBBLE) {\n                    surfaceType = SurfaceType.RUBBLE4\n                } else if (pathMapLevel === PathMap.POWER_PATH) {\n                    surfaceType = SurfaceType.POWER_PATH\n                } else if (pathMapLevel !== PathMap.NONE) {\n                    console.warn('Unexpected path map level: ' + pathMapLevel)\n                }\n\n                const surface = new Surface(terrain, surfaceType, c, r, surfaceMap[r][c])\n                if (cryOreMap) {\n                    const currentCryOre = cryOreMap[r][c]\n                    if (currentCryOre % 2 === 1) {\n                        surface.containedCrystals = (currentCryOre + 1) / 2\n                    } else {\n                        surface.containedOres = currentCryOre / 2\n                    }\n                }\n\n                (terrain.surfaces)[c].push(surface)\n            }\n        }\n\n        // exlpore predug surfaces\n        terrain.forEachSurface((s) => {\n            if (predugMap[s.y][s.x] === PredugMap.CAVERN_EXPOSED || predugMap[s.y][s.x] === PredugMap.SLUG_HOLE_EXPOSED) { // map are rows (y) first, columns (x) second\n                for (let x = s.x - 1; x <= s.x + 1; x++) {\n                    for (let y = s.y - 1; y <= s.y + 1; y++) {\n                        terrain.getSurfaceOrNull(x, y).discovered = true\n                    }\n                }\n            }\n        })\n\n        // create hidden caverns\n        terrain.forEachSurface((s) => {\n            const surface = terrain.getSurfaceOrNull(s.x, s.y)\n            if (predugMap[s.y][s.x] === PredugMap.CAVERN_HIDDEN && !surface.discovered) {\n                surface.surfaceType = SurfaceType.GROUND\n            }\n        })\n\n        // generate path finding weights\n        const weights: number[][] = []\n        for (let x = 0; x < terrain.width; x++) {\n            const col: number[] = []\n            for (let y = 0; y < terrain.height; y++) {\n                const w = terrain.getSurfaceOrNull(x, y).getGraphWalkWeight()\n                col.push(w, w, w)\n            }\n            weights.push(col, col, col)\n        }\n        terrain.graphWalk = new Graph(weights, {diagonal: true})\n\n        // crumble unsupported walls\n        terrain.forEachSurface((s) => {\n            if (!s.isSupported()) s.collapse()\n        })\n\n        terrain.updateSurfaceMeshes(true)\n\n        if (fallinMap) {\n            for (let x = 0; x < terrain.width; x++) {\n                for (let y = 0; y < terrain.height; y++) {\n                    terrain.getSurface(x, y).setFallinLevel(fallinMap[y][x]) // rows (y) before columns (x) used in maps\n                }\n            }\n        }\n\n        if (erodeMap) { // TODO implement lava erosion\n            console.warn('Lucky you! Lava erosion not yet implemented')\n        }\n\n        if (blockMap) { // TODO implement tutorial blocks map\n            // console.log(blockMap)\n        }\n\n        return terrain\n    }\n\n}\n\nenum PathMap {\n\n    NONE = 0,\n    RUBBLE = 1,\n    POWER_PATH = 2,\n\n}\n\nenum PredugMap {\n\n    WALL = 0,\n    CAVERN_EXPOSED = 1,\n    CAVERN_HIDDEN = 2,\n    SLUG_HOLE_EXPOSED = 3,\n    SLUG_HOLE_HIDDEN = 4,\n}\n","import { Vector2 } from 'three'\nimport { PathTarget } from '../PathTarget'\n\nexport class TerrainPath {\n\n    target: PathTarget = null\n    locations: Vector2[] = []\n    lengthSq: number = 0\n\n    constructor(target: PathTarget, locations: Vector2[] | Vector2) {\n        this.target = target\n        this.locations = Array.isArray(locations) ? locations : [locations]\n        for (let c = 0; c < this.locations.length - 1; c++) {\n            const start = this.locations[c]\n            const end = this.locations[c + 1]\n            this.lengthSq += start.distanceToSquared(end)\n        }\n    }\n\n    addLocation(location: Vector2): TerrainPath {\n        this.locations.push(location)\n        if (this.locations.length > 1) {\n            this.lengthSq += this.locations[this.locations.length - 2].distanceToSquared(location)\n        }\n        return this\n    }\n\n    get targetPosition(): Vector2 {\n        return this.locations[this.locations.length - 1] || null\n    }\n\n    get firstLocation(): Vector2 {\n        return this.locations[0] || null\n    }\n\n}\n","import { AxesHelper, Group, Vector2, Vector3 } from 'three'\nimport { DEV_MODE, TILESIZE } from '../../../params'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { PathTarget } from '../PathTarget'\nimport { astar, Graph } from './astar'\nimport { Surface } from './Surface'\nimport { SurfaceType } from './SurfaceType'\nimport { TerrainPath } from './TerrainPath'\n\nexport class Terrain {\n\n    worldMgr: WorldManager\n    sceneMgr: SceneManager\n    textureSet: any = {}\n    width: number = 0\n    height: number = 0\n    surfaces: Surface[][] = []\n    floorGroup: Group = new Group()\n    roofGroup: Group = new Group()\n    graphWalk: Graph = null\n    cachedPaths = new Map<string, TerrainPath>()\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        this.worldMgr = worldMgr\n        this.sceneMgr = sceneMgr\n        this.floorGroup.scale.setScalar(TILESIZE)\n        this.roofGroup.scale.setScalar(TILESIZE)\n        this.roofGroup.visible = false // keep roof hidden unless switched to other camera\n        if (DEV_MODE) this.floorGroup.add(new AxesHelper())\n    }\n\n    getSurfaceFromWorld(worldPosition: Vector3): Surface | null {\n        return this.getSurfaceFromWorldXZ(worldPosition.x, worldPosition.z)\n    }\n\n    getSurfaceFromWorld2D(worldPosition: Vector2): Surface | null {\n        return this.getSurfaceFromWorldXZ(worldPosition.x, worldPosition.y)\n    }\n\n    getSurfaceFromWorldXZ(worldX: number, worldZ: number): Surface | null {\n        return this.getSurface(worldX / TILESIZE, worldZ / TILESIZE)\n    }\n\n    getSurface(x, y): Surface {\n        x = Math.floor(x)\n        y = Math.floor(y)\n        return this.getSurfaceOrNull(x, y) || new Surface(this, SurfaceType.SOLID_ROCK, x, y, 0)\n    }\n\n    getSurfaceOrNull(x, y): Surface | null {\n        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {\n            return this.surfaces[x][y]\n        } else {\n            return null\n        }\n    }\n\n    updateSurfaceMeshes(force: boolean = false) {\n        this.forEachSurface((s) => s.updateMesh(force))\n        this.floorGroup.updateWorldMatrix(true, true) // otherwise ray intersection is not working before rendering\n        this.resetGraphWalk()\n    }\n\n    resetGraphWalk() {\n        this.graphWalk.init()\n        this.cachedPaths.clear()\n        console.log('Cached paths cleared')\n    }\n\n    findPath(start: Vector2, target: PathTarget): TerrainPath {\n        const end = target.targetLocation\n        const gridStartX = Math.floor(start.x * 3 / TILESIZE)\n        const gridStartY = Math.floor(start.y * 3 / TILESIZE)\n        const gridEndX = Math.floor(end.x * 3 / TILESIZE)\n        const gridEndY = Math.floor(end.y * 3 / TILESIZE)\n        if (gridStartX === gridEndX && gridStartY === gridEndY) {\n            return new TerrainPath(target, end)\n        }\n        const cacheIdentifier = gridStartX + '/' + gridStartY + ' -> ' + gridEndX + '/' + gridEndY\n        const cachedPath = this.cachedPaths.get(cacheIdentifier)\n        if (cachedPath) {\n            return cachedPath.addLocation(end)\n        } else {\n            return this.searchPath(gridStartX, gridStartY, gridEndX, gridEndY, target, cacheIdentifier)\n        }\n    }\n\n    private searchPath(gridStartX: number, gridStartY: number, gridEndX: number, gridEndY: number, target: PathTarget, cacheIdentifier: string): TerrainPath {\n        const startNode = this.graphWalk.grid[gridStartX][gridStartY]\n        const endNode = this.graphWalk.grid[gridEndX][gridEndY]\n        const worldPath = astar.search(this.graphWalk, startNode, endNode)\n            .map((n) => Terrain.gridNodeToWorldPos(n))\n        if (worldPath.length < 1) return null // no path found\n        // replace last surface center with actual target position\n        worldPath.pop()\n        worldPath.push(target.targetLocation)\n        this.cachedPaths.set(cacheIdentifier, new TerrainPath(target, worldPath.slice(0, -1))) // cache shallow copy to avoid interference\n        return new TerrainPath(target, worldPath)\n    }\n\n    private static gridNodeToWorldPos(gridNode) {\n        return new Vector2(Math.random(), Math.random()).divideScalar(2).add(gridNode).multiplyScalar(TILESIZE / 3)\n    }\n\n    findFallInOrigin(x: number, y: number): [number, number] {\n        const leftSurface = this.getSurface(x - 1, y)\n        if (leftSurface.isReinforcable()) return [leftSurface.x, leftSurface.y]\n        const topSurface = this.getSurface(x, y - 1)\n        if (topSurface.isReinforcable()) return [topSurface.x, topSurface.y]\n        const rightSurface = this.getSurface(x + 1, y)\n        if (rightSurface.isReinforcable()) return [rightSurface.x, rightSurface.y]\n        const bottomSurface = this.getSurface(x, y + 1)\n        if (bottomSurface.isReinforcable()) return [bottomSurface.x, bottomSurface.y]\n        const leftSurface2 = this.getSurface(x - 1, y)\n        if (leftSurface2.isDigable()) return [leftSurface2.x, leftSurface2.y]\n        const topSurface2 = this.getSurface(x, y - 1)\n        if (topSurface2.isDigable()) return [topSurface2.x, topSurface2.y]\n        const rightSurface2 = this.getSurface(x + 1, y)\n        if (rightSurface2.isDigable()) return [rightSurface2.x, rightSurface2.y]\n        const bottomSurface2 = this.getSurface(x, y + 1)\n        if (bottomSurface2.isDigable()) return [bottomSurface2.x, bottomSurface2.y]\n        return null\n    }\n\n    findFallInTarget(x: number, y: number): [number, number] {\n        const leftSurface = this.getSurface(x - 1, y)\n        if (leftSurface.isWalkable()) return [leftSurface.x, leftSurface.y]\n        const topSurface = this.getSurface(x, y - 1)\n        if (topSurface.isWalkable()) return [topSurface.x, topSurface.y]\n        const rightSurface = this.getSurface(x + 1, y)\n        if (rightSurface.isWalkable()) return [rightSurface.x, rightSurface.y]\n        const bottomSurface = this.getSurface(x, y + 1)\n        if (bottomSurface.isWalkable()) return [bottomSurface.x, bottomSurface.y]\n        return null\n    }\n\n    dispose() {\n        this.forEachSurface(s => s.dispose())\n    }\n\n    forEachSurface(each: (surface: Surface) => any) {\n        this.surfaces?.forEach((r) => r.forEach((s) => each(s)))\n    }\n\n    countDiggables(): number {\n        let totalDiggables = 0\n        this.forEachSurface((s) => totalDiggables += s.isDigable() ? 1 : 0)\n        return totalDiggables\n    }\n\n    countCrystals(): number {\n        let totalCrystals = 0\n        this.forEachSurface((s) => totalCrystals += s.containedCrystals)\n        return totalCrystals\n    }\n\n    countOres(): number {\n        let totalOres = 0\n        this.forEachSurface((s) => totalOres += s.containedOres)\n        return totalOres\n    }\n\n}\n","import { AmbientLight, AudioListener, Color, Frustum, Mesh, MOUSE, PerspectiveCamera, PointLight, Raycaster, Scene, Vector2, Vector3, WebGLRenderer } from 'three'\nimport { MapControls } from 'three/examples/jsm/controls/OrbitControls'\nimport { LevelEntryCfg } from '../cfg/LevelsCfg'\nimport { clearIntervalSafe } from '../core/Util'\nimport { EventBus } from '../event/EventBus'\nimport { EventKey } from '../event/EventKeyEnum'\nimport { TILESIZE } from '../params'\nimport { AnimatedMesh } from '../resource/AnimatedMesh'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { DebugHelper } from '../screen/DebugHelper'\nimport { BuildPlacementMarker } from './model/building/BuildPlacementMarker'\nimport { GameState } from './model/GameState'\nimport { Terrain } from './model/map/Terrain'\nimport { Selectable } from './model/Selectable'\nimport { TerrainLoader } from './TerrainLoader'\nimport { WorldManager } from './WorldManager'\n\nexport class SceneManager {\n\n    static meshRegistry: AnimatedMesh[] = []\n\n    maxFps: number = 30 // most animations use 25 fps so this should be enough\n    renderer: WebGLRenderer\n    debugHelper: DebugHelper = new DebugHelper()\n    renderInterval\n    animRequest\n    scene: Scene\n    listener: AudioListener\n    camera: PerspectiveCamera\n    ambientLight: AmbientLight\n    light: PointLight\n    terrain: Terrain\n    controls: MapControls\n    cursorTorchlight: PointLight\n    buildMarker: BuildPlacementMarker\n\n    constructor(canvas: SpriteImage) {\n        this.renderer = new WebGLRenderer({antialias: true, canvas: canvas})\n        this.renderer.setClearColor(0x000000)\n\n        this.listener = new AudioListener()\n\n        this.camera = new PerspectiveCamera(30, canvas.width / canvas.height, 0.1, 5000) // TODO make these params configurable\n        this.camera.add(this.listener)\n\n        this.controls = new MapControls(this.camera, this.renderer.domElement)\n        this.controls.mouseButtons = {LEFT: null, MIDDLE: MOUSE.ROTATE, RIGHT: MOUSE.PAN}\n        // this.controls.maxPolarAngle = Math.PI * 0.45; // TODO dynamically adapt to terrain height at camera position\n        this.controls.listenToKeyEvents(this.renderer.domElement)\n        this.controls.keyPanSpeed = this.controls.keyPanSpeed * 20\n\n        this.buildMarker = new BuildPlacementMarker(this)\n        EventBus.registerEventListener(EventKey.COMMAND_CANCEL_BUILD_MODE, () => {\n            GameState.buildModeSelection = null // TODO dispose build mode selection first\n            this.buildMarker.hideAllMarker()\n        })\n    }\n\n    selectEntitiesByRay(rx: number, ry: number) {\n        const raycaster = new Raycaster()\n        raycaster.setFromCamera({x: rx, y: ry}, this.camera)\n        let intersects = raycaster.intersectObjects(GameState.raiders.map((r) => r.pickSphere))\n        if (intersects.length < 1) intersects = raycaster.intersectObjects(GameState.buildings.map((b) => b.pickSphere))\n        if (intersects.length < 1 && this.terrain) intersects = raycaster.intersectObjects(this.terrain.floorGroup.children)\n        const selected = []\n        if (intersects.length > 0) {\n            const userData = intersects[0].object.userData\n            if (userData && userData.hasOwnProperty('selectable')) {\n                const selectable = userData['selectable']\n                if (selectable) selected.push(selectable)\n            }\n        }\n        GameState.selectEntities(selected)\n    }\n\n    selectEntitiesInFrustum(r1x: number, r1y: number, r2x: number, r2y: number) {\n        const startPoint = new Vector3(r1x, r1y, 0.5)\n        const endPoint = new Vector3(r2x, r2y, 0.5)\n        // Avoid invalid frustum\n        if (startPoint.x === endPoint.x) {\n            endPoint.x += Number.EPSILON\n        }\n        if (startPoint.y === endPoint.y) {\n            endPoint.y += Number.EPSILON\n        }\n        // update camera\n        this.camera.updateProjectionMatrix()\n        this.camera.updateMatrixWorld()\n        // update frustum\n        const tmpPoint = new Vector3()\n        tmpPoint.copy(startPoint)\n        tmpPoint.x = Math.min(startPoint.x, endPoint.x)\n        tmpPoint.y = Math.max(startPoint.y, endPoint.y)\n        endPoint.x = Math.max(startPoint.x, endPoint.x)\n        endPoint.y = Math.min(startPoint.y, endPoint.y)\n\n        const vecNear = new Vector3()\n        const vecTopLeft = new Vector3()\n        const vecTopRight = new Vector3()\n        const vecDownRight = new Vector3()\n        const vecDownLeft = new Vector3()\n        vecNear.setFromMatrixPosition(this.camera.matrixWorld)\n        vecTopLeft.copy(tmpPoint)\n        vecTopRight.set(endPoint.x, tmpPoint.y, 0)\n        vecDownRight.copy(endPoint)\n        vecDownLeft.set(tmpPoint.x, endPoint.y, 0)\n\n        vecTopLeft.unproject(this.camera)\n        vecTopRight.unproject(this.camera)\n        vecDownRight.unproject(this.camera)\n        vecDownLeft.unproject(this.camera)\n\n        const vectemp1 = new Vector3()\n        const vectemp2 = new Vector3()\n        const vectemp3 = new Vector3()\n        vectemp1.copy(vecTopLeft).sub(vecNear)\n        vectemp2.copy(vecTopRight).sub(vecNear)\n        vectemp3.copy(vecDownRight).sub(vecNear)\n        vectemp1.normalize()\n        vectemp2.normalize()\n        vectemp3.normalize()\n\n        const deep = Number.MAX_VALUE\n        vectemp1.multiplyScalar(deep)\n        vectemp2.multiplyScalar(deep)\n        vectemp3.multiplyScalar(deep)\n        vectemp1.add(vecNear)\n        vectemp2.add(vecNear)\n        vectemp3.add(vecNear)\n\n        const frustum = new Frustum()\n        const planes = frustum.planes\n\n        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight)\n        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight)\n        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear)\n        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear)\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft)\n        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1)\n        planes[5].normal.multiplyScalar(-1)\n\n        let entities: Selectable[] = GameState.raiders.filter((r) => frustum.containsPoint(r.getSelectionCenter()))\n        if (entities.length < 1) {\n            const firstBuilding = GameState.buildings.find((b) => frustum.containsPoint(b.getSelectionCenter()))\n            entities = firstBuilding ? [firstBuilding] : []\n        }\n        GameState.selectEntities(entities)\n    }\n\n    setupScene(levelConf: LevelEntryCfg, worldMgr: WorldManager) {\n        this.scene = new Scene()\n\n        const ambientRgb = ResourceManager.cfg('Main', 'AmbientRGB') || [10, 10, 10]\n        const maxAmbRgb = Math.min(255, Math.max(0, ...ambientRgb))\n        const normalizedRgb = ambientRgb.map(v => v / (maxAmbRgb ? maxAmbRgb : 1))\n        const ambientColor = new Color(normalizedRgb[0], normalizedRgb[1], normalizedRgb[2])\n        this.ambientLight = new AmbientLight(ambientColor, 0.4)\n        this.scene.add(this.ambientLight)\n\n        this.cursorTorchlight = new PointLight(0xffffff, 1.5, 4, 1)\n        this.cursorTorchlight.distance *= TILESIZE\n        this.scene.add(this.cursorTorchlight)\n\n        this.scene.add(this.buildMarker.group)\n\n        // create terrain mesh and add it to the scene\n        this.terrain = TerrainLoader.loadTerrain(levelConf, worldMgr, this)\n        this.scene.add(this.terrain.floorGroup)\n\n        // gather level start details for game result score calculation\n        GameState.totalDiggables = this.terrain.countDiggables()\n        GameState.totalCrystals = this.terrain.countCrystals()\n        GameState.totalOres = this.terrain.countOres()\n    }\n\n    startScene() {\n        this.debugHelper.show()\n        this.renderInterval = setInterval(() => {\n            this.animRequest = requestAnimationFrame(() => {\n                this.debugHelper.renderStart()\n                this.renderer.render(this.scene, this.camera)\n                this.debugHelper.renderDone()\n            })\n        }, 1000 / this.maxFps)\n    }\n\n    disposeScene() {\n        this.debugHelper.hide()\n        this.renderInterval = clearIntervalSafe(this.renderInterval)\n        if (this.animRequest) {\n            cancelAnimationFrame(this.animRequest)\n            this.animRequest = null\n        }\n        GameState.remainingDiggables = this.terrain?.countDiggables() || 0\n        this.terrain?.dispose()\n        this.terrain = null\n        SceneManager.meshRegistry.forEach(mesh => mesh.dispose())\n        SceneManager.meshRegistry = []\n    }\n\n    static registerMesh(animatedMesh: AnimatedMesh): Mesh {\n        this.meshRegistry.push(animatedMesh)\n        return animatedMesh.mesh\n    }\n\n    resize(width: number, height: number) {\n        this.renderer.setSize(width, height)\n    }\n\n    getTerrainIntersectionPoint(rx: number, ry: number): Vector2 {\n        if (!this.terrain) return null\n        const raycaster = new Raycaster()\n        raycaster.setFromCamera({x: rx, y: ry}, this.camera)\n        const intersects = raycaster.intersectObjects(this.terrain.floorGroup.children)\n        return intersects.length > 0 ? new Vector2(intersects[0].point.x, intersects[0].point.z) : null\n    }\n\n    setTorchPosition(position: Vector2) {\n        this.cursorTorchlight.position.copy(this.getFloorPosition(position))\n        this.cursorTorchlight.position.y += 2 * TILESIZE\n    }\n\n    getFloorPosition(world: Vector2) {\n        const floorY = this.terrain.getSurfaceFromWorldXZ(world.x, world.y).getFloorHeight(world.x, world.y)\n        return new Vector3(world.x, floorY, world.y)\n    }\n\n    getTerrainHeight(worldX: number, worldZ: number): number {\n        const raycaster = new Raycaster(new Vector3(Number(worldX), 3 * TILESIZE, Number(worldZ)), new Vector3(0, -1, 0))\n        const intersect = raycaster.intersectObject(this.terrain.floorGroup, true)\n        if (intersect.length > 0) {\n            return intersect[0].point.y\n        } else {\n            console.warn('could not determine terrain height for ' + worldX + '/' + worldZ)\n            return 0\n        }\n    }\n\n}\n","export class InitLoadingMessage {\n\n    wad0FileUrl: string\n    wad1FileUrl: string\n\n    constructor(wad0FileUrl: string, wad1FileUrl: string) {\n        this.wad0FileUrl = wad0FileUrl\n        this.wad1FileUrl = wad1FileUrl\n    }\n\n}\n","export enum MoveState {\n\n    MOVED,\n    TARGET_REACHED,\n    TARGET_UNREACHABLE,\n\n}\n","import { RepeatWrapping, Texture } from 'three'\nimport { createDummyImgData } from '../core/ImageHelper'\nimport { getFilename } from '../core/Util'\nimport { AnimationEntityType } from '../game/model/anim/AnimationEntityType'\nimport { AnimEntityLoader } from './AnimEntityLoader'\nimport { ResourceCache } from './ResourceCache'\nimport { InitLoadingMessage } from './wadworker/InitLoadingMessage'\nimport { WadWorkerMessage } from './wadworker/WadWorkerMessage'\nimport { WorkerMessageType } from './wadworker/WorkerMessageType'\n\nexport class ResourceManager extends ResourceCache { // TODO rename to WadResourceManager\n\n    static worker: Worker = new Worker(new URL('./wadworker/WadWorker', import.meta.url))\n\n    static startLoadingFromCache() {\n        return this.startLoading(null)\n    }\n\n    static startLoadingFromUrl(wad0Url: string, wad1Url: string) {\n        return this.startLoading(new InitLoadingMessage(wad0Url, wad1Url))\n    }\n\n    private static startLoading(msg: InitLoadingMessage) {\n        this.worker.onmessage = (event) => {\n            const msg: WadWorkerMessage = event.data\n            if (msg.type === WorkerMessageType.ASSET) {\n                msg.assetNames.forEach((assetName) => this.resourceByName.set(assetName.toLowerCase(), msg.assetObj))\n                msg.sfxKeys?.forEach((sfxKey) => this.sfxByKey.set(sfxKey, msg.assetObj))\n                this.onAssetLoaded()\n            } else if (msg.type === WorkerMessageType.MSG) {\n                this.onMessage(msg.text)\n            } else if (msg.type === WorkerMessageType.CFG) {\n                this.configuration = msg.cfg\n                this.stats = msg.stats\n                this.loadDefaultCursor()\n                this.onInitialLoad(msg.totalResources)\n            } else if (msg.type === WorkerMessageType.CACHE_MISS) {\n                this.onCacheMissed()\n            } else if (msg.type === WorkerMessageType.DONE) {\n                this.loadAllCursor()\n                console.log('Loading of about ' + msg.totalResources + ' assets complete! Total load time: ' + msg.loadingTimeSeconds + ' seconds.')\n                this.onLoadDone()\n            }\n        }\n        this.worker.postMessage(msg)\n    }\n\n    static onMessage: (msg: string) => any = (msg: string) => {\n        console.log(msg)\n    }\n\n    static onCacheMissed: () => any = () => {\n        console.log('Worker missed cache')\n    }\n\n    static onInitialLoad: (totalResources: number) => any = () => {\n        console.log('Initial loading done.')\n    }\n\n    static onAssetLoaded: () => any = () => {\n    }\n\n    static onLoadDone: () => any = () => {\n    }\n\n    static filterTextureSequenceNames(basename: string): string[] {\n        const lBasename = basename.toLowerCase()\n        const result = []\n        this.resourceByName.forEach((res, name) => {\n            if (name.startsWith(lBasename)) result.push(name)\n        })\n        if (result.length > 0) {\n            return result\n        } else if (!lBasename.startsWith('world/shared/')) {\n            return this.filterTextureSequenceNames('world/shared/' + getFilename(basename))\n        } else {\n            console.warn('Texture sequence not found: ' + basename)\n            return null\n        }\n    }\n\n    static getTexture(textureName): Texture {\n        if (!textureName || textureName.length === 0) {\n            throw 'textureName must not be undefined, null or empty - was ' + textureName\n        }\n        const lTextureName = textureName.toLowerCase()\n        const imgData = this.resourceByName.getOrUpdate(lTextureName, () => {\n            const lSharedTextureName = 'world/shared/' + getFilename(lTextureName)\n            return this.resourceByName.getOrUpdate(lSharedTextureName, () => {\n                console.warn('Texture \\'' + textureName + '\\' (' + lTextureName + ', ' + lSharedTextureName + ') unknown! Using placeholder texture instead')\n                return createDummyImgData(64, 64)\n            })\n        })\n        const texture = new Texture(imgData, Texture.DEFAULT_MAPPING, RepeatWrapping, RepeatWrapping)\n        texture.needsUpdate = true\n        return texture\n    }\n\n    static getAnimationEntityType(aeFilename: string): AnimationEntityType {\n        let cfgRoot = this.getResource(aeFilename)\n        if (!cfgRoot) throw 'Could not get animation entity type for: ' + aeFilename\n        return AnimEntityLoader.loadModels(aeFilename, cfgRoot)\n    }\n\n}\n","import { getPath, iGet } from '../core/Util'\nimport { AnimationEntityType } from '../game/model/anim/AnimationEntityType'\nimport { AnimClip } from '../game/model/anim/AnimClip'\nimport { SceneManager } from '../game/SceneManager'\nimport { LWOLoader } from './LWOLoader'\nimport { LWSCLoader } from './LWSCLoader'\nimport { ResourceManager } from './ResourceManager'\n\nexport class AnimEntityLoader {\n\n    static loadModels(url, root): AnimationEntityType {\n        const path = getPath(url)\n\n        const entityType = new AnimationEntityType()\n\n        entityType.carryNullName = iGet(root, 'CarryNullName')\n        entityType.depositNullName = iGet(root, 'DepositNullName')\n        entityType.toolNullName = iGet(root, 'ToolNullName')\n\n        // TODO load other poly quality models (if available)\n        // let mediumPoly = iGet(root, 'MediumPoly');\n        // if (mediumPoly) {\n        //     Object.keys(mediumPoly).forEach((key) => {\n        //         const polyname = mediumPoly[key];\n        //         const polykey = key.startsWith('!') ? key.slice(1) : key;\n        //         const polyfile = path + polyname + '.lwo';\n        //         console.log('polyfile');\n        //         console.log(polyfile);\n        //         // new LWOLoader().load(polyfile, (model) => {\n        //         //     mediumPoly[polykey] = {polyname: polyname, polyfile: polyfile, model: model};\n        //         // }, undefined, () => {\n        //         //     console.error('Could not load poly ' + polyname + ' from ' + polyfile);\n        //         // });\n        //     });\n        //     Object.keys(mediumPoly).filter((polykey) => polykey.startsWith('!')).forEach((polykey) => delete mediumPoly[polykey]);\n        // }\n\n        const highPoly = iGet(root, 'highpoly')\n        if (highPoly) {\n            entityType.highPoly = {}\n            Object.keys(highPoly).forEach((key) => {\n                const polyname = highPoly[key] + '.lwo'\n                const polykey = key.startsWith('!') ? key.slice(1) : key\n                const lwoBuffer = ResourceManager.getResource(path + polyname)\n                entityType.highPoly[polykey] = SceneManager.registerMesh(new LWOLoader(path).parse(lwoBuffer))\n            })\n        }\n\n        // let fPoly = (root)['fppoly'];\n        // if (fPoly) {\n        //     Object.keys(fPoly).forEach((camera) => {\n        //         Object.keys(fPoly[camera]).forEach((key) => {\n        //             const polyname = fPoly[camera][key];\n        //             const polykey = key.startsWith('!') ? key.slice(1) : key;\n        //             if (polyname !== 'null') {\n        //                 const polyfile = path + polyname + '.lwo';\n        //                 new LWOLoader().load(polyfile, (model) => {\n        //                     fPoly[camera][polykey] = {polyname: polyname, polyfile: polyfile, model: model};\n        //                 }, undefined, () => {\n        //                     console.error('Could not load poly ' + polyname + ' from ' + polyfile);\n        //                 });\n        //             } else {\n        //                 fPoly[camera][key] = {polyname: polyname, polyfile: null, model: new Group()};\n        //             }\n        //         });\n        //         Object.keys(fPoly[camera]).filter((polykey) => polykey.startsWith('!')).forEach((polykey) => delete fPoly[polykey][camera]);\n        //     });\n        // }\n\n        const activities = iGet(root, 'Activities')\n        if (activities) {\n            Object.keys(activities).forEach((activity) => {\n                try {\n                    let keyname = iGet(activities, activity)\n                    const act: { file: string, transcoef: number, lwsfile: boolean, animation: AnimClip } = iGet(root, keyname)\n                    const file = iGet(act, 'FILE')\n                    const isLws = iGet(act, 'LWSFILE') === true\n                    const transcoef = iGet(act, 'TRANSCOEF')\n                    const looping = iGet(act, 'LOOPING') === true\n                    if (isLws) {\n                        const content = ResourceManager.getResource(path + file + '.lws')\n                        act.animation = new LWSCLoader(path).parse(content)\n                        act.animation.looping = looping\n                        act.animation.transcoef = transcoef ? Number(transcoef) : 1\n                        entityType.activities.set(activity.toLowerCase(), act)\n                    } else {\n                        console.error('Found activity which is not an LWS file')\n                    }\n                } catch (e) {\n                    console.error(e)\n                    console.log(root)\n                    console.log(activities)\n                    console.log(activity)\n                }\n            })\n        }\n\n        return entityType\n    }\n\n}\n","import { BuildingEntity } from './building/BuildingEntity'\nimport { PathTarget } from './PathTarget'\n\nexport class BuildingPathTarget extends PathTarget {\n\n    building: BuildingEntity\n\n    constructor(building: BuildingEntity) {\n        super(building.getPosition2D())\n        this.building = building\n    }\n\n}\n","import { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { BarrierActivity } from '../activities/BarrierActivity'\nimport { BuildingSite } from '../building/BuildingSite'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { PriorityIdentifier } from '../job/PriorityIdentifier'\nimport { BarrierLocation } from './BarrierLocation'\nimport { BuildingCarryPathTarget, CarryPathTarget, SiteCarryPathTarget } from './CarryPathTarget'\nimport { MaterialEntity } from './MaterialEntity'\n\nexport class Barrier extends MaterialEntity {\n\n    site: BuildingSite\n    heading: number\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager, location: BarrierLocation, site: BuildingSite) {\n        super(worldMgr, sceneMgr, EntityType.BARRIER, 'MiscAnims/Barrier/Barrier.ae')\n        this.site = site\n        this.heading = location.heading\n        this.priorityIdentifier = PriorityIdentifier.aiPriorityConstruction\n        this.changeActivity()\n        this.targets = [new SiteCarryPathTarget(location.location, this.site)]\n    }\n\n    protected updateTargets(): CarryPathTarget[] {\n        if (this.site?.canceled) {\n            this.site = null\n            const closestToolstation = GameState.getClosestBuildingByType(this.getPosition(), EntityType.TOOLSTATION)\n            this.targets = [new BuildingCarryPathTarget(closestToolstation)]\n        }\n        return this.targets\n    }\n\n    getDefaultActivity(): BarrierActivity {\n        return BarrierActivity.Short\n    }\n\n    onAddToSite() {\n        super.onAddToSite()\n        this.group.rotation.y = this.heading\n        this.changeActivity(BarrierActivity.Expand, () => this.changeActivity(BarrierActivity.Long))\n    }\n\n}\n","import { ElectricFence } from '../collect/ElectricFence'\nimport { CarryJob } from './CarryJob'\n\nexport class CarryFenceJob extends CarryJob<ElectricFence> {\n\n    onJobComplete() {\n        super.onJobComplete()\n        if (this.item.targetSurface.canPlaceFence()) {\n            this.item.addToScene(null, null)\n            this.item.targetSurface.fence = this.item\n        } // TODO else dispose item entity with mesh\n    }\n\n}\n","import { LWOLoader } from '../../../resource/LWOLoader'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { CarryFenceJob } from '../job/CarryFenceJob'\nimport { PriorityIdentifier } from '../job/PriorityIdentifier'\nimport { Surface } from '../map/Surface'\nimport { BuildingCarryPathTarget, CarryPathTarget } from './CarryPathTarget'\nimport { MaterialEntity } from './MaterialEntity'\n\nexport class ElectricFence extends MaterialEntity {\n\n    targetSurface: Surface\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager, surface: Surface) {\n        super(worldMgr, sceneMgr, EntityType.ELECTRIC_FENCE)\n        const resource = ResourceManager.getResource('Buildings/E-Fence/E-Fence4.lwo')\n        const mesh = SceneManager.registerMesh(new LWOLoader('Buildings/E-Fence/').parse(resource))\n        this.group.add(mesh)\n        this.targetSurface = surface\n        this.priorityIdentifier = PriorityIdentifier.aiPriorityConstruction\n    }\n\n    protected updateTargets(): CarryPathTarget[] {\n        if (this.targets.length < 1) {\n            if (this.targetSurface.canPlaceFence()) {\n                this.targets = [new CarryPathTarget(this.targetSurface.getCenterWorld2D())]\n            } else {\n                this.targets = GameState.getBuildingsByType(...this.getTargetBuildingTypes())\n                    .map((b) => new BuildingCarryPathTarget(b))\n            }\n        } else if (!this.targetSurface.canPlaceFence() && !(this.targets[0] as BuildingCarryPathTarget).building) {\n            this.targets = GameState.getBuildingsByType(...this.getTargetBuildingTypes())\n                .map((b) => new BuildingCarryPathTarget(b))\n        }\n        return this.targets\n    }\n\n    createCarryJob(): CarryFenceJob {\n        return new CarryFenceJob(this)\n    }\n\n}\n","import { Matrix4, PositionalAudio, Vector2, Vector3 } from 'three'\nimport { Sample } from '../../../audio/Sample'\nimport { SoundManager } from '../../../audio/SoundManager'\nimport { BuildingEntityStats } from '../../../cfg/BuildingEntityStats'\nimport { EventBus } from '../../../event/EventBus'\nimport { EventKey } from '../../../event/EventKeyEnum'\nimport { BuildingsChangedEvent, SelectionChanged } from '../../../event/LocalEvents'\nimport { MaterialAmountChanged } from '../../../event/WorldEvents'\nimport { TILESIZE } from '../../../params'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { AnimEntityActivity } from '../activities/AnimEntityActivity'\nimport { BuildingActivity } from '../activities/BuildingActivity'\nimport { RaiderActivity } from '../activities/RaiderActivity'\nimport { AnimEntity } from '../anim/AnimEntity'\nimport { BuildingPathTarget } from '../BuildingPathTarget'\nimport { Barrier } from '../collect/Barrier'\nimport { BarrierLocation } from '../collect/BarrierLocation'\nimport { Crystal } from '../collect/Crystal'\nimport { ElectricFence } from '../collect/ElectricFence'\nimport { Ore } from '../collect/Ore'\nimport { EntitySuperType, EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { Surface } from '../map/Surface'\nimport { SurfaceType } from '../map/SurfaceType'\nimport { PathTarget } from '../PathTarget'\nimport { Selectable, SelectionType } from '../Selectable'\nimport { BuildingSite } from './BuildingSite'\n\nexport abstract class BuildingEntity extends AnimEntity implements Selectable {\n\n    blocksPathSurface: boolean = true\n    secondaryBuildingPart: Vector2 = null\n    primaryPowerPath: Vector2 = new Vector2(0, 1)\n    secondaryPowerPath: Vector2 = null\n    waterPathSurface: Vector2 = null\n\n    selected: boolean\n    powerSwitch: boolean = true\n    spawning: boolean = false\n    primarySurface: Surface = null\n    secondarySurface: Surface = null\n    primaryPathSurface: Surface = null\n    secondaryPathSurface: Surface = null\n    upgradeCostOre: number = 0\n    upgradeCostBrick: number = 0\n    crystalsInUse: number = 0\n    inBeam: boolean = false\n    pathTarget: BuildingPathTarget = null\n    engineSound: PositionalAudio\n\n    protected constructor(worldMgr: WorldManager, sceneMgr: SceneManager, entityType: EntityType, aeFilename: string) {\n        super(worldMgr, sceneMgr, EntitySuperType.BUILDING, entityType, aeFilename)\n        this.group.applyMatrix4(new Matrix4().makeScale(-1, 1, 1))\n        this.group.userData = {'selectable': this}\n        this.upgradeCostOre = ResourceManager.cfg('Main', 'BuildingUpgradeCostOre')\n        this.upgradeCostBrick = ResourceManager.cfg('Main', 'BuildingUpgradeCostStuds')\n        EventBus.registerEventListener(EventKey.MATERIAL_AMOUNT_CHANGED, () => {\n            if (this.powerSwitch) this.turnOnPower()\n        })\n    }\n\n    abstract get stats(): BuildingEntityStats\n\n    getSelectionType(): SelectionType {\n        return SelectionType.BUILDING\n    }\n\n    select(): boolean {\n        if (this.selected || this.inBeam) return false\n        this.selectionFrame.visible = true\n        this.selected = true\n        SoundManager.playSample(Sample.SFX_Okay)\n        return true\n    }\n\n    deselect() {\n        this.selectionFrame.visible = false\n        this.selected = false\n    }\n\n    getSelectionCenter(): Vector3 {\n        return this.pickSphere ? new Vector3().copy(this.pickSphere.position).applyMatrix4(this.group.matrixWorld) : null\n    }\n\n    getPickSphereCenter(): Vector3 {\n        return new Vector3(0, this.stats.PickSphere / 4, 0)\n    }\n\n    getDropPosition2D(): Vector2 {\n        if (this.getToolJoint) {\n            const worldPos = new Vector3()\n            this.getToolJoint.getWorldPosition(worldPos)\n            return new Vector2(worldPos.x, worldPos.z)\n        } else if (this.depositJoint) {\n            const worldPos = new Vector3()\n            this.depositJoint.getWorldPosition(worldPos)\n            return new Vector2(worldPos.x, worldPos.z)\n        } else {\n            return this.getPosition2D()\n        }\n    }\n\n    getDropPosition(): Vector3 {\n        return this.sceneMgr.getFloorPosition(this.getDropPosition2D())\n    }\n\n    isUsable(): boolean {\n        return !this.inBeam && this.powerSwitch && (this.isPowered() || this.stats.PowerBuilding)\n    }\n\n    isPowered(): boolean {\n        return this.stats.SelfPowered || this.crystalsInUse > 0\n    }\n\n    onDiscover() {\n        super.onDiscover()\n        GameState.buildingsUndiscovered.remove(this)\n        GameState.buildings.push(this)\n        EventBus.publishEvent(new BuildingsChangedEvent())\n    }\n\n    hasMaxLevel(): boolean {\n        return this.level >= this.stats.Levels - 1\n    }\n\n    upgrade() {\n        if (!this.canUpgrade()) return\n        if (GameState.numBrick >= this.upgradeCostBrick) {\n            GameState.numBrick -= this.upgradeCostBrick\n        } else {\n            GameState.numOre -= this.upgradeCostOre\n        }\n        EventBus.publishEvent(new MaterialAmountChanged())\n        this.level++\n        EventBus.publishEvent(new SelectionChanged())\n        EventBus.publishEvent(new BuildingsChangedEvent())\n        // TODO add sparkly upgrade animation\n    }\n\n    getDefaultActivity(): BuildingActivity {\n        return !this.isPowered() ? BuildingActivity.Unpowered : AnimEntityActivity.Stand\n    }\n\n    beamUp() {\n        GameState.usedCrystals -= this.crystalsInUse\n        this.crystalsInUse = 0\n        this.inBeam = true\n        for (let c = 0; c < this.stats.CostOre; c++) {\n            this.worldMgr.placeMaterial(new Ore(this.worldMgr, this.sceneMgr), this.primarySurface.getRandomPosition())\n        }\n        for (let c = 0; c < this.stats.CostCrystal; c++) {\n            this.worldMgr.placeMaterial(new Crystal(this.worldMgr, this.sceneMgr), this.primarySurface.getRandomPosition())\n        }\n        this.surfaces.forEach((s) => s.setBuilding(null))\n        this.pathTarget = null\n        super.beamUp()\n        EventBus.publishEvent(new BuildingsChangedEvent())\n    }\n\n    removeFromScene() {\n        super.removeFromScene()\n        GameState.buildings.remove(this)\n    }\n\n    canUpgrade() {\n        return !this.hasMaxLevel() && (GameState.numOre >= this.upgradeCostOre || GameState.numBrick >= this.upgradeCostBrick)\n    }\n\n    spawnMaterials(type: EntityType, quantity: number) {\n        const material = []\n        if (type === EntityType.CRYSTAL) {\n            while (GameState.numCrystal > 0 && material.length < quantity) {\n                GameState.numCrystal--\n                material.push(new Crystal(this.worldMgr, this.sceneMgr))\n            }\n        } else if (type === EntityType.ORE) {\n            while (GameState.numOre > 0 && material.length < quantity) {\n                GameState.numOre--\n                material.push(new Ore(this.worldMgr, this.sceneMgr))\n            }\n        } else {\n            console.error('Material drop not implemented for: ' + type)\n        }\n        if (material.length > 0) EventBus.publishEvent(new MaterialAmountChanged())\n        material.forEach((m) => this.worldMgr.placeMaterial(m, this.getDropPosition2D()))\n    }\n\n    spawnBarriers(barrierLocations: BarrierLocation[], site: BuildingSite) {\n        barrierLocations.map((l) => new Barrier(this.worldMgr, this.sceneMgr, l, site)).forEach((b) => this.worldMgr.placeMaterial(b, this.getDropPosition2D()))\n    }\n\n    spawnFence(targetSurface: Surface) {\n        this.worldMgr.placeMaterial(new ElectricFence(this.worldMgr, this.sceneMgr, targetSurface), this.getDropPosition2D())\n    }\n\n    turnOnPower() {\n        if (this.crystalsInUse > 0 || GameState.usedCrystals >= GameState.numCrystal || (this.entityType !== EntityType.POWER_STATION && !this.surfaces.some((s) => s.neighbors.some((n) => n.hasPower)))) return\n        this.crystalsInUse = 1\n        GameState.usedCrystals += this.crystalsInUse\n        this.surfaces.forEach((s) => s.setHasPower(true, true))\n        this.changeActivity()\n        EventBus.publishEvent(new BuildingsChangedEvent())\n        this.engineSound = this.playPositionalSfxName(this.stats.EngineSound, true)\n    }\n\n    turnOffPower() {\n        if (this.crystalsInUse < 1) return\n        GameState.usedCrystals -= this.crystalsInUse\n        this.crystalsInUse = 0\n        this.surfaces.forEach((s) => s.setHasPower(false, false))\n        this.changeActivity()\n        EventBus.publishEvent(new BuildingsChangedEvent())\n        this.engineSound?.stop()\n        this.engineSound = null\n    }\n\n    get surfaces(): Surface[] { // TODO performance cache this in member variable\n        const result = []\n        if (this.primarySurface) result.push(this.primarySurface)\n        if (this.secondarySurface) result.push(this.secondarySurface)\n        if (this.primaryPathSurface) result.push(this.primaryPathSurface)\n        if (this.secondaryPathSurface) result.push(this.secondaryPathSurface)\n        return result\n    }\n\n    placeDown(worldPosition: Vector2, radHeading: number, disableTeleportIn: boolean) {\n        this.primarySurface = this.sceneMgr.terrain.getSurfaceFromWorld2D(worldPosition)\n        this.primarySurface.setBuilding(this)\n        if (this.secondaryBuildingPart) {\n            const secondaryOffset = new Vector2(TILESIZE * this.secondaryBuildingPart.x, TILESIZE * this.secondaryBuildingPart.y)\n                .rotateAround(new Vector2(0, 0), -radHeading).add(worldPosition)\n            this.secondarySurface = this.sceneMgr.terrain.getSurfaceFromWorld2D(secondaryOffset)\n            this.secondarySurface.setBuilding(this)\n        }\n        if (this.primaryPowerPath) {\n            const pathOffset = new Vector2(this.primaryPowerPath.x, this.primaryPowerPath.y).multiplyScalar(TILESIZE)\n                .rotateAround(new Vector2(0, 0), -radHeading).add(worldPosition)\n            this.primaryPathSurface = this.sceneMgr.terrain.getSurfaceFromWorld2D(pathOffset)\n            this.primaryPathSurface.setSurfaceTypeAndUpdateNeighbors(SurfaceType.POWER_PATH_BUILDING)\n        }\n        this.addToScene(worldPosition, radHeading)\n        this.createPickSphere()\n        if (this.group.visible) {\n            GameState.buildings.push(this)\n        } else {\n            GameState.buildingsUndiscovered.push(this)\n        }\n        if (this.group.visible && !disableTeleportIn) {\n            this.inBeam = true\n            this.changeActivity(BuildingActivity.Teleport, () => {\n                this.inBeam = false\n                this.onPlaceDown()\n            })\n        } else {\n            this.onPlaceDown()\n        }\n        this.sceneMgr.terrain.resetGraphWalk()\n    }\n\n    private onPlaceDown() {\n        this.changeActivity()\n        this.turnOnPower()\n        EventBus.publishEvent(new BuildingsChangedEvent())\n    }\n\n    getDropAction(): RaiderActivity {\n        return RaiderActivity.Place\n    }\n\n    getTrainingTargets() {\n        return [new Vector2(-1, 0), new Vector2(0, 1), new Vector2(1, 0), new Vector2(0, -1)]\n            .map((v) => new PathTarget(v.multiplyScalar(TILESIZE / 2).add(this.primarySurface.getCenterWorld2D())))\n    }\n\n    addToScene(worldPosition: Vector2, radHeading: number) {\n        super.addToScene(worldPosition, radHeading)\n        this.pathTarget = new BuildingPathTarget(this)\n    }\n\n    getPathTarget(): BuildingPathTarget {\n        return this.pathTarget\n    }\n\n}\n","import { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class Barracks extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.BARRACKS, 'Buildings/Barracks/Barracks.ae')\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.Barracks\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class Docks extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.DOCKS, 'Buildings/Docks/Docks.ae')\n        this.primaryPowerPath = new Vector2(0, -1)\n        this.waterPathSurface = new Vector2(0, 1)\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.Docks\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class Geodome extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.GEODOME, 'Buildings/Geo-dome/Geo-dome.ae')\n        this.primaryPowerPath = null\n        this.secondaryBuildingPart = new Vector2(0, 1)\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.Geodome\n    }\n\n}\n","import { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { BuildingActivity } from '../../activities/BuildingActivity'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class GunStation extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.GUNSTATION, 'Buildings/gunstation/gunstation.ae')\n        this.primaryPowerPath = null\n    }\n\n    getDefaultActivity(): BuildingActivity {\n        return BuildingActivity.Stand\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.GunStation\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { RaiderActivity } from '../../activities/RaiderActivity'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class OreRefinery extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.ORE_REFINERY, 'Buildings/OreRefinery/OreRefinery.ae')\n        this.primaryPowerPath = new Vector2(0, 2)\n        this.secondaryBuildingPart = new Vector2(0, 1)\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.OreRefinery\n    }\n\n    getDropAction(): RaiderActivity {\n        return RaiderActivity.Deposit\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { RaiderActivity } from '../../activities/RaiderActivity'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class PowerStation extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.POWER_STATION, 'Buildings/Powerstation/Powerstation.ae')\n        this.secondaryBuildingPart = new Vector2(-1, 0)\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.Powerstation\n    }\n\n    getDropAction(): RaiderActivity {\n        return RaiderActivity.Deposit\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class TeleportBig extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.TELEPORT_BIG, 'Buildings/BIGTeleport/BIGTeleport.ae')\n        this.secondaryBuildingPart = new Vector2(1, 0)\n        this.secondaryPowerPath = new Vector2(1, 1)\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.TeleportBIG\n    }\n\n}\n","import { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class TeleportPad extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.TELEPORT_PAD, 'Buildings/Teleports/Teleports.ae')\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.TeleportPad\n    }\n\n}\n","import { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class Toolstation extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.TOOLSTATION, 'Buildings/Toolstation/Toolstation.ae')\n        this.blocksPathSurface = false\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.Toolstation\n    }\n\n}\n","import { BuildingEntityStats } from '../../../../cfg/BuildingEntityStats'\nimport { ResourceManager } from '../../../../resource/ResourceManager'\nimport { SceneManager } from '../../../SceneManager'\nimport { WorldManager } from '../../../WorldManager'\nimport { EntityType } from '../../EntityType'\nimport { BuildingEntity } from '../BuildingEntity'\n\nexport class Upgrade extends BuildingEntity {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.UPGRADE, 'Buildings/Upgrade/Upgrade.ae')\n    }\n\n    get stats(): BuildingEntityStats {\n        return ResourceManager.stats.Upgrade\n    }\n\n}\n","import { EventBus } from '../../../event/EventBus'\nimport { SelectionChanged } from '../../../event/LocalEvents'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { Surface } from '../map/Surface'\nimport { SurfaceType } from '../map/SurfaceType'\nimport { BuildingSite } from './BuildingSite'\n\nexport class PowerPathBuildingSite extends BuildingSite {\n\n    constructor(surface: Surface) {\n        super(surface, null, null, null, null)\n        surface.surfaceType = SurfaceType.POWER_PATH_BUILDING_SITE\n        surface.updateTexture()\n        GameState.getClosestBuildingByType(surface.getCenterWorld(), EntityType.TOOLSTATION)?.spawnMaterials(EntityType.ORE, 2)\n        this.neededByType.set(EntityType.ORE, 2)\n        GameState.buildingSites.push(this)\n        EventBus.publishEvent(new SelectionChanged())\n    }\n\n}\n","import { RaiderActivity } from '../activities/RaiderActivity'\nimport { PathTarget } from '../PathTarget'\nimport { Job } from './Job'\nimport { JobType } from './JobType'\n\nexport class EatJob extends Job {\n\n    constructor() {\n        super(JobType.EAT)\n    }\n\n    getWorkplaces(): PathTarget[] {\n        return this.fulfiller.map((f) => new PathTarget(f.getPosition2D()))\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        // TODO implement endurance, fill eat level here\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return RaiderActivity.Eat\n    }\n\n}\n","import { BuildingEntity } from '../building/BuildingEntity'\nimport { BuildingPathTarget } from '../BuildingPathTarget'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { RaiderTool } from '../raider/RaiderTool'\nimport { Job } from './Job'\nimport { JobType } from './JobType'\n\nexport class GetToolJob extends Job {\n\n    tool: RaiderTool\n    workplaces: BuildingPathTarget[]\n\n    constructor(tool: RaiderTool, toolstation: BuildingEntity) {\n        super(JobType.GET_TOOL)\n        this.tool = tool\n        this.workplaces = toolstation ? [toolstation.getPathTarget()] : GameState.getBuildingsByType(EntityType.TOOLSTATION).map((b) => new BuildingPathTarget(b))\n    }\n\n    getWorkplaces(): BuildingPathTarget[] {\n        if (this.workplaces.some((b) => !b.building.isUsable())) {\n            this.workplaces = GameState.getBuildingsByType(EntityType.TOOLSTATION).map((b) => new BuildingPathTarget(b))\n        }\n        return this.workplaces\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        this.fulfiller.forEach((f) => f.addTool(this.tool))\n    }\n\n}\n","import { EventBus } from '../../../event/EventBus'\nimport { RaidersChangedEvent } from '../../../event/LocalEvents'\nimport { RaiderActivity } from '../activities/RaiderActivity'\nimport { BuildingEntity } from '../building/BuildingEntity'\nimport { FulfillerEntity } from '../FulfillerEntity'\nimport { GameState } from '../GameState'\nimport { PathTarget } from '../PathTarget'\nimport { RaiderTraining } from '../raider/RaiderTraining'\nimport { Job } from './Job'\nimport { JobType } from './JobType'\n\nexport class TrainJob extends Job {\n\n    training: RaiderTraining\n    building: BuildingEntity\n    workplaces: PathTarget[]\n\n    constructor(training: RaiderTraining, building: BuildingEntity) {\n        super(JobType.TRAIN)\n        this.training = training\n        this.building = building\n        this.workplaces = this.getWorkplaces()\n    }\n\n    getWorkplaces(): PathTarget[] {\n        if (!this.building?.isUsable()) {\n            this.workplaces = []\n            GameState.getTrainingSites(this.training).map((s) => s.getTrainingTargets().forEach((t) => this.workplaces.push(t)))\n        }\n        return this.workplaces\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        this.fulfiller.forEach((f) => {\n            f.addTraining(this.training)\n            EventBus.publishEvent(new RaidersChangedEvent(this.training))\n        })\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return RaiderActivity.Train\n    }\n\n    getWorkDuration(fulfiller: FulfillerEntity): number {\n        return 10000 // XXX adjust training time\n    }\n\n}\n","import { RaiderActivity } from '../activities/RaiderActivity'\nimport { BuildingEntity } from '../building/BuildingEntity'\nimport { FulfillerEntity } from '../FulfillerEntity'\nimport { PathTarget } from '../PathTarget'\nimport { Job } from './Job'\nimport { JobType } from './JobType'\n\nexport class UpgradeJob extends Job {\n\n    building: BuildingEntity\n    workplaces: PathTarget[]\n\n    constructor(building: BuildingEntity) {\n        super(JobType.TRAIN)\n        this.building = building\n        this.workplaces = building.getTrainingTargets()\n    }\n\n    getWorkplaces(): PathTarget[] {\n        return this.building.isUsable() ? this.workplaces : []\n    }\n\n    onJobComplete() {\n        super.onJobComplete()\n        this.fulfiller.forEach((f) => {\n            if (f.level < f.stats.Levels) f.level++\n        })\n    }\n\n    getWorkActivity(): RaiderActivity {\n        return RaiderActivity.Train\n    }\n\n    getWorkDuration(fulfiller: FulfillerEntity): number {\n        return 30000 // XXX adjust upgrade time\n    }\n\n}\n","import { EventBus } from '../event/EventBus'\nimport { EventKey } from '../event/EventKeyEnum'\nimport { ChangeBuildingPowerState, ChangeRaiderSpawnRequest, SelectBuildMode, SelectedRaiderPickTool, TrainRaider } from '../event/GuiCommand'\nimport { SelectionChanged } from '../event/LocalEvents'\nimport { RequestedRaidersChanged } from '../event/WorldEvents'\nimport { BuildingEntity } from './model/building/BuildingEntity'\nimport { Barracks } from './model/building/entities/Barracks'\nimport { Docks } from './model/building/entities/Docks'\nimport { Geodome } from './model/building/entities/Geodome'\nimport { GunStation } from './model/building/entities/GunStation'\nimport { OreRefinery } from './model/building/entities/OreRefinery'\nimport { PowerStation } from './model/building/entities/PowerStation'\nimport { TeleportBig } from './model/building/entities/TeleportBig'\nimport { TeleportPad } from './model/building/entities/TeleportPad'\nimport { Toolstation } from './model/building/entities/Toolstation'\nimport { Upgrade } from './model/building/entities/Upgrade'\nimport { PowerPathBuildingSite } from './model/building/PowerPathBuildingSite'\nimport { EntityType } from './model/EntityType'\nimport { GameState } from './model/GameState'\nimport { EatJob } from './model/job/EatJob'\nimport { GetToolJob } from './model/job/GetToolJob'\nimport { TrainJob } from './model/job/TrainJob'\nimport { UpgradeJob } from './model/job/UpgradeJob'\nimport { SceneManager } from './SceneManager'\nimport { WorldManager } from './WorldManager'\n\nexport class GuiManager {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        EventBus.registerEventListener(EventKey.COMMAND_PICK_TOOL, (event: SelectedRaiderPickTool) => {\n            GameState.selectedRaiders.forEach((r) => {\n                if (!r.hasTool(event.tool)) {\n                    r.setJob(new GetToolJob(event.tool, null))\n                }\n            })\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CREATE_POWER_PATH, () => {\n            new PowerPathBuildingSite(GameState.selectedSurface)\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_MAKE_RUBBLE, () => {\n            GameState.selectedSurface?.makeRubble(2)\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_PLACE_FENCE, () => {\n            const selectedSurface = GameState.selectedSurface\n            if (selectedSurface) {\n                GameState.getClosestBuildingByType(selectedSurface.getCenterWorld(), EntityType.TOOLSTATION)?.spawnFence(selectedSurface)\n            }\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CHANGE_RAIDER_SPAWN_REQUEST, (event: ChangeRaiderSpawnRequest) => {\n            if (event.increase) {\n                GameState.requestedRaiders++\n            } else {\n                GameState.requestedRaiders--\n            }\n            EventBus.publishEvent(new RequestedRaidersChanged(GameState.requestedRaiders))\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CREATE_DRILL_JOB, () => {\n            GameState.selectedSurface?.createDrillJob()\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CREATE_REINFORCE_JOB, () => {\n            GameState.selectedSurface?.createReinforceJob()\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CREATE_DYNAMITE_JOB, () => {\n            GameState.selectedSurface?.createDynamiteJob()\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CANCEL_SURFACE_JOBS, () => {\n            GameState.selectedSurface?.cancelJobs()\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CREATE_CLEAR_RUBBLE_JOB, () => {\n            GameState.selectedSurface?.createClearRubbleJob()\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_UPGRADE_BUILDING, () => {\n            GameState.selectedBuilding?.upgrade()\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_BUILDING_BEAMUP, () => {\n            GameState.selectedBuilding?.beamUp()\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CHANGE_BUILDING_POWER_STATE, (event: ChangeBuildingPowerState) => {\n            if (!event.state) {\n                GameState.selectedBuilding?.turnOffPower()\n            } else {\n                GameState.selectedBuilding?.turnOnPower()\n            }\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_RAIDER_EAT, () => {\n            GameState.selectedRaiders.forEach((r) => !r.isDriving() && r.setJob(new EatJob()))\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_RAIDER_UPGRADE, () => {\n            GameState.selectedRaiders.forEach((r) => {\n                const closestToolstation = GameState.getClosestBuildingByType(r.getPosition(), EntityType.TOOLSTATION)\n                if (closestToolstation && r.level < r.stats.Levels) {\n                    r.setJob(new UpgradeJob(closestToolstation))\n                }\n            })\n            EventBus.publishEvent(new SelectionChanged())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_RAIDER_BEAMUP, () => {\n            GameState.selectedRaiders.forEach((r) => r.beamUp())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_TRAIN_RAIDER, (event: TrainRaider) => {\n            GameState.selectedRaiders.forEach((r) => !r.hasTraining(event.training) && r.setJob(new TrainJob(event.training, null)))\n            EventBus.publishEvent(new SelectionChanged())\n            return true\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_RAIDER_DROP, () => {\n            GameState.selectedRaiders?.forEach((r) => r.dropItem())\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_SELECT_BUILD_MODE, (event: SelectBuildMode) => {\n            // TODO dispose build mode selection first\n            GameState.buildModeSelection = GuiManager.buildingFromType(event.entityType, worldMgr, sceneMgr)\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CANCEL_BUILD_MODE, () => {\n            GameState.buildModeSelection = null // TODO dispose build mode selection first\n        })\n        EventBus.registerEventListener(EventKey.COMMAND_CANCEL_CONSTRUCTION, () => {\n            GameState.selectedSurface.site?.cancelSite()\n        })\n    }\n\n    static buildingFromType(entityType: EntityType, worldMgr: WorldManager, sceneMgr: SceneManager): BuildingEntity {\n        switch (entityType) {\n            case EntityType.TOOLSTATION:\n                return new Toolstation(worldMgr, sceneMgr)\n            case EntityType.TELEPORT_PAD:\n                return new TeleportPad(worldMgr, sceneMgr)\n            case EntityType.DOCKS:\n                return new Docks(worldMgr, sceneMgr)\n            case EntityType.POWER_STATION:\n                return new PowerStation(worldMgr, sceneMgr)\n            case EntityType.BARRACKS:\n                return new Barracks(worldMgr, sceneMgr)\n            case EntityType.UPGRADE:\n                return new Upgrade(worldMgr, sceneMgr)\n            case EntityType.GEODOME:\n                return new Geodome(worldMgr, sceneMgr)\n            case EntityType.ORE_REFINERY:\n                return new OreRefinery(worldMgr, sceneMgr)\n            case EntityType.GUNSTATION:\n                return new GunStation(worldMgr, sceneMgr)\n            case EntityType.TELEPORT_BIG:\n                return new TeleportBig(worldMgr, sceneMgr)\n            default:\n                throw 'Unexpected building type: ' + EntityType[entityType]\n        }\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { PathTarget } from '../PathTarget'\nimport { Job } from './Job'\nimport { JobType } from './JobType'\n\nexport class MoveJob extends Job {\n\n    target: PathTarget[]\n\n    constructor(target: Vector2) {\n        super(JobType.MOVE)\n        this.target = [new PathTarget(target)]\n    }\n\n    getWorkplaces(): PathTarget[] {\n        return this.target\n    }\n\n}\n","import { Vector3 } from 'three'\n\nexport class EntityStep {\n\n    vec: Vector3 = null\n    targetReached: boolean = false\n\n    constructor(vec: Vector3) {\n        this.vec = vec\n    }\n\n}\n","import { Vector2, Vector3 } from 'three'\nimport { JOB_ACTION_RANGE } from '../../params'\nimport { SceneManager } from '../SceneManager'\nimport { WorldManager } from '../WorldManager'\nimport { AnimEntityActivity } from './activities/AnimEntityActivity'\nimport { AnimEntity } from './anim/AnimEntity'\nimport { EntityStep } from './EntityStep'\nimport { EntitySuperType, EntityType } from './EntityType'\nimport { TerrainPath } from './map/TerrainPath'\nimport { MoveState } from './MoveState'\nimport { PathTarget } from './PathTarget'\n\nexport abstract class MovableEntity extends AnimEntity {\n\n    currentPath: TerrainPath = null\n\n    protected constructor(worldMgr: WorldManager, sceneMgr: SceneManager, superType: EntitySuperType, entityType: EntityType, aeFilename: string) {\n        super(worldMgr, sceneMgr, superType, entityType, aeFilename)\n    }\n\n    getPosition(): Vector3 {\n        return new Vector3(this.group.position.x, this.group.position.y, this.group.position.z)\n    }\n\n    getPosition2D(): Vector2 {\n        return new Vector2(this.group.position.x, this.group.position.z)\n    }\n\n    getSpeed(): number {\n        return this.animation?.transcoef || 1\n    }\n\n    moveToClosestTarget(target: PathTarget[]): MoveState {\n        if (!target?.length) {\n            console.warn('No targets given')\n            debugger\n        }\n        if (!this.currentPath || !target.some((t) => t.targetLocation.equals(this.currentPath.target.targetLocation))) {\n            const paths = target.map((t) => this.findPathToTarget(t)).filter((p) => !!p)\n                .sort((l, r) => l.lengthSq - r.lengthSq)\n            this.currentPath = paths.length > 0 ? paths[0] : null\n            if (!this.currentPath) return MoveState.TARGET_UNREACHABLE\n        }\n        const nextLocation = this.currentPath.firstLocation\n        this.group.lookAt(new Vector3(nextLocation.x, this.group.position.y, nextLocation.y))\n        const step = this.determineStep()\n        if (step.targetReached) {\n            return MoveState.TARGET_REACHED\n        } else {\n            this.group.position.add(step.vec)\n            this.changeActivity(this.getRouteActivity()) // only change when actually moving\n            return MoveState.MOVED\n        }\n    }\n\n    abstract getRouteActivity(): AnimEntityActivity\n\n    findPathToTarget(target: PathTarget): TerrainPath {\n        return new TerrainPath(target, target.targetLocation)\n    }\n\n    determineStep(): EntityStep {\n        const step = this.getEntityStep(this.currentPath.firstLocation)\n        const stepLengthSq = step.vec.lengthSq()\n        const entitySpeed = this.getSpeed() // TODO use average speed between current and target position\n        if (this.currentPath.locations.length > 1) {\n            if (stepLengthSq < entitySpeed * entitySpeed) {\n                this.currentPath.locations.shift()\n                return this.determineStep()\n            }\n        } else if (stepLengthSq < JOB_ACTION_RANGE * JOB_ACTION_RANGE) {\n            step.targetReached = true\n        }\n        step.vec.setLength(Math.min(entitySpeed, JOB_ACTION_RANGE))\n        return step\n    }\n\n    getEntityStep(target: Vector2): EntityStep {\n        const targetWorld = this.sceneMgr.getFloorPosition(target)\n        targetWorld.y += this.floorOffset\n        return new EntityStep(targetWorld.sub(this.group.position))\n    }\n\n}\n","import { Vector2, Vector3 } from 'three'\nimport { clearIntervalSafe } from '../../core/Util'\nimport { NATIVE_FRAMERATE } from '../../params'\nimport { SceneManager } from '../SceneManager'\nimport { WorldManager } from '../WorldManager'\nimport { MaterialEntity } from './collect/MaterialEntity'\nimport { EntitySuperType, EntityType } from './EntityType'\nimport { Job } from './job/Job'\nimport { MovableEntity } from './MovableEntity'\nimport { RaiderTool } from './raider/RaiderTool'\nimport { RaiderTraining } from './raider/RaiderTraining'\nimport { Selectable, SelectionType } from './Selectable'\n\nexport abstract class FulfillerEntity extends MovableEntity implements Selectable {\n\n    selectionType: SelectionType\n    selected: boolean\n    workInterval = null\n    job: Job = null\n    followUpJob: Job = null\n    carries: MaterialEntity = null\n\n    protected constructor(worldMgr: WorldManager, sceneMgr: SceneManager, superType: EntitySuperType, entityType: EntityType, aeFilename: string, selectionType: SelectionType) {\n        super(worldMgr, sceneMgr, superType, entityType, aeFilename)\n        this.selectionType = selectionType\n        this.group.userData = {'selectable': this}\n        this.workInterval = setInterval(this.work.bind(this), 1000 / NATIVE_FRAMERATE) // TODO do not use interval, make work trigger itself (with timeout/interval) until work is done\n    }\n\n    resetWorkInterval() {\n        this.workInterval = clearIntervalSafe(this.workInterval)\n    }\n\n    abstract work()\n\n    dropItem() {\n        if (!this.carries) return\n        const position = this.getPosition()\n        if (this.carryJoint) {\n            this.carryJoint.remove(this.carries.group)\n            this.carryJoint.getWorldPosition(position)\n        }\n        this.carries.addToScene(new Vector2(position.x, position.z), null)\n        this.carries = null\n    }\n\n    pickupItem(item: MaterialEntity) {\n        this.carries = item\n        if (this.carryJoint) this.carryJoint.add(this.carries.group)\n        this.carries.group.position.set(0, 0, 0)\n    }\n\n    setJob(job: Job, followUpJob: Job = null) {\n        if (this.job !== job) this.stopJob()\n        this.job = job\n        if (this.job) this.job.assign(this)\n        this.followUpJob = followUpJob\n        if (this.followUpJob) this.followUpJob.assign(this)\n    }\n\n    stopJob() {\n        this.dropItem()\n        if (!this.job) return\n        this.job.unassign(this)\n        if (this.followUpJob) this.followUpJob.unassign(this)\n        this.job = null\n        this.followUpJob = null\n        this.changeActivity()\n    }\n\n    abstract hasTool(tool: RaiderTool)\n\n    abstract hasTraining(training: RaiderTraining)\n\n    getSelectionType(): SelectionType {\n        return this.selectionType\n    }\n\n    deselect() {\n        this.selectionFrame.visible = false\n        this.selected = false\n    }\n\n    abstract select(): boolean\n\n    abstract getSelectionCenter(): Vector3\n\n    abstract addTool(tool: RaiderTool)\n\n    abstract addTraining(skill: RaiderTraining)\n\n    abstract get stats(): FulfillerStats\n\n    removeFromScene() {\n        super.removeFromScene()\n        this.workInterval = clearIntervalSafe(this.workInterval)\n    }\n\n}\n\nexport class FulfillerStats {\n\n    Levels: number\n    HardDrillTime: number[]\n    LooseDrillTime: number[]\n    SoilDrillTime: number[]\n    SeamDrillTime: number[]\n\n}\n","import { PositionalAudio, Vector3 } from 'three'\nimport { Sample } from '../../../audio/Sample'\nimport { getRandomInclusive } from '../../../core/Util'\nimport { EventBus } from '../../../event/EventBus'\nimport { RaidersChangedEvent } from '../../../event/LocalEvents'\nimport { RaiderDiscoveredEvent } from '../../../event/WorldLocationEvent'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { BaseActivity } from '../activities/BaseActivity'\nimport { RaiderActivity } from '../activities/RaiderActivity'\nimport { EntitySuperType, EntityType } from '../EntityType'\nimport { FulfillerEntity } from '../FulfillerEntity'\nimport { GameState } from '../GameState'\nimport { JobState } from '../job/JobState'\nimport { TerrainPath } from '../map/TerrainPath'\nimport { MoveState } from '../MoveState'\nimport { PathTarget } from '../PathTarget'\nimport { SelectionType } from '../Selectable'\nimport { RaiderTool } from './RaiderTool'\nimport { RaiderTraining } from './RaiderTraining'\n\nexport class Raider extends FulfillerEntity {\n\n    tools: Map<RaiderTool, boolean> = new Map()\n    trainings: Map<RaiderTraining, boolean> = new Map()\n    slipped: boolean = false\n    workAudio: PositionalAudio\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntitySuperType.RAIDER, EntityType.PILOT, 'mini-figures/pilot/pilot.ae', SelectionType.RAIDER)\n        this.tools.set(RaiderTool.DRILL, true)\n    }\n\n    get stats() {\n        return ResourceManager.stats.Pilot\n    }\n\n    findPathToTarget(target: PathTarget): TerrainPath {\n        return this.sceneMgr.terrain.findPath(this.getPosition2D(), target)\n    }\n\n    onDiscover() {\n        super.onDiscover()\n        GameState.raidersUndiscovered.remove(this)\n        GameState.raiders.push(this)\n        EventBus.publishEvent(new RaidersChangedEvent())\n        EventBus.publishEvent(new RaiderDiscoveredEvent(this.getPosition()))\n    }\n\n    select(): boolean {\n        this.selectionFrame.visible = !this.slipped\n        if (this.selected || this.slipped) return false\n        this.selected = true\n        this.changeActivity()\n        return true\n    }\n\n    getSelectionCenter(): Vector3 {\n        return this.pickSphere ? new Vector3().copy(this.pickSphere.position).applyMatrix4(this.group.matrixWorld) : null\n    }\n\n    isDriving(): boolean {\n        return false // TODO implement vehicles\n    }\n\n    getSpeed(): number {\n        return super.getSpeed() * this.stats.RouteSpeed[this.level] * (this.isOnPath() ? this.stats.PathCoef : 1)\n    }\n\n    isOnPath(): boolean {\n        return this.sceneMgr.terrain.getSurfaceFromWorld(this.group.position).isPath()\n    }\n\n    isOnRubble() {\n        return this.sceneMgr.terrain.getSurfaceFromWorld(this.group.position).hasRubble()\n    }\n\n    getRouteActivity(): BaseActivity {\n        if (this.isOnRubble()) {\n            return !!this.carries ? RaiderActivity.CarryRubble : RaiderActivity.routeRubble\n        } else {\n            return !!this.carries ? RaiderActivity.Carry : RaiderActivity.Route\n        }\n    }\n\n    moveToClosestTarget(target: PathTarget[]): MoveState {\n        const result = super.moveToClosestTarget(target)\n        this.job.setActualWorkplace(this.currentPath?.target)\n        if (result === MoveState.MOVED) {\n            GameState.getNearbySpiders(this).some((spider) => {\n                if (this.group.position.distanceToSquared(spider.group.position) < this.radiusSq + spider.radiusSq) {\n                    this.slip()\n                    spider.onDeath()\n                    return true\n                }\n            })\n        } else if (result === MoveState.TARGET_UNREACHABLE) {\n            console.log('Entity could not move to job target, stopping job')\n            this.stopJob()\n        }\n        return result\n    }\n\n    slip() {\n        if (getRandomInclusive(0, 100) < 10) this.stopJob()\n        this.dropItem()\n        this.slipped = true\n        this.playPositionalSample(Sample.SND_Slipup) // FIXME also second parameter in LWS files for AddNullObject SFX,\n        this.changeActivity(RaiderActivity.Slip, () => {\n            this.slipped = false\n        })\n    }\n\n    work() {\n        if (!this.job || this.selected || this.slipped) return\n        if (this.job.jobState !== JobState.INCOMPLETE) {\n            this.stopJob()\n        } else {\n            const carryItem = this.job.getCarryItem()\n            if (carryItem && this.carries !== carryItem) {\n                this.dropItem()\n                if (this.moveToClosestTarget(carryItem.getPositionPathTarget())) {\n                    this.changeActivity(RaiderActivity.Collect, () => {\n                        this.pickupItem(carryItem)\n                    })\n                }\n            } else if (this.moveToClosestTarget(this.job.getWorkplaces()) === MoveState.TARGET_REACHED) {\n                if (this.job.isReadyToComplete()) {\n                    const workActivity = this.job.getWorkActivity() || this.getDefaultActivity()\n                    if (!this.workAudio && workActivity === RaiderActivity.Drill) {\n                        this.workAudio = this.playPositionalSample(Sample.SFX_Drill, true)\n                    }\n                    this.changeActivity(workActivity, () => {\n                        this.workAudio?.stop()\n                        this.workAudio = null\n                        this.completeJob()\n                    }, this.job.getWorkDuration(this))\n                } else {\n                    this.changeActivity()\n                }\n            }\n        }\n    }\n\n    private completeJob() {\n        this.job?.onJobComplete()\n        if (this.job?.jobState === JobState.INCOMPLETE) return\n        if (this.job) this.job.unassign(this)\n        this.job = this.followUpJob\n        this.followUpJob = null\n        this.changeActivity()\n    }\n\n    getDefaultActivity(): BaseActivity {\n        return this.carries ? RaiderActivity.CarryStand : super.getDefaultActivity()\n    }\n\n    beamUp() {\n        this.stopJob()\n        super.beamUp()\n        EventBus.publishEvent(new RaidersChangedEvent())\n    }\n\n    removeFromScene() {\n        super.removeFromScene()\n        GameState.raiders.remove(this)\n    }\n\n    hasTool(tool: RaiderTool) {\n        return !tool || this.tools.has(tool)\n    }\n\n    hasTraining(training: RaiderTraining) {\n        return !training || this.trainings.has(training)\n    }\n\n    addTool(tool: RaiderTool) {\n        this.tools.set(tool, true)\n    }\n\n    addTraining(training: RaiderTraining) {\n        this.trainings.set(training, true)\n    }\n\n}\n","import { AnimEntityActivity } from './AnimEntityActivity'\n\nexport class MonsterActivity extends AnimEntityActivity {\n\n    static Route = new MonsterActivity('Activity_Route')\n\n}\n","import { clearTimeoutSafe } from '../../../core/Util'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { MonsterActivity } from '../activities/MonsterActivity'\nimport { EntitySuperType, EntityType } from '../EntityType'\nimport { MovableEntity } from '../MovableEntity'\nimport { PathTarget } from '../PathTarget'\n\nexport abstract class Monster extends MovableEntity {\n\n    moveTimeout: NodeJS.Timeout\n    target: PathTarget[] = []\n\n    protected constructor(worldMgr: WorldManager, sceneMgr: SceneManager, entityType: EntityType, aeFilename: string) {\n        super(worldMgr, sceneMgr, EntitySuperType.MONSTER, entityType, aeFilename)\n    }\n\n    removeFromScene() {\n        super.removeFromScene()\n        this.moveTimeout = clearTimeoutSafe(this.moveTimeout)\n    }\n\n    getRouteActivity(): MonsterActivity {\n        return MonsterActivity.Route\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { getRandomInclusive } from '../../../core/Util'\nimport { NATIVE_FRAMERATE, TILESIZE } from '../../../params'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { MoveState } from '../MoveState'\nimport { PathTarget } from '../PathTarget'\nimport { Monster } from './Monster'\n\nexport class Bat extends Monster {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.BAT, 'Creatures/bat/bat.ae')\n        this.floorOffset = TILESIZE / 2\n    }\n\n    get stats() {\n        return ResourceManager.stats.Bat\n    }\n\n    startRandomMove() {\n        Bat.onMove(this)\n    }\n\n    private static onMove(bat: Bat) {\n        if (bat.target.length < 1 || bat.moveToClosestTarget(bat.target) === MoveState.TARGET_REACHED) {\n            bat.target = [bat.findTarget()]\n        }\n        bat.moveTimeout = setTimeout(() => Bat.onMove(bat), 1000 / NATIVE_FRAMERATE)\n    }\n\n    private findTarget(): PathTarget { // TODO move to nearby drilling noise, explosions or sonic blasters\n        const terrain = this.sceneMgr.terrain\n        const currentCenter = terrain.getSurfaceFromWorld(this.getPosition()).getCenterWorld()\n        for (let c = 0; c < 20; c++) {\n            const targetX = getRandomInclusive(currentCenter.x - (TILESIZE + TILESIZE / 2), currentCenter.x + TILESIZE + TILESIZE / 2)\n            const targetZ = getRandomInclusive(currentCenter.z - TILESIZE / 2, currentCenter.z + TILESIZE / 2)\n            if (terrain.getSurfaceFromWorldXZ(targetX, targetZ).surfaceType.floor) { // TODO evaluate CrossLand, CrossLava, CrossWater from stats\n                return new PathTarget(new Vector2(targetX, targetZ))\n            }\n        }\n        console.warn('Could not find a target')\n        return null\n    }\n\n    onDeath() {\n        this.removeFromScene()\n        GameState.bats.remove(this)\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { getRandom, getRandomInclusive } from '../../../core/Util'\nimport { NATIVE_FRAMERATE, TILESIZE } from '../../../params'\nimport { ResourceManager } from '../../../resource/ResourceManager'\nimport { SceneManager } from '../../SceneManager'\nimport { WorldManager } from '../../WorldManager'\nimport { EntityType } from '../EntityType'\nimport { GameState } from '../GameState'\nimport { SurfaceType } from '../map/SurfaceType'\nimport { MoveState } from '../MoveState'\nimport { PathTarget } from '../PathTarget'\nimport { Monster } from './Monster'\n\nexport class SmallSpider extends Monster {\n\n    constructor(worldMgr: WorldManager, sceneMgr: SceneManager) {\n        super(worldMgr, sceneMgr, EntityType.SMALL_SPIDER, 'Creatures/SpiderSB/SpiderSB.ae')\n        this.floorOffset = 1\n    }\n\n    get stats() {\n        return ResourceManager.stats.SmallSpider\n    }\n\n    startMoving() {\n        SmallSpider.onMove(this)\n    }\n\n    private static onMove(spider: SmallSpider) {\n        spider.surfaces.forEach((s) => GameState.spidersBySurface.getOrUpdate(s, () => []).remove(spider))\n        if (spider.target.length > 0 && spider.moveToClosestTarget(spider.target) === MoveState.MOVED) {\n            spider.surfaces.forEach((s) => GameState.spidersBySurface.getOrUpdate(s, () => []).push(spider))\n            if (!spider.sceneMgr.terrain.getSurfaceFromWorld(spider.getPosition()).surfaceType.floor) {\n                spider.onDeath()\n            } else {\n                spider.moveTimeout = setTimeout(() => SmallSpider.onMove(spider), 1000 / NATIVE_FRAMERATE)\n            }\n        } else {\n            spider.changeActivity()\n            spider.moveTimeout = setTimeout(() => {\n                spider.target = [spider.findTarget()]\n                SmallSpider.onMove(spider)\n            }, 1000 + getRandom(9000))\n        }\n    }\n\n    private findTarget(): PathTarget {\n        const terrain = this.sceneMgr.terrain\n        const currentCenter = terrain.getSurfaceFromWorld(this.getPosition()).getCenterWorld()\n        for (let c = 0; c < 20; c++) {\n            const targetX = getRandomInclusive(currentCenter.x - (TILESIZE + TILESIZE / 2), currentCenter.x + TILESIZE + TILESIZE / 2)\n            const targetZ = getRandomInclusive(currentCenter.z - TILESIZE / 2, currentCenter.z + TILESIZE / 2)\n            const surfaceType = terrain.getSurfaceFromWorldXZ(targetX, targetZ).surfaceType\n            if (surfaceType !== SurfaceType.WATER && surfaceType !== SurfaceType.LAVA) { // TODO evaluate CrossLand, CrossLava, CrossWater from stats\n                return new PathTarget(new Vector2(targetX, targetZ))\n            }\n        }\n        console.warn('Could not find a target')\n        return null\n    }\n\n    onDeath() {\n        this.removeFromScene()\n        GameState.spiders.remove(this)\n        this.surfaces.forEach((s) => GameState.spidersBySurface.getOrUpdate(s, () => []).remove(this))\n    }\n\n}\n","import { MathUtils, Vector2 } from 'three'\nimport { EventBus } from '../event/EventBus'\nimport { RaidersChangedEvent } from '../event/LocalEvents'\nimport { TILESIZE } from '../params'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { Barracks } from './model/building/entities/Barracks'\nimport { Docks } from './model/building/entities/Docks'\nimport { Geodome } from './model/building/entities/Geodome'\nimport { GunStation } from './model/building/entities/GunStation'\nimport { OreRefinery } from './model/building/entities/OreRefinery'\nimport { PowerStation } from './model/building/entities/PowerStation'\nimport { TeleportBig } from './model/building/entities/TeleportBig'\nimport { TeleportPad } from './model/building/entities/TeleportPad'\nimport { Toolstation } from './model/building/entities/Toolstation'\nimport { Upgrade } from './model/building/entities/Upgrade'\nimport { Crystal } from './model/collect/Crystal'\nimport { GameState } from './model/GameState'\nimport { Bat } from './model/monster/Bat'\nimport { SmallSpider } from './model/monster/SmallSpider'\nimport { Raider } from './model/raider/Raider'\nimport { SceneManager } from './SceneManager'\nimport { WorldManager } from './WorldManager'\nimport degToRad = MathUtils.degToRad\n\nexport class ObjectListLoader {\n\n    static loadObjectList(worldMgr: WorldManager, sceneMgr: SceneManager, objectListConf, disableStartTeleport: boolean) {\n        Object.values(objectListConf).forEach((olObject: any) => {\n            const lTypeName = olObject.type ? olObject.type.toLowerCase() : olObject.type\n            // all object positions are off by one tile, because they start at 1 not 0\n            const worldPos = new Vector2(olObject.xPos, olObject.yPos).addScalar(-1).multiplyScalar(TILESIZE) // TODO assert that world pos is over terrain otherwise drop item\n            const buildingType: string = ResourceManager.cfg('BuildingTypes', olObject.type)\n            const radHeading = degToRad(olObject.heading)\n            if (lTypeName === 'TVCamera'.toLowerCase()) {\n                console.log('Camera heading: ' + Math.round(olObject.heading % 360))\n                console.log('Camera target: ' + (olObject.xPos - 1) + '/' + (olObject.yPos - 1))\n                const cameraOffset = new Vector2(6, 0).rotateAround(new Vector2(0, 0), radHeading + Math.PI / 2)\n                const cameraPos = sceneMgr.getFloorPosition(cameraOffset.multiplyScalar(TILESIZE).add(worldPos))\n                cameraPos.y += 4 * TILESIZE\n                sceneMgr.camera.position.copy(cameraPos)\n                sceneMgr.controls.target.copy(sceneMgr.getFloorPosition(worldPos))\n                sceneMgr.controls.update()\n                sceneMgr.setTorchPosition(new Vector2(worldPos.x, worldPos.y - TILESIZE / 2))\n            } else if (lTypeName === 'Pilot'.toLowerCase()) {\n                const raider = new Raider(worldMgr, sceneMgr)\n                raider.changeActivity()\n                raider.createPickSphere()\n                raider.addToScene(worldPos, radHeading - Math.PI / 2)\n                if (raider.group.visible) {\n                    GameState.raiders.push(raider)\n                    EventBus.publishEvent(new RaidersChangedEvent())\n                } else {\n                    GameState.raidersUndiscovered.push(raider)\n                }\n            } else if (buildingType) {\n                console.log(olObject.type + ' heading: ' + Math.round(olObject.heading % 360))\n                const entity = this.createBuildingByName(buildingType, worldMgr, sceneMgr)\n                entity.placeDown(worldPos, -radHeading - Math.PI, disableStartTeleport)\n            } else if (lTypeName === 'PowerCrystal'.toLowerCase()) {\n                worldMgr.placeMaterial(new Crystal(worldMgr, sceneMgr), worldPos)\n            } else if (lTypeName === 'SmallSpider'.toLowerCase()) {\n                const spider = new SmallSpider(worldMgr, sceneMgr)\n                spider.changeActivity()\n                spider.addToScene(worldPos, radHeading)\n                GameState.spiders.push(spider)\n                spider.surfaces.forEach((s) => GameState.spidersBySurface.getOrUpdate(s, () => []).push(spider))\n                spider.startMoving()\n            } else if (lTypeName === 'Bat'.toLowerCase()) {\n                const bat = new Bat(worldMgr, sceneMgr)\n                bat.changeActivity()\n                bat.addToScene(worldPos, radHeading)\n                GameState.bats.push(bat)\n                bat.startRandomMove()\n            } else {\n                // TODO implement remaining object types\n                console.warn('Object type ' + olObject.type + ' not yet implemented')\n            }\n        })\n    }\n\n    private static createBuildingByName(buildingType: string, worldMgr: WorldManager, sceneMgr: SceneManager) {\n        const typename = buildingType.slice(buildingType.lastIndexOf('/') + 1).toLowerCase()\n        if (typename === 'toolstation') {\n            return new Toolstation(worldMgr, sceneMgr)\n        } else if (typename === 'teleports') {\n            return new TeleportPad(worldMgr, sceneMgr)\n        } else if (typename === 'docks') {\n            return new Docks(worldMgr, sceneMgr)\n        } else if (typename === 'powerstation') {\n            return new PowerStation(worldMgr, sceneMgr)\n        } else if (typename === 'barracks') {\n            return new Barracks(worldMgr, sceneMgr)\n        } else if (typename === 'upgrade') {\n            return new Upgrade(worldMgr, sceneMgr)\n        } else if (typename === 'geo-dome') {\n            return new Geodome(worldMgr, sceneMgr)\n        } else if (typename === 'orerefinery') {\n            return new OreRefinery(worldMgr, sceneMgr)\n        } else if (typename === 'gunstation') {\n            return new GunStation(worldMgr, sceneMgr)\n        } else if (typename === 'teleportbig') {\n            return new TeleportBig(worldMgr, sceneMgr)\n        } else {\n            throw 'Unknown building type: ' + typename\n        }\n    }\n\n}\n","// noinspection JSUnusedGlobalSymbols\nexport enum MOUSE_BUTTON {\n    MAIN = 0,\n    MIDDLE = 1,\n    SECONDARY = 2\n}\n\nexport enum POINTER_EVENT {\n    MOVE,\n    DOWN,\n    UP,\n}\n\nexport enum KEY_EVENT {\n    DOWN,\n    UP,\n}\n","import { clearIntervalSafe } from '../core/Util'\nimport { EventBus } from '../event/EventBus'\nimport { EventKey } from '../event/EventKeyEnum'\nimport { JobCreateEvent, JobDeleteEvent } from '../event/WorldEvents'\nimport { CHECK_CLEARRUBBLE_INTERVAL, JOB_SCHEDULE_INTERVAL } from '../params'\nimport { BuildingEntity } from './model/building/BuildingEntity'\nimport { BuildingPathTarget } from './model/BuildingPathTarget'\nimport { EntityType } from './model/EntityType'\nimport { GameState } from './model/GameState'\nimport { GetToolJob } from './model/job/GetToolJob'\nimport { PublicJob } from './model/job/Job'\nimport { JobState } from './model/job/JobState'\nimport { MoveJob } from './model/job/MoveJob'\nimport { PriorityIdentifier } from './model/job/PriorityIdentifier'\nimport { TrainJob } from './model/job/TrainJob'\nimport { Raider } from './model/raider/Raider'\nimport { WorldManager } from './WorldManager'\n\nexport class Supervisor {\n\n    worldMgr: WorldManager\n    jobs: PublicJob[] = []\n    assignInterval = null\n    checkRubbleInterval = null\n\n    constructor(worldMgr: WorldManager) {\n        this.worldMgr = worldMgr\n        EventBus.registerEventListener(EventKey.JOB_CREATE, (event: JobCreateEvent) => {\n            this.jobs.push(event.job)\n        })\n        EventBus.registerEventListener(EventKey.JOB_DELETE, (event: JobDeleteEvent) => {\n            event.job.cancel()\n        })\n    }\n\n    start() {\n        stop()\n        this.assignInterval = setInterval(this.assignJobs.bind(this), JOB_SCHEDULE_INTERVAL)\n        this.checkRubbleInterval = setInterval(this.checkUnclearedRubble.bind(this), CHECK_CLEARRUBBLE_INTERVAL)\n    }\n\n    stop() {\n        this.assignInterval = clearIntervalSafe(this.assignInterval)\n        this.checkRubbleInterval = clearIntervalSafe(this.checkRubbleInterval)\n        GameState.raiders.forEach((r) => r.resetWorkInterval())\n        GameState.raidersUndiscovered.forEach((r) => r.resetWorkInterval())\n    }\n\n    assignJobs() {\n        const availableJobs: PublicJob[] = []\n        this.jobs = this.jobs.filter((j) => {\n            const result = j.jobState === JobState.INCOMPLETE\n            if (result && j.fulfiller.length < 1 && this.worldMgr.priorityList.isEnabled(j.getPriorityIdentifier())) { // TODO don't assign jobs on hidden surfaces\n                availableJobs.push(j)\n            }\n            return result\n        })\n        availableJobs.sort((left, right) => {\n            return Math.sign(this.worldMgr.priorityList.getPriority(left) - this.worldMgr.priorityList.getPriority(right))\n        })\n        const unemployedRaider = GameState.raiders.filter((r) => !r.job)\n        availableJobs.forEach((job) => { // XXX better use estimated time to complete job as metric\n                let closestRaider: Raider = null\n                let closestRaiderIndex: number = null\n                let minDistance: number = null\n                let closestToolRaider: Raider = null\n                let closestToolRaiderIndex: number = null\n                let minToolDistance: number = null\n                let closestToolstation: BuildingEntity = null\n                const requiredTool = job.getRequiredTool()\n                let closestTrainingRaider: Raider = null\n                let closestTrainingRaiderIndex: number = null\n                let minTrainingDistance: number = null\n                let closestTrainingArea: BuildingEntity = null\n                const requiredTraining = job.getRequiredTraining()\n                unemployedRaider.forEach((raider, index) => {\n                    const hasRequiredTool = raider.hasTool(requiredTool)\n                    const hasTraining = raider.hasTraining(requiredTraining)\n                    if (hasRequiredTool && hasTraining) {\n                        const pathToJob = job.getWorkplaces().map((b) => raider.findPathToTarget(b))\n                            .filter((t) => !!t)\n                            .sort((l, r) => l.lengthSq - r.lengthSq)[0]\n                        if (pathToJob) {\n                            const dist = pathToJob.lengthSq // TODO use precalculated path to job\n                            if (minDistance === null || dist < minDistance) {\n                                closestRaider = raider\n                                closestRaiderIndex = index\n                                minDistance = dist\n                            }\n                        }\n                    } else if (!hasRequiredTool) {\n                        const pathToToolstation = GameState.getBuildingsByType(EntityType.TOOLSTATION)\n                            .map((b) => raider.findPathToTarget(b.getPathTarget()))\n                            .filter((p) => !!p)\n                            .sort((l, r) => l.lengthSq - r.lengthSq)[0]\n                        if (pathToToolstation) {\n                            const dist = pathToToolstation.lengthSq\n                            if (minToolDistance === null || dist < minToolDistance) {\n                                closestToolRaider = raider\n                                closestToolRaiderIndex = index\n                                minToolDistance = dist\n                                closestToolstation = (pathToToolstation.target as BuildingPathTarget).building\n                            }\n                        }\n                    } else {\n                        const pathToTrainingSite = GameState.getTrainingSites(requiredTraining)\n                            .map((b) => raider.findPathToTarget(b.getPathTarget()))\n                            .filter((p) => !!p)\n                            .sort((l, r) => l.lengthSq - r.lengthSq)[0]\n                        if (pathToTrainingSite) {\n                            const dist = pathToTrainingSite.lengthSq\n                            if (minTrainingDistance === null || dist < minTrainingDistance) {\n                                closestTrainingRaider = raider\n                                closestTrainingRaiderIndex = index\n                                minTrainingDistance = dist\n                                closestTrainingArea = (pathToTrainingSite.target as BuildingPathTarget).building\n                            }\n                        }\n                    }\n                })\n                if (closestRaider) {\n                    closestRaider.setJob(job)\n                    unemployedRaider.splice(closestRaiderIndex, 1)\n                } else if (closestToolRaider) {\n                    closestToolRaider.setJob(new GetToolJob(requiredTool, closestToolstation), job)\n                    unemployedRaider.splice(closestToolRaiderIndex, 1)\n                } else if (closestTrainingRaider) {\n                    closestTrainingRaider.setJob(new TrainJob(requiredTraining, closestTrainingArea), job)\n                    unemployedRaider.splice(closestTrainingRaiderIndex, 1)\n                }\n            },\n        )\n        unemployedRaider.forEach((raider) => {\n            const sites = raider.surfaces.map((s) => s.site).filter(s => !!s)\n            if (sites.length > 0) raider.setJob(new MoveJob(sites[0].getWalkOutSurface().getRandomPosition()))\n        })\n    }\n\n    checkUnclearedRubble() {\n        if (!this.worldMgr.priorityList.isEnabled(PriorityIdentifier.aiPriorityClearing)) return\n        GameState.raiders.forEach((raider) => {\n            if (raider.job) return\n            const startSurface = raider.sceneMgr.terrain.getSurfaceFromWorld(raider.getPosition())\n            for (let rad = 0; rad < 10; rad++) {\n                for (let x = startSurface.x - rad; x <= startSurface.x + rad; x++) {\n                    for (let y = startSurface.y - rad; y <= startSurface.y + rad; y++) {\n                        const surface = raider.sceneMgr.terrain.getSurfaceOrNull(x, y)\n                        if (!(surface?.hasRubble()) || !surface?.discovered) continue\n                        const clearRubbleJob = surface.createClearRubbleJob()\n                        if (!clearRubbleJob) continue\n                        const requiredTool = clearRubbleJob.getRequiredTool()\n                        if (raider.hasTool(requiredTool)) {\n                            raider.setJob(clearRubbleJob)\n                        } else {\n                            const pathToToolstation = GameState.getBuildingsByType(EntityType.TOOLSTATION)\n                                .map((b) => raider.findPathToTarget(b.getPathTarget()))\n                                .filter((p) => !!p)\n                                .sort((l, r) => l.lengthSq - r.lengthSq)[0]\n                            if (pathToToolstation) {\n                                raider.setJob(new GetToolJob(requiredTool, (pathToToolstation.target as BuildingPathTarget).building), clearRubbleJob)\n                            }\n                        }\n                    }\n                }\n            }\n        })\n    }\n\n}\n","/** Function documentation mostly copied from the following URLs\n *\n * https://kb.rockraidersunited.com/User:Jessietail/NERPs_reference\n * https://web.archive.org/web/20131206122442/http://rru-stuff.org/nerpfuncs.html\n * https://kb.rockraidersunited.com/NERPs_documentation#Labels\n *\n */\nimport { EntityType } from '../game/model/EntityType'\nimport { GameResultState, GameState } from '../game/model/GameState'\nimport { clearIntervalSafe, getRandom } from './Util'\n\n// noinspection JSUnusedGlobalSymbols,JSUnusedLocalSymbols\nexport class NerpRunner {\n\n    debug = false\n    onLevelEnd: () => any = null\n    nerpInterval: NodeJS.Timeout = null\n\n    registers = new Array(8).fill(0)\n    timers = new Array(4).fill(0)\n    scriptLines = [] // contains humand readable script strings\n    statements = [] // contains parsed statements for execution\n    macrosByName = {}\n    labelsByName = {}\n    halted = false\n    programCounter = 0\n    messages = []\n    // more state variables and switches\n    messagePermit = null\n\n    constructor(debug = false) {\n        this.debug = debug\n    }\n\n    startExecution() {\n        const that = this\n        this.nerpInterval = setInterval(() => {\n            that.execute()\n        }, 2000)\n    }\n\n    pauseExecution() {\n        this.nerpInterval = clearIntervalSafe(this.nerpInterval)\n    }\n\n    /**\n     * Internally used to validate and parse a register number.\n     * @param register\n     * @return {number}\n     */\n    checkRegister(register) {\n        const num = parseInt(register)\n        if (isNaN(num) || num < 0 || num > this.registers.length) throw new Error('Invalid register (' + register + ') provided')\n        return num\n    }\n\n    /**\n     * Internally used to validate and parse a value before setting or adding it with a register.\n     * @param value\n     * @return {number}\n     */\n    checkRegisterValue(value) {\n        const num = parseInt(value)\n        if (isNaN(num)) throw new Error('Invalid register value (' + value + ') provided')\n        return num\n    }\n\n    /**\n     * Gets the value currently stored in the given register, internally used to handle all registers with one method.\n     * @param register the register to read\n     * @return {number} returns the value currently stored in the register\n     */\n    getR(register) {\n        register = this.checkRegister(register)\n        return this.registers[register]\n    }\n\n    /**\n     * Sets the given value for the given register, internally used to handle all registers with one method.\n     * @param register the register to set\n     * @param value the value to set for the given register\n     */\n    setR(register, value) {\n        register = this.checkRegister(register)\n        value = this.checkRegisterValue(value)\n        this.registers[register] = value\n    }\n\n    /**\n     * Adds the given value to the given register, internally used to handle all registers with one method.\n     * @param register the register to add to\n     * @param value the value to add to the given register\n     */\n    addR(register, value) {\n        register = this.checkRegister(register)\n        value = this.checkRegisterValue(value)\n        this.registers[register] += value\n    }\n\n    /**\n     * Set the respective timer to the given numerical value. Units are in milliseconds.\n     * @param timer\n     * @param value\n     */\n    setTimer(timer, value) {\n        const num = parseInt(value)\n        if (isNaN(num)) throw new Error('Can\\'t set timer to NaN value: ' + value)\n        this.timers[timer] = new Date().getTime() + num\n    }\n\n    /**\n     * Gets the value of the respective timer. Units are in milliseconds.\n     * @param timer\n     * @return {number}\n     */\n    getTimer(timer) {\n        return new Date().getTime() - this.timers[timer]\n    }\n\n    /**\n     * End the level successfully and show the score screen.\n     */\n    setLevelCompleted() {\n        console.log('Nerp runner marks level as complete')\n        this.halted = true\n        GameState.resultState = GameResultState.COMPLETE\n        this.onLevelEnd()\n    }\n\n    /**\n     * End the level as failure and show the score screen.\n     */\n    setLevelFail() {\n        console.log('NerpRunner marks level as failed; at line: ' + this.scriptLines[this.programCounter])\n        this.halted = true\n        GameState.resultState = GameResultState.FAILED\n        this.onLevelEnd()\n    }\n\n    /**\n     * Sets tutorial flags\n     * @param value a bitmask to set flags with\n     */\n    setTutorialFlags(value) {\n        // seems like value must be interpreted bitwise and sets a certain flag on each bit\n        // seen so far:\n        // 0 = 0x00 allow any click anywhere anytime\n        // 3 = 0x11 disallow invalid clicks\n        // 4095 = 0x111111111111 set all flags? (seen in Tutorial01 level)\n        if (value !== 0) { // holds for all known levels\n            console.warn('NERP: setTutorialFlags not yet implemented', value)\n        }\n    }\n\n    /**\n     * This is used to make messages come up/not come up.\n     * @param messagesAllowed\n     */\n    setMessagePermit(messagesAllowed) {\n        this.messagePermit = !messagesAllowed\n    }\n\n    setBuildingsUpgradeLevel(typeName: EntityType, level: number) {\n        GameState.buildings.forEach(b => {\n            if (b.entityType === typeName) b.level = level\n        })\n    }\n\n    setToolStoreLevel(level: number) {\n        this.setBuildingsUpgradeLevel(EntityType.TOOLSTATION, level)\n    }\n\n    setTeleportPadLevel(level: number) {\n        this.setBuildingsUpgradeLevel(EntityType.TELEPORT_PAD, level)\n    }\n\n    setPowerStationLevel(level: number) {\n        this.setBuildingsUpgradeLevel(EntityType.POWER_STATION, level)\n    }\n\n    setBarracksLevel(level: number) {\n        this.setBuildingsUpgradeLevel(EntityType.BARRACKS, level)\n    }\n\n    /**\n     * Gets the number of tool stores currently built. NOT the total ever built.\n     * @return {number}\n     */\n    getToolStoresBuilt() {\n        return GameState.buildings.count((b) => b.entityType === EntityType.TOOLSTATION)\n    }\n\n    /**\n     * Gets the number of minifigures on the level. XXX it is NOT tested if this ignores minifigures in hidden caverns\n     * @return {number}\n     */\n    getMinifiguresOnLevel() {\n        return GameState.raiders.length\n    }\n\n    /**\n     * Gets the number of crystals currently stored.\n     * @return {number}\n     */\n    getCrystalsCurrentlyStored() {\n        return GameState.numCrystal\n    }\n\n    getObjectiveSwitch() {\n        // TODO implement this\n        return false\n    }\n\n    setMessageTimerValues(arg1, arg2, arg3) {\n        // TODO implement this\n    }\n\n    getMessageTimer() {\n        return 0 // TODO return remaining amount of time needed to fully play WAV message\n    }\n\n    cameraUnlock() {\n        // TODO implement this\n    }\n\n    setMessage(messageNumber, arrowDisabled) {\n        if (!this.messagePermit) return\n        if (messageNumber === 0) return // TODO messages start at 1\n        const msg = this.messages[messageNumber]\n        console.log(msg.txt) // TODO show message to user\n        // msg.snd resides in sounds/streamed/ which is currently not loaded :(\n    }\n\n    setCameraGotoTutorial(arg1) {\n        // TODO implement this\n    }\n\n    getTutorialBlockIsGround(blockNum) {\n        return 0 // TODO return true if given block is ground\n    }\n\n    getTutorialBlockIsPath(blockNum) {\n        return 0 // TODO return true if given block is a path\n    }\n\n    getUnitAtBlock(blockNum) {\n        return 0 // TODO return number of units on given block\n    }\n\n    getOxygenLevel() {\n        return GameState.airLevel * 100\n    }\n\n    getObjectiveShowing() {\n        // TODO implement this\n        return false\n    }\n\n    addPoweredCrystals() {\n        // TODO implement this\n    }\n\n    disallowAll() {\n        // TODO implement this\n    }\n\n    getPoweredPowerStationsBuilt() {\n        return GameState.buildings.count((b) => b.isUsable() && b.entityType === EntityType.POWER_STATION)\n    }\n\n    getPoweredBarracksBuilt() {\n        return GameState.buildings.count((b) => b.isUsable() && b.entityType === EntityType.BARRACKS)\n    }\n\n    getRecordObjectAtTutorial() {\n        // TODO implement this\n    }\n\n    getHiddenObjectsFound() {\n        // TODO implement this\n        return 0\n    }\n\n    getLevel1PowerStationsBuilt() {\n        return GameState.buildings.count((b) => b.entityType === EntityType.POWER_STATION && b.level >= 1)\n    }\n\n    getRandom100(): number {\n        return getRandom(100)\n    }\n\n    getSlugsOnLevel(): number {\n        return 0 // TODO implement slugs\n    }\n\n    generateSlug() {\n        console.warn('Slugs not yet implemented') // TODO implement slugs\n    }\n\n    callMethod(methodName, methodArgs) {\n        if (methodName === 'Stop') {\n            throw 'Stop'\n        } else if (methodName === 'TRUE') {\n            return true\n        } else if (methodName === 'FALSE') {\n            return false\n        }\n        const setRegisterMatch = methodName.match(/^SetR([0-7])$/)\n        if (setRegisterMatch) {\n            return this.setR(setRegisterMatch[1], methodArgs[0])\n        }\n        const addRegisterMatch = methodName.match(/^AddR([0-7])$/)\n        if (addRegisterMatch) {\n            return this.addR(addRegisterMatch[1], methodArgs[0])\n        }\n        const getRegisterMatch = methodName.match(/^GetR([0-7])$/)\n        if (getRegisterMatch) {\n            return this.getR(getRegisterMatch[1])\n        }\n        const setTimerMatch = methodName.match(/^SetTimer([0-3])$/)\n        if (setTimerMatch) {\n            return this.setTimer(setTimerMatch[1], methodArgs[0])\n        }\n        const getTimerMatch = methodName.match(/^GetTimer([0-3])$/)\n        if (getTimerMatch) {\n            return this.getTimer(getTimerMatch[1])\n        }\n        const lMethodName = methodName.toLowerCase()\n        const memberName = Object.getOwnPropertyNames(NerpRunner.prototype).find((name) => name.toLowerCase() === lMethodName)\n        if (memberName) return this[memberName].apply(this, methodArgs)\n        throw new Error('Undefined method: ' + methodName)\n    }\n\n    conditional(left, right) {\n        const conditionResult = this.executeStatement(left)\n        if (this.debug) {\n            console.log('Condition evaluated to ' + conditionResult)\n        }\n        if (conditionResult) {\n            this.executeStatement(right)\n        }\n    }\n\n    executeStatement(expression) {\n        if (expression.invoke) {\n            const argValues = expression.invoke !== 'conditional' ? expression.args.map(e => this.executeStatement(e)) : expression.args\n            const result = this.callMethod(expression.invoke, argValues)\n            if (result !== undefined && this.debug) {\n                console.log('Method returned: ' + result)\n            }\n            return result\n        } else if (expression.comparator) {\n            const left = this.executeStatement(expression.left)\n            const right = this.executeStatement(expression.right)\n            if (expression.comparator === '=') {\n                return left === right\n            } else if (expression.comparator === '!=') {\n                return left !== right\n            } else if (expression.comparator === '<') {\n                return left < right\n            } else if (expression.comparator === '>') {\n                return left > right\n            } else {\n                console.log(expression)\n                throw new Error('Unknown comparator: ' + expression.comparator)\n            }\n        } else if (!isNaN(expression)) { // just a number\n            return expression\n        } else if (expression.jump) {\n            this.programCounter = this.labelsByName[expression.jump]\n            if (this.programCounter === undefined) {\n                throw new Error('Label \\'' + expression.jump + '\\' is unknown!')\n            }\n            if (this.debug) {\n                console.log('Jumping to label \\'' + expression.jump + '\\' in line ' + this.programCounter)\n            }\n        } else {\n            console.log(expression)\n            throw new Error('Unknown expression in line ' + this.programCounter + ': ' + expression)\n        }\n    }\n\n    execute(debug = false) {\n        this.debug = debug\n        if (this.halted) return\n        try {\n            if (this.debug) {\n                console.log('Executing following script\\n' + this.scriptLines.join('\\n'))\n                console.log('Registers: ' + this.registers)\n            }\n            for (this.programCounter = 0; this.programCounter < this.statements.length; this.programCounter++) {\n                const statement = this.statements[this.programCounter]\n                if (this.debug) {\n                    console.log(this.programCounter + ': ' + this.scriptLines[this.programCounter])\n                    console.log(statement)\n                }\n                if (!statement.label) { // do nothing for label markers\n                    this.executeStatement(statement)\n                }\n            }\n        } catch (e) {\n            if (e === 'Stop') {\n                return\n            }\n            console.error(e)\n            console.error('FATAL ERROR! Script execution failed! You can NOT win anymore!')\n            this.halted = true\n        }\n    }\n\n}\n","import { ResourceManager } from '../resource/ResourceManager'\nimport { NerpRunner } from './NerpRunner'\n\nexport class NerpParser {\n\n    static parse(nerpScript: string): NerpRunner {\n        const nerpRunner = new NerpRunner()\n        const lines = nerpScript.split('\\n').map(l => l\n            .split('//')[0].trim() // before comment starts\n            .split(';')[0].trim() // before preprocessor comment starts\n            .replace(/_/g, '') // some preprocessor macros use this prefix\n            .replace(/\\bTRUE \\? /, '') // some weird requirement of the original language\n            .replace(/[{}]/g, ''), // duplicate limit for macros using labels too\n        )\n        for (let c = 0; c < lines.length; c++) {\n            const line = lines[c]\n            if (line.length < 1) {\n                continue // ignore empty lines, but important for macro closure\n            }\n            if (line.startsWith('#include ')) { // include other nerp scripts/headers\n                const includeName = line.replace(/^#include /, '').trim().slice(1, -1)\n                if (includeName === 'nerpdef.h') {\n                    // trivial default header file, is applied by search and replace above\n                    // see https://github.com/jgrip/legorr/blob/master/nerpdef.h\n                    continue\n                }\n                const includedRunner = NerpParser.parse(ResourceManager.getResource('Levels/' + includeName))\n                if (!includedRunner || !includedRunner.scriptLines || includedRunner.scriptLines.length < 1) {\n                    throw 'Can\\'t include unknown nerp script: ' + line\n                }\n                nerpRunner.scriptLines = nerpRunner.scriptLines.concat(includedRunner.scriptLines)\n                // copy macros from included file to current file\n                nerpRunner.macrosByName = Object.assign({}, nerpRunner.macrosByName, includedRunner.macrosByName)\n            } else if (line.startsWith('#define ')) { // parse C++ preprocessor macro\n                const firstLine = line.replace(/^#define /, '').split(' ')\n                const macroLines = [firstLine.splice(1).join(' ').replace(/\\\\$/, '').trim()]\n                let mLine = line\n                let append = false\n                while (mLine.endsWith('\\\\') && c < lines.length - 1) {\n                    c++\n                    mLine = lines[c].trim()\n                    const macroLine = mLine.replace(/\\\\$/, '').trim()\n                    if (macroLine.length > 0) {\n                        if (append) {\n                            append = false\n                            macroLines[macroLines.length - 1] += macroLine\n                        } else {\n                            macroLines.push(macroLine)\n                        }\n                    }\n                    if (mLine.match(/:\\\\$/)) {\n                        append = true\n                    }\n                }\n                const macroCall = firstLine[0].split('(')\n                nerpRunner.macrosByName[macroCall[0]] = {\n                    args: macroCall[1].replace(/\\)$/, '').split(','),\n                    lines: macroLines,\n                }\n            } else {\n                nerpRunner.scriptLines = nerpRunner.scriptLines.concat(this.replaceMacros(nerpRunner.macrosByName, line))\n            }\n        }\n        // somewhat precompile the script and create syntax tree\n        // must be done in separate block to make sure the script is complete and we can refer/rely on line numbers for label jumps\n        for (let c = 0; c < nerpRunner.scriptLines.length; c++) {\n            const line = nerpRunner.scriptLines[c]\n            nerpRunner.statements[c] = line.replace(/\\(\\)/g, '') // now the macros are applied and obsolete empty \"()\" can be removed\n                .split(' ? ')\n            const labelMatch = line.match(/(\\S+):/)\n            if (nerpRunner.statements[c].length === 2) { // line contains condition (primary operator)\n                nerpRunner.statements[c] = {\n                    invoke: 'conditional',\n                    args: [this.preProcess(nerpRunner.statements[c][0]), this.preProcess(nerpRunner.statements[c][1])],\n                }\n            } else if (labelMatch) { // keep label line number for later usage\n                const labelName = labelMatch[1].toLowerCase()\n                nerpRunner.labelsByName[labelName] = c\n                nerpRunner.statements[c] = {label: labelName}\n            } else if (nerpRunner.statements[c].length === 1) { // just a call\n                nerpRunner.statements[c] = this.preProcess(nerpRunner.statements[c][0])\n            } else { // lines contains more than 1 condition statement\n                throw 'Can\\'t deal with line: ' + line\n            }\n        }\n        return nerpRunner\n    }\n\n    static replaceMacros(macrosByName, line): string[] {\n        // check if this line contains a macro\n        const split = line.split('(') // not a very stable check though...\n        const macro = macrosByName[split[0]]\n        if (macro) {\n            const argValues = split.splice(1).join('(').slice(0, -1).split(',')\n            if (argValues.length !== macro.args.length) {\n                throw 'Invalid number of args provided for macro in line ' + line\n            }\n            const macroLines = []\n            macro.lines.forEach((line) => {\n                for (let c = 0; c < argValues.length; c++) {\n                    line = line.replace(new RegExp('\\\\b' + macro.args[c] + '\\\\b'), argValues[c])\n                }\n                macroLines.push(...(this.replaceMacros(macrosByName, line)))\n            })\n            return macroLines\n        } else {\n            return [line]\n        }\n    }\n\n    static preProcess(expression) {\n        expression = expression.trim().replace(/^_/, '') // remove whitespace and leading underscore\n        const number = parseInt(expression)\n        if (!isNaN(number)) {\n            return number\n        }\n        const opSplit = expression.split(/ (=) | (!=) | (>) | (<) /).filter(e => e !== undefined)\n        const brackets = expression.match(/^(.+)\\((.+)\\)$/)\n        const spaceSplit = expression.split(' ')\n        const labelMatch = expression.match(/([^:]+):$/)\n        const jumpMatch = expression.match(/^:([^:]+)$/)\n        if (opSplit.length === 3) { // expression contains secondary operator\n            return {left: this.preProcess(opSplit[0]), comparator: opSplit[1], right: this.preProcess(opSplit[2])}\n        } else if (brackets) {\n            const args = brackets[2].split(',').map(a => this.preProcess(a))\n            return {invoke: brackets[1], args: args}\n        } else if (spaceSplit.length > 1) { // space split must be the very last since most expressions contain space\n            const args = spaceSplit.length === 2 ? [this.preProcess(spaceSplit[1])] : spaceSplit.splice(1).map(a => this.preProcess(a))\n            return {invoke: spaceSplit[0], args: args}\n        } else if (labelMatch) { // label definition\n            return {label: labelMatch[1]}\n        } else if (jumpMatch) { // jump to label\n            return {jump: jumpMatch[1].toLowerCase()}\n        } else { // function call without args\n            if (expression.match(/[ =?><!]/)) {\n                throw 'Invalid expression given, parsing must have failed before somewhere'\n            }\n            return {invoke: expression, args: []}\n        }\n    }\n\n}\n","import { LevelPrioritiesEntryConfig } from '../../../cfg/LevelsCfg'\nimport { PublicJob } from './Job'\nimport { PriorityIdentifier } from './PriorityIdentifier'\n\nexport class PriorityList {\n\n    levelDefault: PriorityEntry[] = []\n    current: PriorityEntry[] = []\n\n    setList(priorities: PriorityEntry[]) {\n        this.levelDefault = priorities\n        this.reset()\n    }\n\n    toggle(index: number) {\n        this.current[index].enabled = !this.current[index].enabled\n    }\n\n    upOne(index: number) {\n        const tmp = this.current[index]\n        this.current[index] = this.current[index + 1]\n        this.current[index + 1] = tmp\n    }\n\n    reset() {\n        this.current = this.levelDefault.map(entry => new PriorityEntry(entry)) // use deep copy to avoid interference\n    }\n\n    pushToTop(index: number) {\n        const element = this.current[index]\n        for (let c = index; c > 0; c--) {\n            this.current[c] = this.current[c - 1]\n        }\n        this.current[0] = element\n    }\n\n    getPriority(job: PublicJob) {\n        let priority = 0\n        this.current.some((j, index) => {\n            if (j.key === job.getPriorityIdentifier()) {\n                priority = index\n                return true\n            }\n        })\n        return priority\n    }\n\n    isEnabled(priorityIdentifier: PriorityIdentifier): boolean {\n        return this.current.find((entry) => entry.key === priorityIdentifier)?.enabled || false\n    }\n}\n\nexport class PriorityEntry {\n\n    key: PriorityIdentifier\n    enabled: boolean\n\n    constructor(levelPriorityEntry: LevelPrioritiesEntryConfig) {\n        this.key = levelPriorityEntry.key\n        this.enabled = levelPriorityEntry.enabled\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { LevelEntryCfg } from '../cfg/LevelsCfg'\nimport { NerpParser } from '../core/NerpParser'\nimport { NerpRunner } from '../core/NerpRunner'\nimport { EventBus } from '../event/EventBus'\nimport { EventKey } from '../event/EventKeyEnum'\nimport { AirLevelChanged, SelectionChanged, SetupPriorityList } from '../event/LocalEvents'\nimport { JobCreateEvent } from '../event/WorldEvents'\nimport { UPDATE_OXYGEN_TIMER } from '../params'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { MaterialEntity } from './model/collect/MaterialEntity'\nimport { GameState } from './model/GameState'\nimport { PriorityList } from './model/job/PriorityList'\nimport { SelectionType } from './model/Selectable'\n\nexport class WorldManager {\n\n    nerpRunner: NerpRunner = null\n    oxygenUpdateInterval = null\n    priorityList: PriorityList = new PriorityList()\n\n    constructor() {\n        EventBus.registerEventListener(EventKey.SELECTION_CHANGED, (event: SelectionChanged) => {\n            if (event.selectionType === SelectionType.NOTHING) GameState.selectEntities([])\n        })\n        EventBus.registerEventListener(EventKey.CAVERN_DISCOVERED, () => {\n            GameState.discoveredCaverns++\n        })\n        this.oxygenUpdateInterval = setInterval(this.updateOxygen.bind(this), UPDATE_OXYGEN_TIMER)\n    }\n\n    setup(levelConf: LevelEntryCfg, onLevelEnd: () => any) {\n        GameState.totalCaverns = levelConf.reward?.quota?.caverns || 0\n        this.priorityList.setList(levelConf.priorities)\n        EventBus.publishEvent(new SetupPriorityList(this.priorityList.levelDefault))\n        GameState.oxygenRate = levelConf.oxygenRate\n\n        // load nerp script\n        this.nerpRunner = NerpParser.parse(ResourceManager.getResource(levelConf.nerpFile))\n        this.nerpRunner.messages.push(...(ResourceManager.getResource(levelConf.nerpMessageFile)))\n        this.nerpRunner.onLevelEnd = onLevelEnd\n    }\n\n    start() {\n        this.nerpRunner?.startExecution()\n        GameState.levelStartTime = Date.now()\n    }\n\n    stop() {\n        GameState.levelStopTime = Date.now()\n        this.nerpRunner?.pauseExecution()\n        GameState.buildings.forEach((b) => b.removeFromScene())\n        GameState.buildingsUndiscovered.forEach((b) => b.removeFromScene())\n        GameState.raiders.forEach((r) => r.removeFromScene())\n        GameState.raidersUndiscovered.forEach((r) => r.removeFromScene())\n        GameState.materials.forEach((m) => m.removeFromScene())\n        GameState.materialsUndiscovered.forEach((m) => m.removeFromScene())\n        GameState.spiders.forEach((m) => m.removeFromScene())\n        GameState.bats.forEach((b) => b.removeFromScene())\n    }\n\n    placeMaterial(item: MaterialEntity, worldPosition: Vector2) {\n        item.addToScene(worldPosition, 0)\n        if (item.group.visible) {\n            GameState.materials.push(item)\n            EventBus.publishEvent(new JobCreateEvent(item.createCarryJob()))\n        } else {\n            GameState.materialsUndiscovered.push(item)\n        }\n        return item\n    }\n\n    updateOxygen() {\n        const sum = GameState.raiders.map((r) => r.stats.OxygenCoef).reduce((l, r) => l + r, 0) +\n            GameState.buildings.map((b) => b.isUsable() ? b.stats.OxygenCoef : 0).reduce((l, r) => l + r, 0)\n        const rateMultiplier = 0.001\n        const valuePerSecond = 1 / 25\n        const msToSeconds = 0.001\n        const diff = sum * GameState.oxygenRate * rateMultiplier * valuePerSecond * UPDATE_OXYGEN_TIMER * msToSeconds / 10\n        const airLevel = Math.min(1, Math.max(0, GameState.airLevel + diff))\n        if (GameState.airLevel !== airLevel) {\n            GameState.airLevel = airLevel\n            EventBus.publishEvent(new AirLevelChanged(GameState.airLevel))\n        }\n    }\n\n}\n","import { GameKeyboardEvent } from '../../event/GameKeyboardEvent'\nimport { GamePointerEvent } from '../../event/GamePointerEvent'\nimport { GameWheelEvent } from '../../event/GameWheelEvent'\nimport { SPRITE_RESOLUTION_HEIGHT, SPRITE_RESOLUTION_WIDTH } from '../../params'\n\nexport class ScreenLayer {\n\n    canvas: HTMLCanvasElement\n    context: CanvasRenderingContext2D\n    onRedraw: (context: SpriteContext) => any\n    active: boolean = true\n\n    constructor(alpha: boolean, withContext: boolean) {\n        this.canvas = document.createElement('canvas')\n        if (!alpha) this.canvas.style.background = '#f0f'\n        if (withContext) this.context = this.canvas.getContext('2d', {alpha: alpha})\n        this.hide()\n    }\n\n    reset() {\n    }\n\n    setZIndex(zIndex: number) {\n        this.canvas.style.zIndex = String(zIndex)\n    }\n\n    static compareZ(layerA: ScreenLayer, layerB: ScreenLayer) {\n        let aIndex = layerA?.canvas?.style?.zIndex || 0\n        const bIndex = layerB?.canvas?.style?.zIndex || 0\n        return aIndex === bIndex ? 0 : aIndex > bIndex ? -1 : 1\n    }\n\n    resize(width, height) {\n        this.canvas.width = width\n        this.canvas.height = height\n    }\n\n    redraw() {\n        const callback = this.onRedraw\n        if (this.isActive() && callback) {\n            const context = this.context\n            requestAnimationFrame(() => callback(context))\n        }\n    }\n\n    show() {\n        this.reset()\n        this.active = true\n        this.canvas.style.visibility = 'visible'\n        this.redraw()\n    }\n\n    hide() {\n        this.active = false\n        this.canvas.style.visibility = 'hidden'\n    }\n\n    isActive() {\n        return this.active\n    }\n\n    toCanvasCoords(windowX: number, windowY: number) {\n        const clientRect = this.canvas.getBoundingClientRect()\n        return [windowX - clientRect.left, windowY - clientRect.top]\n    }\n\n    handlePointerEvent(event: GamePointerEvent): Promise<boolean> {\n        return new Promise((resolve) => resolve(false))\n    }\n\n    handleKeyEvent(event: GameKeyboardEvent): Promise<boolean> {\n        return new Promise((resolve) => resolve(false))\n    }\n\n    handleWheelEvent(event: GameWheelEvent): Promise<boolean> {\n        return new Promise((resolve) => resolve(false))\n    }\n\n}\n\nexport class ScaledLayer extends ScreenLayer {\n\n    fixedWidth: number = SPRITE_RESOLUTION_WIDTH\n    fixedHeight: number = SPRITE_RESOLUTION_HEIGHT\n    scaleX: number\n    scaleY: number\n\n    constructor(alpha: boolean = true, withContext: boolean = true) {\n        super(alpha, withContext)\n        this.updateScale()\n    }\n\n    private updateScale() {\n        this.scaleX = this.canvas.width / this.fixedWidth\n        this.scaleY = this.canvas.height / this.fixedHeight\n    }\n\n    toScaledCoords(windowX: number, windowY: number) {\n        const [cx, cy] = this.toCanvasCoords(windowX, windowY)\n        return [cx / this.scaleX, cy / this.scaleY].map((c) => Math.round(c))\n    }\n\n    resize(width, height) {\n        super.resize(width, height)\n        this.updateScale()\n        this.context.scale(this.scaleX, this.scaleY)\n    }\n\n}\n","import { KEY_EVENT } from './EventTypeEnum'\n\nexport class GameKeyboardEvent {\n\n    eventEnum: KEY_EVENT\n    type: string\n    bubbles: boolean\n    key: string\n    code: string\n\n    constructor(eventEnum: KEY_EVENT, event: KeyboardEvent) {\n        this.eventEnum = eventEnum\n        this.type = event.type\n        this.bubbles = false // disable bubbling otherwise we'll trigger this same event handler again\n        this.key = event.key\n        this.code = event.code\n    }\n\n}\n","import { POINTER_EVENT } from './EventTypeEnum'\n\nexport class GamePointerEvent implements PointerEventInit {\n\n    type: string\n    eventEnum: POINTER_EVENT\n    bubbles: boolean\n    clientX: number\n    clientY: number\n    pointerType: string\n    button: number\n    ctrlKey: boolean\n    metaKey: boolean\n    shiftKey: boolean\n    canvasX: number\n    canvasY: number\n\n    constructor(eventEnum: POINTER_EVENT, event: PointerEvent) {\n        this.eventEnum = eventEnum\n        this.type = event.type\n        this.bubbles = false // disable bubbling otherwise we'll trigger this same event handler again\n        // all event attributes used by three.js controls: clientX, clientY, deltaY, keyCode, touches, pointerType, button, ctrlKey, metaKey, shiftKey\n        this.clientX = event.clientX\n        this.clientY = event.clientY\n        this.pointerType = event.pointerType\n        this.button = event.button\n        this.ctrlKey = event.ctrlKey\n        this.metaKey = event.metaKey\n        this.shiftKey = event.shiftKey\n    }\n\n}\n","export class GameWheelEvent {\n\n    type: string\n    bubbles: boolean\n    clientX: number\n    clientY: number\n    deltaX: number\n    deltaY: number\n    deltaZ: number\n    button: number\n    ctrlKey: boolean\n    metaKey: boolean\n    shiftKey: boolean\n    canvasX: number\n    canvasY: number\n\n    constructor(event: WheelEvent) {\n        this.type = event.type\n        this.bubbles = false // disable bubbling otherwise we'll trigger this same event handler again\n        // all event attributes used by three.js controls: clientX, clientY, deltaY, keyCode, touches, button, ctrlKey, metaKey, shiftKey\n        this.clientX = event.clientX\n        this.clientY = event.clientY\n        this.deltaX = event.deltaX\n        this.deltaY = event.deltaY\n        this.deltaZ = event.deltaZ\n        this.button = event.button\n        this.ctrlKey = event.ctrlKey\n        this.metaKey = event.metaKey\n        this.shiftKey = event.shiftKey\n    }\n\n}\n","import { DEV_MODE } from '../params'\nimport { BaseScreen } from '../screen/BaseScreen'\nimport { ScreenLayer } from '../screen/layer/ScreenLayer'\nimport { KEY_EVENT, POINTER_EVENT } from './EventTypeEnum'\nimport { GameKeyboardEvent } from './GameKeyboardEvent'\nimport { GamePointerEvent } from './GamePointerEvent'\nimport { GameWheelEvent } from './GameWheelEvent'\n\nexport class EventManager {\n\n    constructor(screen: BaseScreen) {\n        screen.gameCanvasContainer.addEventListener('contextmenu', (event: MouseEvent) => {\n            if (screen.isInRect(event)) event.preventDefault()\n        })\n        new Map<string, POINTER_EVENT>([\n            ['pointermove', POINTER_EVENT.MOVE],\n            ['pointerdown', POINTER_EVENT.DOWN],\n            ['pointerup', POINTER_EVENT.UP],\n        ]).forEach((eventEnum, eventType) => {\n            screen.gameCanvasContainer.addEventListener(eventType, (event: PointerEvent) => {\n                if (!screen.isInRect(event)) return\n                event.preventDefault()\n                const nonBubblingClone = new GamePointerEvent(eventEnum, event)\n                const activeLayers = screen.layers.filter(l => l.isActive())\n                    .sort((a, b) => ScreenLayer.compareZ(a, b))\n                EventManager.publishPointerEvent(activeLayers, nonBubblingClone)\n            })\n        })\n        new Map<string, KEY_EVENT>([\n            ['keydown', KEY_EVENT.DOWN],\n            ['keyup', KEY_EVENT.UP],\n        ]).forEach((eventEnum, eventType) => {\n            screen.gameCanvasContainer.addEventListener(eventType, (event: KeyboardEvent) => {\n                if (!DEV_MODE) event.preventDefault()\n                const nonBubblingClone = new GameKeyboardEvent(eventEnum, event)\n                const activeLayers = screen.layers.filter(l => l.isActive())\n                    .sort((a, b) => ScreenLayer.compareZ(a, b))\n                EventManager.publishKeyEvent(activeLayers, nonBubblingClone)\n            })\n        })\n        screen.gameCanvasContainer.addEventListener('wheel', (event: WheelEvent) => {\n            if (!screen.isInRect(event)) return\n            const nonBubblingClone = new GameWheelEvent(event)\n            const activeLayers = screen.layers.filter(l => l.isActive())\n                .sort((a, b) => ScreenLayer.compareZ(a, b))\n            EventManager.publishWheelEvent(activeLayers, nonBubblingClone)\n        })\n    }\n\n    private static publishPointerEvent(activeLayers: ScreenLayer[], event: GamePointerEvent) {\n        activeLayers.shift()?.handlePointerEvent(event).then((consumed) => {\n            if (!consumed) this.publishPointerEvent(activeLayers, event)\n        })\n    }\n\n    private static publishKeyEvent(activeLayers: ScreenLayer[], event: GameKeyboardEvent) {\n        activeLayers.shift()?.handleKeyEvent(event).then((consumed) => {\n            if (!consumed) this.publishKeyEvent(activeLayers, event)\n        })\n    }\n\n    private static publishWheelEvent(activeLayers: ScreenLayer[], event: GameWheelEvent) {\n        activeLayers.shift()?.handleWheelEvent(event).then((consumed) => {\n            if (!consumed) this.publishWheelEvent(activeLayers, event)\n        })\n    }\n\n}\n","import { Raycaster } from 'three'\nimport { clearTimeoutSafe } from '../../core/Util'\nimport { EventKey } from '../../event/EventKeyEnum'\nimport { POINTER_EVENT } from '../../event/EventTypeEnum'\nimport { GamePointerEvent } from '../../event/GamePointerEvent'\nimport { IEventHandler } from '../../event/IEventHandler'\nimport { ChangeCursor } from '../../event/LocalEvents'\nimport { GameState } from '../../game/model/GameState'\nimport { Surface } from '../../game/model/map/Surface'\nimport { SelectionType } from '../../game/model/Selectable'\nimport { SceneManager } from '../../game/SceneManager'\nimport { ResourceManager } from '../../resource/ResourceManager'\nimport { AnimatedCursor } from '../AnimatedCursor'\nimport { Cursor } from '../Cursor'\nimport { ScreenLayer } from './ScreenLayer'\n\nexport class CursorLayer extends ScreenLayer {\n\n    sceneMgr: SceneManager\n    currentCursor: Cursor = null\n    timedCursor: Cursor = null\n    cursorTimeout = null\n    activeCursor: AnimatedCursor = null\n\n    constructor(parent: IEventHandler) {\n        super(true, false)\n        parent.registerEventListener(EventKey.CHANGE_CURSOR, (event: ChangeCursor) => {\n            if (this.active) this.changeCursor(event.cursor, event.timeout)\n        })\n    }\n\n    reset() {\n        this.changeCursor(Cursor.Pointer_Standard)\n    }\n\n    hide() {\n        super.hide()\n        this.canvas.style.cursor = null\n        this.currentCursor = null\n        this.timedCursor = null\n        this.cursorTimeout = clearTimeoutSafe(this.cursorTimeout)\n        this.activeCursor?.disableAnimation()\n        this.activeCursor = null\n    }\n\n    handlePointerEvent(event: GamePointerEvent): Promise<boolean> {\n        if (event.eventEnum === POINTER_EVENT.MOVE && this.sceneMgr) {\n            const [cx, cy] = this.toCanvasCoords(event.clientX, event.clientY)\n            const rx = (cx / this.canvas.width) * 2 - 1\n            const ry = -(cy / this.canvas.height) * 2 + 1\n            const raycaster = new Raycaster()\n            raycaster.setFromCamera({x: rx, y: ry}, this.sceneMgr.camera)\n            this.changeCursor(this.determineCursor(raycaster))\n        }\n        return super.handlePointerEvent(event)\n    }\n\n    determineCursor(raycaster: Raycaster): Cursor {\n        if (GameState.buildModeSelection) {\n            return this.sceneMgr.buildMarker.lastCheck ? Cursor.Pointer_CanBuild : Cursor.Pointer_CannotBuild\n        }\n        let intersects = raycaster.intersectObjects(GameState.raiders.map((r) => r.pickSphere))\n        if (intersects.length > 0) {\n            return Cursor.Pointer_Selected\n        } else {\n            let intersects = raycaster.intersectObjects(GameState.buildings.map((b) => b.pickSphere))\n            if (intersects.length > 0) {\n                return Cursor.Pointer_Selected\n            } else {\n                intersects = raycaster.intersectObjects(this.sceneMgr.terrain.floorGroup.children)\n                if (intersects.length > 0) {\n                    const userData = intersects[0].object.userData\n                    if (userData && userData.hasOwnProperty('surface')) {\n                        const surface = userData['surface'] as Surface\n                        if (surface) {\n                            if (GameState.selectionType === SelectionType.RAIDER || GameState.selectionType === SelectionType.VEHICLE || GameState.selectionType === SelectionType.GROUP) {\n                                if (surface.isDrillable()) {\n                                    return Cursor.Pointer_Drill // TODO check if selected entities can drill and return Pointer_CDrill otherwise\n                                } else {\n                                    return surface.surfaceType.cursorFulfiller\n                                }\n                            } else {\n                                return surface.surfaceType.cursor\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return Cursor.Pointer_Standard\n    }\n\n    private changeCursor(cursor: Cursor, timeout: number = null) {\n        if (timeout) {\n            this.cursorTimeout = clearTimeoutSafe(this.cursorTimeout)\n            if (this.timedCursor !== cursor) this.setCursor(cursor)\n            const that = this\n            this.cursorTimeout = setTimeout(() => {\n                that.cursorTimeout = null\n                that.setCursor(that.currentCursor)\n            }, timeout)\n        } else if (this.currentCursor !== cursor) {\n            this.currentCursor = cursor\n            if (this.cursorTimeout) return\n            this.setCursor(cursor)\n        }\n    }\n\n    private setCursor(cursor: Cursor) {\n        this.activeCursor?.disableAnimation()\n        this.activeCursor = ResourceManager.getCursor(cursor)\n        this.activeCursor.enableAnimation(this.canvas.style)\n    }\n\n}\n","import { EventBus } from '../event/EventBus'\nimport { EventKey } from '../event/EventKeyEnum'\nimport { EventManager } from '../event/EventManager'\nimport { GameEvent } from '../event/GameEvent'\nimport { IEventHandler } from '../event/IEventHandler'\nimport { SPRITE_RESOLUTION_HEIGHT, SPRITE_RESOLUTION_WIDTH } from '../params'\nimport { CursorLayer } from './layer/CursorLayer'\nimport { ScreenLayer } from './layer/ScreenLayer'\n\nexport class BaseScreen implements IEventHandler {\n\n    gameCanvasContainer: HTMLElement\n    eventMgr: EventManager\n    layers: ScreenLayer[] = []\n    width: number = SPRITE_RESOLUTION_WIDTH\n    height: number = SPRITE_RESOLUTION_HEIGHT\n    ratio: number = SPRITE_RESOLUTION_WIDTH / SPRITE_RESOLUTION_HEIGHT\n    cursorLayer: CursorLayer\n\n    constructor() {\n        this.gameCanvasContainer = document.getElementById('game-canvas-container')\n        this.gameCanvasContainer.focus()\n        this.eventMgr = new EventManager(this)\n        if (!this.gameCanvasContainer) throw 'Fatal error: game canvas container not found!'\n        window.addEventListener('resize', () => this.onWindowResize())\n        this.onWindowResize()\n        this.cursorLayer = this.addLayer(new CursorLayer(this), 1000) // TODO turn cursor layer into singleton?\n    }\n\n    addLayer<T extends ScreenLayer>(layer: T, zIndex: number = 0): T {\n        layer.resize(this.width, this.height)\n        layer.setZIndex(zIndex)\n        this.layers.push(layer)\n        this.gameCanvasContainer.appendChild(layer.canvas)\n        return layer\n    }\n\n    redraw() {\n        this.layers.forEach((layer) => layer.redraw())\n    }\n\n    show() {\n        this.layers.forEach((layer) => layer.show())\n        this.redraw()\n    }\n\n    hide() {\n        this.layers.forEach((layer) => layer.hide())\n    }\n\n    onWindowResize() {\n        const maxWidth = this.gameCanvasContainer.offsetWidth, maxHeight = this.gameCanvasContainer.offsetHeight\n        const idealHeight = Math.round(maxWidth / this.ratio)\n        if (idealHeight > maxHeight) {\n            this.resize(Math.round(maxHeight * this.ratio), maxHeight)\n        } else {\n            this.resize(maxWidth, idealHeight)\n        }\n    }\n\n    resize(width: number, height: number) {\n        this.width = width\n        this.height = height\n        this.layers.forEach((layer) => {\n            const oldCanvas = layer.canvas\n            layer.resize(width, height)\n            if (oldCanvas !== layer.canvas) { // TODO refactor this\n                this.gameCanvasContainer.removeChild(oldCanvas)\n                this.gameCanvasContainer.appendChild(layer.canvas)\n            }\n        })\n        this.redraw()\n    }\n\n    isInRect(event: MouseEvent | WheelEvent) {\n        if (this.layers.length < 1) return false\n        const firstLayer = this.layers[0] // all layers have same state and size\n        if (!firstLayer.isActive() || !firstLayer.canvas) return false\n        const rect = firstLayer.canvas.getBoundingClientRect()\n        const clientX = event.clientX, clientY = event.clientY\n        return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom\n    }\n\n    publishEvent(event: GameEvent): void {\n        EventBus.publishEvent(event)\n    }\n\n    registerEventListener(eventKey: EventKey, callback: (GameEvent) => any): void {\n        EventBus.registerEventListener(eventKey, callback)\n    }\n\n}\n","import { Vector2 } from 'three'\nimport { EventKey } from '../../event/EventKeyEnum'\nimport { KEY_EVENT, MOUSE_BUTTON, POINTER_EVENT } from '../../event/EventTypeEnum'\nimport { GameEvent } from '../../event/GameEvent'\nimport { GameKeyboardEvent } from '../../event/GameKeyboardEvent'\nimport { GamePointerEvent } from '../../event/GamePointerEvent'\nimport { GameWheelEvent } from '../../event/GameWheelEvent'\nimport { IEventHandler } from '../../event/IEventHandler'\nimport { SelectionChanged } from '../../event/LocalEvents'\nimport { FulfillerEntity } from '../../game/model/FulfillerEntity'\nimport { GameState } from '../../game/model/GameState'\nimport { Job } from '../../game/model/job/Job'\nimport { MoveJob } from '../../game/model/job/MoveJob'\nimport { Surface } from '../../game/model/map/Surface'\nimport { Raider } from '../../game/model/raider/Raider'\nimport { SelectionType } from '../../game/model/Selectable'\nimport { SceneManager } from '../../game/SceneManager'\nimport { WorldManager } from '../../game/WorldManager'\nimport { DEV_MODE } from '../../params'\nimport { ScreenLayer } from './ScreenLayer'\n\nexport class GameLayer extends ScreenLayer implements IEventHandler {\n\n    parent: IEventHandler\n    worldMgr: WorldManager\n    sceneMgr: SceneManager\n    private rightDown: { x: number, y: number } = {x: 0, y: 0}\n\n    constructor(parent: IEventHandler) {\n        super(false, false)\n        this.parent = parent\n    }\n\n    reset() {\n        super.reset()\n        this.rightDown = {x: 0, y: 0}\n    }\n\n    handlePointerEvent(event: GamePointerEvent): Promise<boolean> {\n        const buildMarker = this.sceneMgr.buildMarker\n        if (event.eventEnum === POINTER_EVENT.MOVE) {\n            const intersectionPoint = this.getTerrainPositionFromEvent(event)\n            if (intersectionPoint) this.sceneMgr.setTorchPosition(intersectionPoint)\n            buildMarker.update(intersectionPoint)\n        } else if (event.eventEnum === POINTER_EVENT.UP) {\n            if (event.button === MOUSE_BUTTON.MAIN) {\n                if (GameState.buildModeSelection && buildMarker.lastCheck) {\n                    buildMarker.createBuildingSite()\n                    return new Promise<boolean>((resolve) => resolve(true))\n                }\n            } else if (event.button === MOUSE_BUTTON.SECONDARY) {\n                const downUpDistance = Math.abs(event.clientX - this.rightDown.x) + Math.abs(event.clientY - this.rightDown.y)\n                if (downUpDistance < 3) {\n                    if (GameState.selectionType === SelectionType.RAIDER || GameState.selectionType === SelectionType.GROUP) {\n                        // TODO check for collectable entity first\n                        const intersectionPoint = this.getTerrainPositionFromEvent(event)\n                        if (intersectionPoint) {\n                            const surface = this.sceneMgr.terrain.getSurfaceFromWorldXZ(intersectionPoint.x, intersectionPoint.y)\n                            if (surface) {\n                                if (surface.isDrillable()) {\n                                    this.assignSurfaceJob(surface.createDrillJob(), surface, intersectionPoint)\n                                } else if (surface.hasRubble()) {\n                                    this.assignSurfaceJob(surface.createClearRubbleJob(), surface, intersectionPoint)\n                                } else if (surface.isWalkable()) {\n                                    GameState.selectedEntities.forEach((raider: Raider) => raider.setJob(new MoveJob(intersectionPoint)))\n                                    if (GameState.selectedEntities.length > 0) this.publishEvent(new SelectionChanged())\n                                }\n                            }\n                        }\n                    } else if (GameState.buildModeSelection) {\n                        GameState.buildModeSelection = null\n                        buildMarker.hideAllMarker()\n                    }\n                }\n            }\n        } else if (event.eventEnum === POINTER_EVENT.DOWN) {\n            if (event.button === MOUSE_BUTTON.SECONDARY) {\n                this.rightDown.x = event.clientX\n                this.rightDown.y = event.clientY\n            }\n        }\n        this.canvas.dispatchEvent(new PointerEvent(event.type, event))\n        return new Promise((resolve) => resolve(true))\n    }\n\n    handleKeyEvent(event: GameKeyboardEvent): Promise<boolean> {\n        if (DEV_MODE && event.eventEnum === KEY_EVENT.UP) {\n            if (GameState.selectionType === SelectionType.SURFACE) {\n                if (event.code === 'KeyC') {\n                    GameState.selectedEntities.forEach((s: Surface) => {\n                        if (!s.surfaceType.floor) s.collapse()\n                    })\n                    this.publishEvent(new SelectionChanged())\n                    return new Promise((resolve) => resolve(true))\n                } else if (event.code === 'KeyF') {\n                    GameState.selectedEntities.forEach((s: Surface) => {\n                        const t = s.terrain.findFallInTarget(s.x, s.y)\n                        if (!s.surfaceType.floor) s.createFallin(t[0], t[1])\n                    })\n                    this.publishEvent(new SelectionChanged())\n                    return new Promise((resolve) => resolve(true))\n                }\n            }\n        }\n        this.canvas.dispatchEvent(new KeyboardEvent(event.type, event))\n        return new Promise((resolve) => resolve(true))\n    }\n\n    assignSurfaceJob(job: Job, surface: Surface, intersectionPoint: Vector2) {\n        if (!job) return\n        GameState.selectedEntities.forEach((e: FulfillerEntity) => {\n            if (e.hasTool(job.getRequiredTool()) && e.hasTraining(job.getRequiredTraining())) {\n                e.setJob(job)\n            } else if (surface.isWalkable()) {\n                e.setJob(new MoveJob(intersectionPoint))\n            }\n        })\n        if (GameState.selectedEntities.length > 0) this.publishEvent(new SelectionChanged())\n    }\n\n    getTerrainPositionFromEvent(event): Vector2 {\n        const [cx, cy] = this.toCanvasCoords(event.clientX, event.clientY)\n        const rx = (cx / this.canvas.width) * 2 - 1\n        const ry = -(cy / this.canvas.height) * 2 + 1\n        return this.sceneMgr.getTerrainIntersectionPoint(rx, ry)\n    }\n\n    handleWheelEvent(event: GameWheelEvent): Promise<boolean> {\n        this.canvas.dispatchEvent(new WheelEvent(event.type, event))\n        return new Promise((resolve) => resolve(true))\n    }\n\n    publishEvent(event: GameEvent): void {\n        this.parent?.publishEvent(event)\n    }\n\n    registerEventListener(eventKey: EventKey, callback: (GameEvent) => any): void {\n        this.parent.registerEventListener(eventKey, callback)\n    }\n\n}\n","import { MathUtils } from 'three'\nimport { SoundManager } from '../../audio/SoundManager'\nimport { EventBus } from '../../event/EventBus'\nimport { EventKey } from '../../event/EventKeyEnum'\nimport { GameEvent } from '../../event/GameEvent'\nimport { GameKeyboardEvent } from '../../event/GameKeyboardEvent'\nimport { GamePointerEvent } from '../../event/GamePointerEvent'\nimport { GameWheelEvent } from '../../event/GameWheelEvent'\nimport { BuildingsChangedEvent, PlaySoundEvent, RaidersChangedEvent } from '../../event/LocalEvents'\nimport { MaterialAmountChanged } from '../../event/WorldEvents'\nimport { ResourceManager } from '../../resource/ResourceManager'\nimport { WorkerMessageType } from '../../resource/wadworker/WorkerMessageType'\nimport { GuiWorkerMessage } from '../../worker/GuiWorkerMessage'\nimport { WorkerEventResponse } from '../../worker/WorkerEventResponse'\nimport { WorkerPublishEvent } from '../../worker/WorkerPublishEvent'\nimport { WorkerResponse } from '../../worker/WorkerResponse'\nimport { ScreenLayer } from './ScreenLayer'\nimport generateUUID = MathUtils.generateUUID\n\nexport abstract class OffscreenLayer extends ScreenLayer {\n\n    private worker: Worker\n    resolveCallbackByEventId: Map<string, ((consumed: boolean) => any)> = new Map()\n\n    protected constructor(worker: Worker) {\n        super(true, false)\n        this.worker = worker\n        this.sendMessage({\n            type: WorkerMessageType.INIT,\n            resourceByName: ResourceManager.resourceByName,\n            cfg: ResourceManager.configuration,\n            stats: ResourceManager.stats,\n        })\n        this.worker.onmessage = (event) => {\n            const response = event.data as WorkerResponse\n            if (response.type === WorkerMessageType.RESPONSE_EVENT) {\n                const eventResponse = response as WorkerEventResponse\n                const resolve = this.resolveCallbackByEventId.get(eventResponse.eventId)\n                resolve(eventResponse.eventConsumed)\n                this.resolveCallbackByEventId.delete(eventResponse.eventId)\n            } else if (response.type === WorkerMessageType.GAME_EVENT) {\n                const event = (response as WorkerPublishEvent).gameEvent\n                if (event.eventKey === EventKey.PLAY_SOUND) {\n                    SoundManager.playSample((event as PlaySoundEvent).sample)\n                }\n                EventBus.publishEvent(event)\n            } else if (!this.onMessage(response)) {\n                console.warn('Offscreen layer ignored message: ' + WorkerMessageType[response.type])\n            }\n        }\n        EventBus.registerWorkerListener((event: GameEvent) => {\n            if (!event.guiForward) return\n            try {\n                this.sendMessage({type: WorkerMessageType.GAME_EVENT, gameEvent: event})\n            } catch (e) {\n                console.warn('Could not send event to GUI worker: ', e, event)\n            }\n        })\n    }\n\n    abstract onMessage(msg): boolean\n\n    protected sendMessage(message: GuiWorkerMessage, transfer?: Transferable[]) {\n        this.worker.postMessage(message, transfer)\n    }\n\n    reset() {\n        this.sendMessage({type: WorkerMessageType.RESET})\n        this.sendMessage({type: WorkerMessageType.GAME_EVENT, gameEvent: new BuildingsChangedEvent()})\n        this.sendMessage({type: WorkerMessageType.GAME_EVENT, gameEvent: new RaidersChangedEvent()})\n        this.sendMessage({type: WorkerMessageType.GAME_EVENT, gameEvent: new MaterialAmountChanged()})\n    }\n\n    resize(width, height) {\n        const zIndex = Number(this.canvas.style.zIndex) || 0\n        this.canvas = document.createElement('canvas')\n        if (!this.active) this.canvas.style.visibility = 'hidden'\n        super.resize(width, height)\n        this.setZIndex(zIndex)\n        const canvas = this.canvas.transferControlToOffscreen()\n        this.sendMessage({\n            type: WorkerMessageType.CANVAS,\n            canvas: canvas,\n        }, [canvas])\n    }\n\n    redraw() {\n        if (this.isActive()) this.sendMessage({type: WorkerMessageType.REDRAW})\n    }\n\n    handlePointerEvent(event: GamePointerEvent): Promise<boolean> {\n        [event.canvasX, event.canvasY] = this.toCanvasCoords(event.clientX, event.clientY)\n        return this.sendEventMessage(WorkerMessageType.EVENT_POINTER, event)\n    }\n\n    handleKeyEvent(event: GameKeyboardEvent): Promise<boolean> {\n        return this.sendEventMessage(WorkerMessageType.EVENT_KEY, event)\n    }\n\n    handleWheelEvent(event: GameWheelEvent): Promise<boolean> {\n        [event.canvasX, event.canvasY] = this.toCanvasCoords(event.clientX, event.clientY)\n        return this.sendEventMessage(WorkerMessageType.EVENT_POINTER, event)\n    }\n\n    private sendEventMessage(type: WorkerMessageType, event: GamePointerEvent | GameKeyboardEvent | GameWheelEvent): Promise<boolean> {\n        const eventId = generateUUID()\n        this.sendMessage({\n            type: type,\n            eventId: eventId,\n            inputEvent: event,\n        })\n        return new Promise((resolve) => this.resolveCallbackByEventId.set(eventId, resolve))\n    }\n\n}\n","import { WorkerMessageType } from '../../resource/wadworker/WorkerMessageType'\nimport { OffscreenLayer } from './OffscreenLayer'\n\nexport class GuiMainLayer extends OffscreenLayer {\n\n    onOptionsShow: () => any = () => console.log('Show options triggered')\n\n    constructor() {\n        super(new Worker(new URL('../../worker/GuiMainWorker', import.meta.url))) // webpack does not allow to extract the URL\n    }\n\n    onMessage(msg): boolean {\n        if (msg.type === WorkerMessageType.SHOW_OPTIONS) {\n            this.onOptionsShow()\n        } else {\n            return false\n        }\n        return true\n    }\n\n    setSpaceToContinue(state: boolean) {\n        this.sendMessage({type: WorkerMessageType.SPACE_TO_CONINUE, messageState: state})\n    }\n\n}\n","import { ObjectiveImageCfg } from '../../cfg/ObjectiveImageCfg'\nimport { WorkerMessageType } from '../../resource/wadworker/WorkerMessageType'\nimport { WorkerResponse } from '../../worker/WorkerResponse'\nimport { OffscreenLayer } from './OffscreenLayer'\n\nexport class OverlayLayer extends OffscreenLayer {\n\n    onSetSpaceToContinue: (state: boolean) => any = (state: boolean) => console.log('set space to continue: ' + state)\n    onAbortGame: () => any = () => console.log('abort the game')\n    onRestartGame: () => any = () => console.log('pause the game')\n\n    constructor() {\n        super(new Worker(new URL('../../worker/OverlayWorker', import.meta.url))) // webpack does not allow to extract the URL\n    }\n\n    onMessage(msg: WorkerResponse): boolean {\n        if (msg.type === WorkerMessageType.SPACE_TO_CONINUE) {\n            this.onSetSpaceToContinue(msg.messageState)\n        } else if (msg.type === WorkerMessageType.GAME_ABORT) {\n            this.onAbortGame()\n        } else if (msg.type === WorkerMessageType.GAME_RESTART) {\n            this.onRestartGame()\n        } else {\n            return false\n        }\n        return true\n    }\n\n    setup(objectiveText: string, objectiveBackImgCfg: ObjectiveImageCfg) {\n        this.sendMessage({\n            type: WorkerMessageType.OVERLAY_SETUP,\n            objectiveText: objectiveText,\n            objectiveBackImgCfg: objectiveBackImgCfg,\n        })\n    }\n\n    showOptions() {\n        this.sendMessage({type: WorkerMessageType.SHOW_OPTIONS})\n    }\n\n}\n","import { MOUSE_BUTTON, POINTER_EVENT } from '../../event/EventTypeEnum'\nimport { GamePointerEvent } from '../../event/GamePointerEvent'\nimport { GameState } from '../../game/model/GameState'\nimport { SceneManager } from '../../game/SceneManager'\nimport { ScreenLayer } from './ScreenLayer'\n\nexport class SelectionLayer extends ScreenLayer {\n\n    sceneMgr: SceneManager\n    selectStart: { x: number, y: number } = null\n\n    constructor() {\n        super(true, true)\n    }\n\n    reset() {\n        super.reset()\n        this.selectStart = null\n    }\n\n    handlePointerEvent(event: GamePointerEvent): Promise<boolean> {\n        if (GameState.buildModeSelection) return new Promise((resolve) => resolve(false))\n        const [cx, cy] = this.toCanvasCoords(event.clientX, event.clientY)\n        if (event.eventEnum === POINTER_EVENT.DOWN) {\n            if (event.button === MOUSE_BUTTON.MAIN) return new Promise((resolve) => resolve(this.startSelection(cx, cy)))\n        } else if (event.eventEnum === POINTER_EVENT.MOVE) {\n            return new Promise((resolve) => resolve(this.changeSelection(cx, cy)))\n        } else if (event.eventEnum === POINTER_EVENT.UP) {\n            if (event.button === MOUSE_BUTTON.MAIN) return new Promise((resolve) => resolve(this.selectEntities(cx, cy)))\n        }\n        return new Promise((resolve) => resolve(false))\n    }\n\n    startSelection(screenX: number, screenY: number) {\n        this.selectStart = {x: screenX, y: screenY}\n        return true\n    }\n\n    changeSelection(screenX: number, screenY: number) {\n        if (!this.selectStart) return false // selection was not started on this layer\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n        this.context.strokeStyle = 'rgba(128, 192, 192, 0.5)'\n        this.context.lineWidth = 2\n        this.context.strokeRect(this.selectStart.x, this.selectStart.y, screenX - this.selectStart.x, screenY - this.selectStart.y)\n        return true\n    }\n\n    selectEntities(screenX: number, screenY: number) {\n        if (!this.selectStart) return false // selection was not started on this layer\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n        const r1x = (this.selectStart.x / this.canvas.width) * 2 - 1\n        const r1y = -(this.selectStart.y / this.canvas.height) * 2 + 1\n        const r2x = (screenX / this.canvas.width) * 2 - 1\n        const r2y = -(screenY / this.canvas.height) * 2 + 1\n        if (Math.abs(screenX - this.selectStart.x) < 5 && Math.abs(screenY - this.selectStart.y) < 5) {\n            const x = (this.selectStart.x + screenX) / this.canvas.width - 1\n            const y = -(this.selectStart.y + screenY) / this.canvas.height + 1\n            this.sceneMgr.selectEntitiesByRay(x, y)\n        } else {\n            this.sceneMgr.selectEntitiesInFrustum(r1x, r1y, r2x, r2y)\n        }\n        this.selectStart = null\n        return true\n    }\n\n}\n","import { MathUtils, Vector2 } from 'three'\nimport { Sample } from '../audio/Sample'\nimport { LevelObjectiveTextEntry } from '../cfg/LevelObjectiveTextEntry'\nimport { LevelEntryCfg } from '../cfg/LevelsCfg'\nimport { clearIntervalSafe, getRandom, iGet } from '../core/Util'\nimport { EventKey } from '../event/EventKeyEnum'\nimport { RaidersChangedEvent } from '../event/LocalEvents'\nimport { RequestedRaidersChanged } from '../event/WorldEvents'\nimport { GuiManager } from '../game/GuiManager'\nimport { RaiderActivity } from '../game/model/activities/RaiderActivity'\nimport { EntityType } from '../game/model/EntityType'\nimport { GameState } from '../game/model/GameState'\nimport { MoveJob } from '../game/model/job/MoveJob'\nimport { Raider } from '../game/model/raider/Raider'\nimport { ObjectListLoader } from '../game/ObjectListLoader'\nimport { SceneManager } from '../game/SceneManager'\nimport { Supervisor } from '../game/Supervisor'\nimport { WorldManager } from '../game/WorldManager'\nimport { CHECK_SPANW_RAIDER_TIMER, TILESIZE } from '../params'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { BaseScreen } from './BaseScreen'\nimport { GameLayer } from './layer/GameLayer'\nimport { GuiMainLayer } from './layer/GuiMainLayer'\nimport { OverlayLayer } from './layer/OverlayLayer'\nimport { SelectionLayer } from './layer/SelectionLayer'\nimport degToRad = MathUtils.degToRad\n\nexport class GameScreen extends BaseScreen {\n\n    onLevelEnd: () => void = () => console.log('Level aborted')\n    gameLayer: GameLayer\n    selectionLayer: SelectionLayer\n    guiLayer: GuiMainLayer\n    overlayLayer: OverlayLayer\n    worldMgr: WorldManager\n    sceneMgr: SceneManager\n    guiMgr: GuiManager\n    spawnRaiderInterval = null\n    jobSupervisor: Supervisor\n    levelName: string\n    levelConf: LevelEntryCfg\n\n    constructor() {\n        super()\n        this.gameLayer = this.addLayer(new GameLayer(this), 0)\n        this.selectionLayer = this.addLayer(new SelectionLayer(), 10)\n        this.guiLayer = this.addLayer(new GuiMainLayer(), 20)\n        this.overlayLayer = this.addLayer(new OverlayLayer(), 30)\n        this.worldMgr = new WorldManager()\n        this.gameLayer.worldMgr = this.worldMgr\n        this.sceneMgr = new SceneManager(this.gameLayer.canvas)\n        this.cursorLayer.sceneMgr = this.sceneMgr\n        this.gameLayer.sceneMgr = this.sceneMgr\n        this.selectionLayer.sceneMgr = this.sceneMgr\n        this.jobSupervisor = new Supervisor(this.worldMgr)\n        this.guiMgr = new GuiManager(this.worldMgr, this.sceneMgr)\n        // link layer\n        this.guiLayer.onOptionsShow = () => this.overlayLayer.showOptions()\n        this.overlayLayer.onSetSpaceToContinue = (state: boolean) => this.guiLayer.setSpaceToContinue(state)\n        this.overlayLayer.onAbortGame = () => this.onLevelEnd()\n        this.overlayLayer.onRestartGame = () => this.restartLevel()\n        this.registerEventListener(EventKey.REQUESTED_RAIDERS_CHANGED, () => {\n            if (GameState.requestedRaiders > 0 && !this.spawnRaiderInterval) {\n                this.spawnRaiderInterval = setInterval(this.checkSpawnRaiders.bind(this), CHECK_SPANW_RAIDER_TIMER)\n            }\n        })\n    }\n\n    startLevel(levelName: string, levelConf: LevelEntryCfg) {\n        this.levelName = levelName\n        this.levelConf = levelConf\n        this.setupAndStartLevel()\n    }\n\n    restartLevel() {\n        this.hide()\n        GameState.reset()\n        this.setupAndStartLevel()\n    }\n\n    private setupAndStartLevel() {\n        console.log('Starting level ' + this.levelName + ' - ' + this.levelConf.fullName)\n        this.worldMgr.setup(this.levelConf, () => this.onLevelEnd())\n        this.sceneMgr.setupScene(this.levelConf, this.worldMgr)\n        // setup GUI\n        const objectiveText: LevelObjectiveTextEntry = iGet(ResourceManager.getResource(this.levelConf.objectiveText), this.levelName)\n        this.guiLayer.reset()\n        this.overlayLayer.setup(objectiveText.objective, this.levelConf.objectiveImage640x480)\n        // load in non-space objects next\n        const objectListConf = ResourceManager.getResource(this.levelConf.oListFile)\n        ObjectListLoader.loadObjectList(this.worldMgr, this.sceneMgr, objectListConf, this.levelConf.disableStartTeleport)\n        this.show()\n    }\n\n    show() {\n        super.show()\n        this.sceneMgr.startScene()\n        this.worldMgr.start()\n        this.jobSupervisor.start()\n    }\n\n    hide() {\n        this.spawnRaiderInterval = clearIntervalSafe(this.spawnRaiderInterval)\n        this.jobSupervisor.stop()\n        this.worldMgr.stop()\n        this.sceneMgr.disposeScene()\n        super.hide()\n    }\n\n    resize(width: number, height: number) {\n        super.resize(width, height)\n        this.sceneMgr?.resize(width, height)\n    }\n\n    checkSpawnRaiders() {\n        if (GameState.requestedRaiders < 1) {\n            this.spawnRaiderInterval = clearIntervalSafe(this.spawnRaiderInterval)\n            return\n        }\n        if (GameState.raiders.length >= GameState.getMaxRaiders()) return\n        const spawnBuildings = GameState.getBuildingsByType(EntityType.TOOLSTATION, EntityType.TELEPORT_PAD)\n        for (let c = 0; c < spawnBuildings.length && GameState.requestedRaiders > 0; c++) {\n            const station = spawnBuildings[c]\n            if (station.spawning) continue\n            GameState.requestedRaiders--\n            this.publishEvent(new RequestedRaidersChanged(GameState.requestedRaiders))\n            station.spawning = true\n            const raider = new Raider(this.worldMgr, this.sceneMgr)\n            const heading = station.getHeading()\n            raider.playPositionalSample(Sample.SND_teleport)\n            raider.changeActivity(RaiderActivity.TeleportIn, () => {\n                station.spawning = false\n                raider.changeActivity()\n                raider.createPickSphere()\n                const walkOutPos = station.getPosition2D().add(new Vector2(0, TILESIZE * 3 / 4 + getRandom(TILESIZE / 2))\n                    .rotateAround(new Vector2(0, 0), heading + degToRad(-10 + getRandom(20))))\n                raider.setJob(new MoveJob(walkOutPos))\n                GameState.raiders.push(raider)\n                this.publishEvent(new RaidersChangedEvent())\n            })\n            raider.addToScene(new Vector2(0, TILESIZE / 2).rotateAround(new Vector2(0, 0), station.getHeading()).add(station.getPosition2D()), heading)\n        }\n    }\n\n}\n","export class MainMenuBaseItem {\n\n    x: number = 0\n    y: number = 0\n    width: number = 0\n    height: number = 0\n    zIndex: number = 100\n    scrollAffected = false\n    needsRedraw: boolean = false\n    hover: boolean = false\n    pressed: boolean = false\n    actionName: string = ''\n    targetIndex: number = 0\n\n    static compareZ(left: MainMenuBaseItem, right: MainMenuBaseItem) {\n        return left.zIndex === right.zIndex ? 0 : left.zIndex > right.zIndex ? -1 : 1\n    }\n\n    checkHover(sx: number, sy: number): boolean {\n        const hover = sx >= this.x && sx < this.x + this.width && sy >= this.y && sy < this.y + this.height\n        if (this.hover !== hover) {\n            this.hover = hover\n            this.needsRedraw = true\n            this.onHoverChange()\n        }\n        if (!this.hover) this.pressed = false\n        return this.hover\n    }\n\n    onHoverChange() {\n    }\n\n    checkSetPressed() {\n        if (!this.hover) return\n        if (!this.pressed) this.needsRedraw = true\n        this.pressed = true\n    }\n\n    setReleased() {\n        if (this.pressed) this.needsRedraw = true\n        this.pressed = false\n    }\n\n    draw(context: SpriteContext) {\n        this.needsRedraw = false\n    }\n\n}\n","import { MenuLabelItemCfg } from '../cfg/MenuLabelItemCfg'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\nimport { MainMenuLayer } from './MainMenuLayer'\n\nexport class MainMenuIconButton extends MainMenuBaseItem {\n\n    imgNormal = null\n    imgHover = null\n    imgPressed = null\n    tooltip = ''\n\n    constructor(layer: MainMenuLayer, cfg: MenuLabelItemCfg) {\n        super()\n        this.imgNormal = ResourceManager.getImage(cfg.imgNormal)\n        this.imgHover = ResourceManager.getImage(cfg.imgHover)\n        this.imgPressed = ResourceManager.getImage(cfg.imgPressed)\n        this.tooltip = (cfg.tooltip || '').replace(/_/g, ' ')\n        this.width = Math.max(this.imgNormal.width, this.imgHover.width, this.imgPressed.width)\n        this.height = Math.max(this.imgNormal.height, this.imgHover.height, this.imgPressed.height)\n        this.x = layer.cfg.autoCenter ? (layer.fixedWidth - this.width) / 2 : layer.cfg.position[0] + cfg.x\n        this.y = layer.cfg.position[1] + cfg.y\n        this.actionName = cfg.actionName\n        if (this.actionName === 'Next') this.targetIndex = Number(cfg.target.substring('menu'.length)) - 1\n    }\n\n    draw(context: SpriteContext) {\n        super.draw(context)\n        let img = this.imgNormal\n        if (this.hover) img = this.imgHover\n        if (this.pressed) img = this.imgPressed\n        context.drawImage(img, this.x, this.y)\n    }\n\n}\n","import { MenuLabelItemCfg } from '../cfg/MenuLabelItemCfg'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\nimport { MainMenuLayer } from './MainMenuLayer'\n\nexport class MainMenuLabelButton extends MainMenuBaseItem {\n\n    labelImgLo = null\n    labelImgHi = null\n\n    constructor(layer: MainMenuLayer, cfg: MenuLabelItemCfg) {\n        super()\n        this.labelImgLo = layer.loFont.createTextImage(cfg.label)\n        this.labelImgHi = layer.hiFont.createTextImage(cfg.label)\n        this.width = Math.max(this.labelImgLo.width, this.labelImgHi.width)\n        this.height = Math.max(this.labelImgLo.height, this.labelImgHi.height)\n        this.x = layer.cfg.autoCenter ? (layer.fixedWidth - this.width) / 2 : layer.cfg.position[0] + cfg.x\n        this.y = layer.cfg.position[1] + cfg.y\n        this.actionName = cfg.actionName\n        if (this.actionName === 'Next') this.targetIndex = Number(cfg.target.substring('menu'.length)) - 1\n    }\n\n    draw(context: SpriteContext) {\n        super.draw(context)\n        const img = this.hover && !this.pressed ? this.labelImgHi : this.labelImgLo\n        context.drawImage(img, this.x, this.y)\n    }\n\n}\n","import { MenuEntryCfg } from '../cfg/MenuEntryCfg'\nimport { BitmapFont } from '../core/BitmapFont'\nimport { clearIntervalSafe } from '../core/Util'\nimport { MOUSE_BUTTON, POINTER_EVENT } from '../event/EventTypeEnum'\nimport { GamePointerEvent } from '../event/GamePointerEvent'\nimport { GameWheelEvent } from '../event/GameWheelEvent'\nimport { NATIVE_FRAMERATE } from '../params'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { ScaledLayer } from '../screen/layer/ScreenLayer'\nimport { MainMenuScreen } from '../screen/MainMenuScreen'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\nimport { MainMenuIconButton } from './MainMenuIconButton'\nimport { MainMenuLabelButton } from './MainMenuLabelButton'\nimport { MainMenuLevelButton } from './MainMenuLevelButton'\n\nexport class MainMenuLayer extends ScaledLayer {\n\n    screen: MainMenuScreen\n    cfg: MenuEntryCfg\n    loFont: BitmapFont\n    hiFont: BitmapFont\n    menuImage: SpriteImage\n    titleImage: SpriteImage\n    items: MainMenuBaseItem[] = []\n    scrollY: number = 0\n    scrollSpeedY: number = 0\n    scrollInterval = null\n\n    constructor(screen: MainMenuScreen, menuCfg: MenuEntryCfg) {\n        super()\n        this.screen = screen\n        this.cfg = menuCfg\n        this.loFont = menuCfg.loFont ? ResourceManager.getBitmapFont(menuCfg.loFont) : null\n        this.hiFont = menuCfg.hiFont ? ResourceManager.getBitmapFont(menuCfg.hiFont) : null\n        this.menuImage = menuCfg.menuImage ? ResourceManager.getImage(menuCfg.menuImage) : null\n        this.titleImage = this.loFont.createTextImage(menuCfg.fullName)\n\n        menuCfg.itemsLabel.forEach((item) => {\n            if (item.label) {\n                this.items.push(new MainMenuLabelButton(this, item))\n            } else {\n                this.items.push(new MainMenuIconButton(this, item))\n            }\n        })\n\n        this.items.sort((a, b) => MainMenuBaseItem.compareZ(a, b))\n\n        this.onRedraw = (context) => {\n            context.drawImage(this.menuImage, 0, -this.scrollY)\n            if (menuCfg.displayTitle) context.drawImage(this.titleImage, (this.fixedWidth - this.titleImage.width) / 2, this.cfg.position[1])\n            this.items.forEach((item, index) => (this.items[this.items.length - 1 - index]).draw(context))\n        }\n    }\n\n    reset() {\n        super.reset()\n        this.scrollY = 0\n        this.scrollSpeedY = 0\n    }\n\n    show() {\n        super.show()\n        const that = this\n        this.scrollInterval = setInterval(() => {\n            if (that.scrollSpeedY === 0) return\n            that.setScrollY(that.scrollSpeedY)\n        }, 1000 / NATIVE_FRAMERATE)\n    }\n\n    hide() {\n        this.scrollInterval = clearIntervalSafe(this.scrollInterval)\n        super.hide()\n    }\n\n    handlePointerEvent(event: GamePointerEvent): Promise<boolean> {\n        if (event.eventEnum === POINTER_EVENT.MOVE) {\n            const [sx, sy] = this.toScaledCoords(event.clientX, event.clientY)\n            let hovered = false\n            this.items.forEach((item) => {\n                if (!hovered) {\n                    const absY = sy + (item.scrollAffected ? this.scrollY : 0)\n                    hovered = item.checkHover(sx, absY)\n                } else {\n                    if (item.hover) item.needsRedraw = true\n                    item.hover = false\n                    item.setReleased()\n                }\n            })\n            if (this.cfg.canScroll) {\n                const scrollAreaHeight = 100\n                if (sy < scrollAreaHeight) {\n                    this.setScrollSpeedY(-(scrollAreaHeight - sy))\n                } else if (sy > this.fixedHeight - scrollAreaHeight) {\n                    this.setScrollSpeedY(sy - (this.fixedHeight - scrollAreaHeight))\n                } else {\n                    this.setScrollSpeedY(0)\n                }\n            }\n        } else if (event.eventEnum === POINTER_EVENT.DOWN) {\n            if (event.button === MOUSE_BUTTON.MAIN) {\n                this.items.forEach((item) => item.checkSetPressed())\n            }\n        } else if (event.eventEnum === POINTER_EVENT.UP) {\n            if (event.button === MOUSE_BUTTON.MAIN) {\n                this.items.forEach((item) => {\n                    if (item.pressed) {\n                        item.setReleased()\n                        if (item.actionName.toLowerCase() === 'next') {\n                            this.screen.showMainMenu(item.targetIndex)\n                        } else if (item.actionName.toLowerCase() === 'selectlevel') {\n                            this.screen.selectLevel((item as MainMenuLevelButton).levelKey)\n                        } else if (item.actionName) {\n                            console.warn('not implemented: ' + item.actionName + ' - ' + item.targetIndex)\n                        }\n                    }\n                })\n            }\n        }\n        if (this.needsRedraw()) this.redraw()\n        return new Promise((resolve) => resolve(false))\n    }\n\n    private setScrollSpeedY(deltaY: number) {\n        this.scrollSpeedY = Math.sign(deltaY) * Math.pow(Math.round(deltaY / 20), 2)\n    }\n\n    handleWheelEvent(event: GameWheelEvent): Promise<boolean> {\n        if (!this.cfg.canScroll) return new Promise((resolve) => resolve(false))\n        this.setScrollY(event.deltaY)\n        return new Promise((resolve) => resolve(true))\n    }\n\n    private setScrollY(deltaY: number) {\n        const scrollYBefore = this.scrollY\n        this.scrollY = Math.min(Math.max(this.scrollY + deltaY, 0), this.menuImage.height - this.fixedHeight)\n        if (scrollYBefore !== this.scrollY) this.redraw()\n    }\n\n    needsRedraw(): boolean {\n        return this.items.some((item) => item.needsRedraw)\n    }\n\n}\n","import { LevelEntryCfg } from '../cfg/LevelsCfg'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\nimport { MainMenuLayer } from './MainMenuLayer'\n\nexport class MainMenuLevelButton extends MainMenuBaseItem {\n\n    layer: MainMenuLayer\n    imgActive = null\n    imgInactive = null\n    imgCross = null\n    unlocked: boolean = false\n    levelKey: string = ''\n\n    constructor(layer: MainMenuLayer, levelKey: string, levelCfg: LevelEntryCfg) {\n        super()\n        this.layer = layer\n        this.actionName = 'selectlevel'\n        this.levelKey = levelKey\n        this.x = levelCfg.frontEndX\n        this.y = levelCfg.frontEndY\n        this.zIndex = 10\n        this.scrollAffected = true\n        const [imgActive, imgInactive, imgCross] = levelCfg.menuBMP\n        this.imgActive = ResourceManager.getImage(imgActive)\n        this.imgInactive = ResourceManager.getImage(imgInactive)\n        this.imgCross = ResourceManager.getImage(imgCross)\n        this.width = Math.max(this.imgActive.width, this.imgInactive.width, this.imgCross.width)\n        this.height = Math.max(this.imgActive.height, this.imgInactive.height, this.imgCross.height)\n        this.unlocked = levelCfg.frontEndOpen\n        this.unlocked = true // TODO don't unlock everything by default\n    }\n\n    draw(context: SpriteContext) {\n        super.draw(context)\n        let img = this.imgCross\n        if (this.unlocked) img = this.hover ? this.imgActive : this.imgInactive\n        context.drawImage(img, this.x, this.y - this.layer.scrollY)\n    }\n\n}\n","import { createContext } from '../core/ImageHelper'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\n\nexport class MainMenuPanel extends MainMenuBaseItem {\n\n    context: SpriteContext\n\n    constructor(imgData: ImageData, area: { x: number, y: number, w: number, h: number }) {\n        super()\n        this.zIndex = 50\n        this.context = createContext(imgData.width, imgData.height)\n        this.context.putImageData(imgData, 0, 0)\n        this.x = area.x\n        this.y = area.y\n        this.width = area.w\n        this.height = area.h\n    }\n\n    checkHover(sx: number, sy: number): boolean {\n        const inRect = sx >= this.x && sx < this.x + this.width && sy >= this.y && sy < this.y + this.height\n        const hover = inRect && this.context.getImageData(sx, sy, 1, 1).data[3] > 0\n        if (this.hover !== hover) this.needsRedraw = true\n        this.hover = hover\n        return this.hover\n    }\n\n    draw(context: SpriteContext) {\n        super.draw(context)\n        context.drawImage(this.context.canvas, this.x, this.y, this.width, this.height)\n    }\n\n}\n","import { BitmapFont } from '../core/BitmapFont'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\n\nexport class MainMenuWindow extends MainMenuBaseItem {\n\n    font: BitmapFont\n    imgFirstLine = null\n    imgSecondLine = null\n\n    constructor(font: BitmapFont, area: { x: number, y: number, w: number, h: number }) {\n        super()\n        this.font = font\n        this.x = area.x\n        this.y = area.y\n        this.width = area.w\n        this.height = area.h\n    }\n\n    setFirstLine(text: string) {\n        this.imgFirstLine = !!text ? this.font.createTextImage(text) : null\n    }\n\n    setSecondLine(text: string) {\n        this.imgSecondLine = !!text ? this.font.createTextImage(text) : null\n    }\n\n    draw(context: SpriteContext) {\n        super.draw(context)\n        const cx = this.x + this.width / 2, cy = this.y + this.height / 2\n        if (this.imgFirstLine) context.drawImage(this.imgFirstLine, cx - this.imgFirstLine.width / 2, cy - this.imgFirstLine.height)\n        if (this.imgSecondLine) context.drawImage(this.imgSecondLine, cx - this.imgSecondLine.width / 2, cy)\n    }\n\n}\n","import { LevelEntryCfg, LevelsCfg } from '../cfg/LevelsCfg'\nimport { MenuEntryCfg } from '../cfg/MenuEntryCfg'\nimport { iGet } from '../core/Util'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { MainMenuScreen } from '../screen/MainMenuScreen'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\nimport { MainMenuLayer } from './MainMenuLayer'\nimport { MainMenuLevelButton } from './MainMenuLevelButton'\nimport { MainMenuPanel } from './MainMenuPanel'\nimport { MainMenuWindow } from './MainMenuWindow'\n\nexport class LevelSelectLayer extends MainMenuLayer {\n\n    constructor(screen: MainMenuScreen, menuCfg: MenuEntryCfg, modeLevel: boolean) {\n        super(screen, menuCfg)\n        const levelsCfg: LevelsCfg = ResourceManager.getResource('Levels')\n        const levelTextCfg = new LevelTextCfg()\n        this.items.push(new MainMenuPanel(levelTextCfg.panelImgData, levelTextCfg.panelPos))\n        const levelTextWindow = new MainMenuWindow(ResourceManager.getDefaultFont(), levelTextCfg.window)\n        levelTextWindow.setFirstLine(modeLevel ? levelTextCfg.level : levelTextCfg.tutorial)\n        this.items.push(levelTextWindow)\n        Object.keys(levelsCfg.levelsByName).forEach((levelKey) => {\n            const level: LevelEntryCfg = levelsCfg.levelsByName[levelKey]\n            const levelButton = new MainMenuLevelButton(this, levelKey, level)\n            levelButton.onHoverChange = () => levelTextWindow.setSecondLine(levelButton.hover ? level.fullName : '')\n            this.items.push(levelButton)\n        })\n        this.items.sort((a, b) => MainMenuBaseItem.compareZ(a, b))\n    }\n\n}\n\nclass LevelTextCfg {\n\n    window = {x: 0, y: 0, w: 0, h: 0}\n    panelImgData: ImageData\n    panelPos = {x: 0, y: 0, w: 0, h: 0}\n    level: string = ''\n    tutorial: string = ''\n\n    constructor() {\n        const cfg = ResourceManager.cfg('Menu', 'LevelText')\n        const winCfg = iGet(cfg, 'Window')\n        this.window = {x: winCfg[0], y: winCfg[1], w: winCfg[2], h: winCfg[3]}\n        const panelCfg = iGet(cfg, 'Panel')\n        this.panelImgData = ResourceManager.getImageData(panelCfg[0])\n        this.panelPos = {x: panelCfg[1], y: panelCfg[2], w: panelCfg[3], h: panelCfg[4]}\n        this.level = LevelTextCfg.parseLabel(iGet(cfg, 'Level'))\n        this.tutorial = LevelTextCfg.parseLabel(iGet(cfg, 'Tutorial'))\n    }\n\n    private static parseLabel(cfg: any) { // TODO improve cfg handling instead\n        if (!cfg) {\n            return ''\n        } else if (Array.isArray(cfg)) {\n            return cfg.join(',').replace(/_/g, ' ')\n        } else {\n            return cfg.replace(/_/g, ' ')\n        }\n    }\n\n}\n","import { MenuCfg } from '../cfg/MenuCfg'\nimport { LevelSelectLayer } from '../menu/LevelSelectLayer'\nimport { MainMenuLayer } from '../menu/MainMenuLayer'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { BaseScreen } from './BaseScreen'\n\nexport class MainMenuScreen extends BaseScreen {\n\n    onLevelSelected: (levelName: string) => void = null\n    menus: MainMenuLayer[] = []\n\n    constructor() {\n        super()\n        const mainMenuFullCfg = ResourceManager.getResource('MainMenuFull') as MenuCfg\n        mainMenuFullCfg.menus.forEach((menuCfg) => {\n            let layer\n            if (menuCfg.title === 'Levels') {\n                layer = new LevelSelectLayer(this, menuCfg, true)\n            } else if (menuCfg.title === 'Tutorials') {\n                layer = new LevelSelectLayer(this, menuCfg, false)\n            } else {\n                layer = new MainMenuLayer(this, menuCfg)\n            }\n            this.menus.push(layer)\n            this.addLayer(layer)\n        })\n    }\n\n    showMainMenu(index: number = 0) {\n        this.menus.forEach((menu, i) => i === index ? menu.show() : menu.hide())\n        this.cursorLayer.show()\n    }\n\n    showLevelSelection() {\n        this.showMainMenu(1)\n    }\n\n    selectLevel(levelName) {\n        this.hide()\n        this.onLevelSelected(levelName)\n    }\n\n}\n","import { ResourceManager } from '../resource/ResourceManager'\nimport { MainMenuBaseItem } from './MainMenuBaseItem'\n\nexport class RewardScreenButton extends MainMenuBaseItem {\n\n    imgNormal: SpriteImage\n    imgHover: SpriteImage\n    imgPressed: SpriteImage\n    imgDisabled: SpriteImage\n    disabled: boolean = false\n    visible: boolean = true\n\n    constructor(conf: any) {\n        super()\n        let imgNormalFilepath, imgHoverFilepath, imgPressedFilepath, imgDisabledFilepath;\n        [imgNormalFilepath, imgHoverFilepath, imgPressedFilepath, imgDisabledFilepath, this.x, this.y] = conf\n        this.imgNormal = ResourceManager.getImage(imgNormalFilepath)\n        this.imgHover = ResourceManager.getImage(imgHoverFilepath)\n        this.imgPressed = ResourceManager.getImage(imgPressedFilepath)\n        this.imgDisabled = ResourceManager.getImage(imgDisabledFilepath)\n        this.width = this.imgNormal.width\n        this.height = this.imgNormal.height\n    }\n\n    draw(context: SpriteContext) {\n        super.draw(context)\n        if (!this.visible) return\n        let img = this.imgNormal\n        if (this.disabled) {\n            img = this.imgDisabled\n        } else if (this.pressed) {\n            img = this.imgPressed\n        } else if (this.hover) {\n            img = this.imgHover\n        }\n        context.drawImage(img, this.x, this.y)\n    }\n\n}\n","import { LevelRewardConfig } from '../cfg/LevelsCfg'\nimport { RewardCfg } from '../cfg/RewardCfg'\nimport { BitmapFont } from '../core/BitmapFont'\nimport { clearTimeoutSafe } from '../core/Util'\nimport { MOUSE_BUTTON, POINTER_EVENT } from '../event/EventTypeEnum'\nimport { GameResultState, GameState } from '../game/model/GameState'\nimport { RewardScreenButton } from '../menu/RewardScreenButton'\nimport { MAX_RAIDER_BASE } from '../params'\nimport { ResourceManager } from '../resource/ResourceManager'\nimport { BaseScreen } from './BaseScreen'\nimport { ScaledLayer } from './layer/ScreenLayer'\n\nexport class RewardScreen extends BaseScreen {\n\n    onAdvance: () => void\n    cfg: RewardCfg = null\n    titleFont: BitmapFont\n    resultsLayer: ScaledLayer\n    descriptionTextLayer: ScaledLayer\n    btnLayer: ScaledLayer\n    resultIndex: number = 0\n    resultLastIndex: number = 0\n    images: { img: SpriteImage, x: number, y: number }[] = []\n    boxes: { img: SpriteImage, x: number, y: number }[] = []\n    fonts = {}\n    texts: SpriteImage[] = []\n    uncoverTimeout = null\n    btnSave: RewardScreenButton\n    btnAdvance: RewardScreenButton\n    levelFullNameImg: SpriteImage\n    rewardConfig: LevelRewardConfig\n\n    constructor() {\n        super()\n        this.cfg = ResourceManager.getResource('Reward')\n        this.titleFont = ResourceManager.getBitmapFont(this.cfg.titleFont)\n        const backgroundImg = ResourceManager.getImage(this.cfg.wallpaper)\n        const backgroundLayer = this.addLayer(new ScaledLayer())\n        backgroundLayer.onRedraw = (context) => context.drawImage(backgroundImg, 0, 0)\n        this.cfg.images.forEach((img) => {\n            this.images.push({img: ResourceManager.getImage(img.filePath), x: img.x, y: img.y})\n        })\n        this.cfg.boxImages.forEach((img) => {\n            this.boxes.push({img: ResourceManager.getImage(img.filePath), x: img.x, y: img.y})\n        })\n        Object.keys(this.cfg.fonts).forEach((fontKey, index) => {\n            const font = ResourceManager.getBitmapFont(this.cfg.fonts[fontKey])\n            this.fonts[fontKey.toLowerCase()] = font\n            const txt = this.cfg.texts[index]\n            const labelFont = index < 9 ? font : ResourceManager.getBitmapFont(this.cfg.backFont)\n            this.texts.push(labelFont.createTextImage(txt.text))\n        })\n        this.resultsLayer = this.addLayer(new ScaledLayer())\n        this.resultsLayer.handlePointerEvent = ((event) => {\n            if (event.eventEnum === POINTER_EVENT.UP) {\n                this.uncoverTimeout = clearTimeoutSafe(this.uncoverTimeout)\n                this.uncoverTimeout = null\n                this.resultIndex = this.resultLastIndex\n                this.btnSave.visible = true\n                this.btnAdvance.visible = true\n                this.redraw()\n                return new Promise((resolve) => resolve(true))\n            }\n            return new Promise((resolve) => resolve(false))\n        })\n        this.descriptionTextLayer = this.addLayer(new ScaledLayer(), 20)\n        this.btnLayer = this.addLayer(new ScaledLayer(), 50)\n        this.btnSave = new RewardScreenButton(this.cfg.saveButton)\n        this.btnSave.disabled = true\n        this.btnAdvance = new RewardScreenButton(this.cfg.advanceButton)\n        this.btnLayer.handlePointerEvent = ((event) => {\n            if (event.eventEnum === POINTER_EVENT.MOVE) {\n                const [sx, sy] = this.btnLayer.toScaledCoords(event.clientX, event.clientY)\n                this.btnSave.checkHover(sx, sy)\n                this.btnAdvance.checkHover(sx, sy)\n            } else if (event.eventEnum === POINTER_EVENT.DOWN) {\n                if (event.button === MOUSE_BUTTON.MAIN) {\n                    this.btnSave.checkSetPressed()\n                    this.btnAdvance.checkSetPressed()\n                }\n            } else if (event.eventEnum === POINTER_EVENT.UP) {\n                if (event.button === MOUSE_BUTTON.MAIN) {\n                    if (this.btnSave.pressed) {\n                        this.btnSave.setReleased()\n                        // TODO switch to save screen\n                    } else if (this.btnAdvance.pressed) {\n                        this.btnAdvance.setReleased()\n                        this.hide()\n                        this.onAdvance()\n                    }\n                }\n            }\n            if (this.btnSave.needsRedraw || this.btnAdvance.needsRedraw) this.redraw()\n            return new Promise((resolve) => resolve(false))\n        })\n        this.btnLayer.onRedraw = (context) => {\n            this.btnSave.draw(context)\n            this.btnAdvance.draw(context)\n        }\n    }\n\n    show() {\n        this.resultIndex = 0\n        this.btnSave.visible = false\n        this.btnAdvance.visible = false\n        this.uncoverResult()\n        let resultText = this.cfg.quitText\n        this.resultLastIndex = this.images.length - 2\n        if (GameState.resultState === GameResultState.COMPLETE) {\n            resultText = this.cfg.completeText\n            this.resultLastIndex = this.images.length - 1\n        } else if (GameState.resultState === GameResultState.FAILED) {\n            resultText = this.cfg.failedText\n        }\n        const resultValues = []\n        resultValues.push(this.fonts['crystals'].createTextImage(this.percentString(GameState.numCrystal, GameState.neededCrystals)))\n        resultValues.push(this.fonts['ore'].createTextImage(this.percentString(GameState.numOre, GameState.totalOres)))\n        resultValues.push(this.fonts['diggable'].createTextImage(this.percentString(GameState.remainingDiggables, GameState.totalDiggables, true)))\n        resultValues.push(this.fonts['constructions'].createTextImage(GameState.buildings.length.toString()))\n        resultValues.push(this.fonts['caverns'].createTextImage(this.percentString(GameState.discoveredCaverns, GameState.totalCaverns)))\n        resultValues.push(this.fonts['figures'].createTextImage(this.percentString(GameState.raiders.length, GameState.getMaxRaiders())))\n        resultValues.push(this.fonts['rockmonsters'].createTextImage(this.percentString(0))) // TODO show defence report, is either 0% or 100%\n        resultValues.push(this.fonts['oxygen'].createTextImage(this.percentString(GameState.airLevel)))\n        resultValues.push(this.fonts['timer'].createTextImage(this.timeString(GameState.gameTimeSeconds)))\n        resultValues.push(this.fonts['score'].createTextImage(this.percentString(this.score)))\n        const gameResultTextImg = this.titleFont.createTextImage(resultText)\n        this.resultsLayer.onRedraw = (context) => {\n            context.clearRect(0, 0, this.resultsLayer.fixedWidth, this.resultsLayer.fixedHeight)\n            for (let c = 0; c <= this.resultIndex; c++) {\n                const img = this.images[c]\n                if (img) context.drawImage(img.img, img.x, img.y)\n            }\n            for (let c = 0; c <= this.resultIndex; c++) {\n                const box = this.boxes[c]\n                if (box) context.drawImage(box.img, box.x, box.y)\n            }\n            for (let c = 0; c <= this.resultIndex; c++) {\n                const txt = this.cfg.texts[c]\n                const text = resultValues[c]\n                if (text) context.drawImage(text, txt.x - text.width / 2, txt.y)\n            }\n            context.drawImage(this.levelFullNameImg, this.resultsLayer.fixedWidth / 2 - this.levelFullNameImg.width / 2, this.cfg.vertSpacing - this.levelFullNameImg.height / 2)\n            context.drawImage(gameResultTextImg, this.resultsLayer.fixedWidth / 2 - gameResultTextImg.width / 2, this.cfg.vertSpacing + this.levelFullNameImg.height / 2)\n        }\n        this.descriptionTextLayer.onRedraw = (context) => {\n            const descriptionTextImg = this.texts[this.resultIndex]\n            context.clearRect(0, this.cfg.textPos[1], this.descriptionTextLayer.fixedWidth, this.descriptionTextLayer.fixedHeight - this.cfg.textPos[1])\n            const tx = this.resultIndex !== this.images.length - 1 ? this.cfg.textPos[0] : 305\n            const ty = this.resultIndex !== this.images.length - 1 ? this.cfg.textPos[1] : 195\n            context.drawImage(descriptionTextImg, tx - descriptionTextImg.width / 2, ty)\n        }\n        super.show()\n    }\n\n    score(): number {\n        if (!this.rewardConfig) return 0\n        let quota = this.rewardConfig.quota\n        let importance = this.rewardConfig.importance\n        const scoreCrystals = GameState.numCrystal >= (quota.crystals || Infinity) ? importance.crystals : 0\n        const scoreTimer = GameState.gameTimeSeconds <= (quota.timer || 0) ? importance.timer : 0\n        const scoreCaverns = quota.caverns ? Math.min(1, GameState.discoveredCaverns / quota.caverns) * importance.caverns : 0\n        const scoreConstructions = quota.constructions ? Math.min(1, GameState.buildings.length / quota.constructions * importance.constructions) : 0\n        const scoreOxygen = GameState.airLevel * importance.oxygen\n        const scoreFigures = GameState.raiders.length >= MAX_RAIDER_BASE ? importance.figures : 0\n        return Math.max(0, Math.min(100, Math.round(scoreCrystals + scoreTimer + scoreCaverns + scoreConstructions + scoreOxygen + scoreFigures) / 100))\n    }\n\n    percentString(actual, max = 1, lessIsMore: boolean = false) {\n        if (max === 0) max = 1\n        let value = Math.round(Math.max(Math.min(actual / max, 1), 0) * 100)\n        if (lessIsMore) value = 100 - value\n        return value.toString() + '%'\n    }\n\n    padLeft(value: string, padding = '0', length = 2) {\n        while (value.length < length) value = padding + value\n        return value\n    }\n\n    timeString(seconds: number) {\n        const ss = this.padLeft((seconds % 60).toString())\n        const minutes = Math.floor(seconds / 60)\n        const mm = this.padLeft(((minutes % 60).toString()))\n        const hh = this.padLeft((Math.floor(minutes / 60).toString()))\n        return hh + ':' + mm + ':' + ss\n    }\n\n    uncoverResult() {\n        this.uncoverTimeout = setTimeout(() => {\n            this.uncoverTimeout = null\n            this.resultIndex++\n            if (this.resultIndex < this.resultLastIndex) {\n                this.uncoverResult()\n            } else {\n                this.btnSave.visible = true\n                this.btnAdvance.visible = true\n            }\n            this.redraw()\n        }, this.cfg.timer * 1000)\n    }\n\n    setup(levelFullName: string, rewardConfig: LevelRewardConfig) {\n        this.levelFullNameImg = this.titleFont.createTextImage(levelFullName)\n        this.rewardConfig = rewardConfig\n    }\n\n}\n","import { ClearCacheButton } from '../site/clearcache/ClearCacheButton'\nimport { GithubBox } from '../site/github/github-box'\nimport { WadFileSelectionModal } from '../site/modal/WadFileSelectionModal'\nimport { LevelEntryCfg } from './cfg/LevelsCfg'\nimport { getRandomInclusive } from './core/Util'\nimport { GameState } from './game/model/GameState'\nimport { DEV_MODE } from './params'\nimport { ResourceManager } from './resource/ResourceManager'\nimport { GameScreen } from './screen/GameScreen'\nimport { LoadingScreen } from './screen/LoadingScreen'\nimport { MainMenuScreen } from './screen/MainMenuScreen'\nimport { RewardScreen } from './screen/RewardScreen'\n\nif (DEV_MODE) console.warn('DEV MODE ACTIVE')\n\n// setup and link all components\n\nconst loadingScreen = new LoadingScreen()\nconst wadFileSelectModal = new WadFileSelectionModal('game-container')\nconst githubBox = new GithubBox('game-container')\nconst clearCacheButton = new ClearCacheButton('game-container')\n\nwadFileSelectModal.onStart = (wad0Url, wad1Url) => {\n    ResourceManager.startLoadingFromUrl(wad0Url, wad1Url)\n}\nResourceManager.onMessage = (msg: string) => {\n    loadingScreen.setLoadingMessage(msg)\n}\nResourceManager.onCacheMissed = () => {\n    wadFileSelectModal.show()\n}\nResourceManager.onInitialLoad = (totalResources: number) => {\n    wadFileSelectModal.hide()\n    loadingScreen.enableGraphicMode(totalResources)\n}\nResourceManager.onAssetLoaded = () => {\n    loadingScreen.increaseLoadingState()\n}\nResourceManager.onLoadDone = () => {\n    // complete setup\n    const mainMenuScreen = new MainMenuScreen()\n    const gameScreen = new GameScreen()\n    const rewardScreen = new RewardScreen()\n\n    mainMenuScreen.onLevelSelected = (levelName) => {\n        try {\n            const levelConf: LevelEntryCfg = ResourceManager.getResource('Levels').levelsByName[levelName]\n            if (!levelConf) throw 'Could not find level configuration for \"' + levelName + '\"' // TODO this could be nicer\n            rewardScreen.setup(levelConf.fullName, levelConf.reward)\n            gameScreen.startLevel(levelName, levelConf)\n        } catch (e) {\n            console.error('Could not load level: ' + levelName, e)\n            gameScreen.hide()\n            mainMenuScreen.showLevelSelection()\n        }\n    }\n    gameScreen.onLevelEnd = () => {\n        gameScreen.hide()\n        rewardScreen.show()\n    }\n    rewardScreen.onAdvance = () => {\n        GameState.reset()\n        mainMenuScreen.showLevelSelection()\n    }\n\n    // setup complete\n    loadingScreen.hide()\n    githubBox.hide()\n    clearCacheButton.hide()\n    const params = new URLSearchParams(window.location.search)\n    const entry = params.get('entry')\n    if (DEV_MODE && entry) {\n        GameState.numOre = Number(params.get('numOre')) || 0\n        GameState.numCrystal = Number(params.get('numCrystal')) || 0\n        if (entry === 'level') mainMenuScreen.showLevelSelection()\n        else if (entry === 'reward') rewardScreen.show()\n        else if (entry === 'random') mainMenuScreen.selectLevel('Level' + (('00' + getRandomInclusive(1, 25)).substr(-2)))\n        else if (entry) mainMenuScreen.selectLevel(entry)\n    } else {\n        mainMenuScreen.showMainMenu()\n    }\n}\n\n// start the game engine with loading resources\n\nloadingScreen.show()\nResourceManager.startLoadingFromCache()\n","import { ResourceManager } from '../resource/ResourceManager'\nimport { BaseScreen } from './BaseScreen'\nimport { ScaledLayer } from './layer/ScreenLayer'\n\nexport class LoadingScreen extends BaseScreen {\n\n    layer: ScaledLayer\n    assetIndex: number = 0\n\n    constructor() {\n        super()\n        this.layer = this.addLayer(new ScaledLayer())\n    }\n\n    show() {\n        this.layers.forEach((layer) => {\n            if (layer !== this.cursorLayer) layer.show()\n        })\n        this.setLoadingMessage('Loading...')\n    }\n\n    setLoadingMessage(text) {\n        this.layer.onRedraw = (context) => {\n            // clear the screen to black\n            context.fillStyle = 'black'\n            context.fillRect(0, 0, this.layer.fixedWidth, this.layer.fixedHeight)\n            // draw the loading title\n            context.font = '24px Arial'\n            context.fillStyle = 'white'\n            context.fillText('Loading Rock Raiders', 20, this.layer.fixedHeight - 50)\n            // hard-code the first loading message\n            context.font = '18px Arial'\n            context.fillStyle = 'white'\n            context.fillText(text, 20, this.layer.fixedHeight - 20)\n        }\n        this.redraw()\n    }\n\n    enableGraphicMode(totalResources: number) {\n        const imgBackground = ResourceManager.getImage(ResourceManager.cfg('Main', 'LoadScreen'))\n        const imgProgress = ResourceManager.getImage(ResourceManager.cfg('Main', 'ProgressBar'))\n        const imgLoading = ResourceManager.getDefaultFont().createTextImage(ResourceManager.cfg('Main', 'LoadingText'))\n        this.layer.onRedraw = (context => {\n            context.drawImage(imgBackground, 0, 0)\n            const loadingBarWidth = 353 * (this.assetIndex < totalResources ? Math.round(this.assetIndex / totalResources) : 1)\n            context.drawImage(imgProgress, 142, 450, loadingBarWidth, 9)\n            context.drawImage(imgLoading, Math.round(320 - imgLoading.width / 2), Math.round(456 - imgLoading.height / 2))\n        })\n        this.cursorLayer.show()\n        this.redraw()\n    }\n\n    increaseLoadingState() {\n        this.assetIndex++\n        this.redraw()\n    }\n\n}\n","export const DEV_MODE = process.env.WEBPACK_MODE === 'development'\nexport const WAD_CACHE_DB_NAME = 'RockRaidersWeb'\nexport const JOB_SCHEDULE_INTERVAL = 1000 // milliseconds\nexport const CHECK_CLEARRUBBLE_INTERVAL = 5000 // milliseconds\nexport const JOB_ACTION_RANGE = 7\nexport const CHECK_SPANW_RAIDER_TIMER = 1000 // milliseconds\nexport const MAX_RAIDER_BASE = 12\nexport const MAX_RAIDER_REQUEST = 9\nexport const ADDITIONAL_RAIDER_PER_SUPPORT = 10\nexport const UPDATE_OXYGEN_TIMER = 5000 // milliseconds\nexport const PANEL_ANIMATION_MULTIPLIER = 3\nexport const HEIGHT_MULTIPLER = 0.1\nexport const SEQUENCE_TEXTURE_FRAMERATE = 5\n\n// native constants (do not change)\n\nexport const SPRITE_RESOLUTION_WIDTH = 640\nexport const SPRITE_RESOLUTION_HEIGHT = 480\nexport const TILESIZE = 40\nexport const NATIVE_FRAMERATE = 30\n"],"sourceRoot":""}